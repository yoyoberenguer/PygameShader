
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader_gpu &#8212; PygameShader 1.0.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=9306f2a9"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PygameTools" href="PygameTools.html" />
    <link rel="prev" title="Shader" href="Shader.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Shader"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PygameShader 1.0.11 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader-gpu">
<h1>Shader_gpu<a class="headerlink" href="#shader-gpu" title="Link to this heading">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader_gpu.pyx</span></code></p>
<hr class="docutils" />
<section id="gpu-accelerated-image-processing-library">
<span id="gpu-image-processing-summary"></span><h2>1. GPU-Accelerated Image Processing Library<a class="headerlink" href="#gpu-accelerated-image-processing-library" title="Link to this heading">¶</a></h2>
<p>This library provides GPU-accelerated image processing functionality
leveraging <strong>CUDA</strong> (via <strong>CuPy</strong>) to efficiently perform various image
transformations and filters on <strong>NVIDIA GPUs</strong>. Its main purpose is to
speed up computationally expensive image processing operations that would
otherwise be slow on a CPU.</p>
</section>
<section id="key-features-use-cases">
<h2>2. Key Features &amp; Use Cases<a class="headerlink" href="#key-features-use-cases" title="Link to this heading">¶</a></h2>
<p><strong>GPU Memory &amp; Hardware Information</strong>
Retrieve details about the available GPU memory, PCI bus ID, and compute capability.
<strong>Use Case</strong>: Useful for dynamically managing memory allocation and optimizing parallel processing tasks.</p>
<dl class="simple">
<dt><strong>Image Processing &amp; Filters</strong></dt><dd><p>Perform common image filters efficiently on the GPU, including:</p>
</dd>
</dl>
<ul class="simple">
<li><p><strong>Inversion</strong>: <code class="xref py py-func docutils literal notranslate"><span class="pre">invert_gpu()</span></code></p></li>
<li><p><strong>Grayscale &amp; Sepia</strong>: <code class="xref py py-func docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></p></li>
<li><p><strong>Edge Detection</strong>: Sobel, Prewitt, Canny</p></li>
<li><p><strong>Blur &amp; Smoothing Filters</strong>: Gaussian, Median, Bilateral</p></li>
<li><p><strong>Embossing &amp; Sharpening</strong></p></li>
</ul>
</section>
<section id="use-case">
<h2>3. Use Case<a class="headerlink" href="#use-case" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>Optimized for real-time video and image processing by executing these operations in parallel on the GPU.</p>
</div></blockquote>
<p><strong>Color Manipulation &amp; Enhancements</strong>
Adjust image properties such as brightness, contrast, saturation, and HSL/HSV values.</p>
<p><strong>Use Case</strong>: Ideal for image enhancement, augmented reality (AR) applications, and photo editing software.</p>
<p><strong>Special Effects &amp; Transformations</strong>
Apply artistic transformations and effects, including:</p>
<ul class="simple">
<li><p><strong>Swirl, Fisheye, Wave, Ripple Effects</strong></p></li>
<li><p><strong>Chromatic Aberration &amp; RGB Splitting</strong></p></li>
<li><p><strong>Cartoon Effect &amp; Bloom Filters</strong></p></li>
<li><p><strong>Dithering &amp; Heatmap Effects</strong></p></li>
</ul>
<p><strong>Use Case</strong>: Useful for game development, VFX, and computer graphics applications.</p>
<p><strong>Geometric Transformations</strong>
Support for geometric transformations such as:</p>
<ul class="simple">
<li><p><strong>Mirroring</strong></p></li>
<li><p><strong>Zooming</strong></p></li>
<li><p><strong>Downscaling</strong></p></li>
<li><p><strong>Blending</strong></p></li>
</ul>
<p><strong>Use Case</strong>: Can be used for image compression, texture mapping, and real-time rendering.</p>
<p><strong>Real-Time Video Processing</strong>
Real-time video effects are supported by functions such as <code class="xref py py-func docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">predator_gpu()</span></code>, and <code class="xref py py-func docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code>.</p>
<p><strong>Use Case</strong>: Ideal for integration into streaming software, video filters, or surveillance systems.</p>
</section>
<section id="potential-applications">
<h2>4. Potential Applications<a class="headerlink" href="#potential-applications" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Real-time Image &amp; Video Processing</strong>: Enhance camera feeds in real-time.</p></li>
<li><p><strong>Computer Vision &amp; AI Preprocessing</strong>: Apply fast filters before passing images to ML models.</p></li>
<li><p><strong>Game Development &amp; Graphics</strong>: Add special effects for gaming &amp; simulation environments.</p></li>
<li><p><strong>Augmented &amp; Virtual Reality (AR/VR)</strong>: Optimize visuals for immersive experiences.</p></li>
<li><p><strong>High-performance Photography Tools</strong>: Edit large images efficiently using the GPU.</p></li>
</ul>
</section>
<section id="summary">
<h2>5. Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>This library offloads complex image processing tasks from the CPU to the GPU,
making operations significantly faster and more efficient. It is ideal for applications
that require real-time performance, such as games, AR/VR, video streaming, and AI-based
image processing.</p>
</section>
<section id="cython-list-methods">
<h2>6. Cython list methods<a class="headerlink" href="#cython-list-methods" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_free_mem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_free_mem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_free_mem" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the available free memory on the GPU.</p>
<p>This function queries the GPU device for its current free memory and
returns the amount in bytes. It is useful for monitoring memory usage
when working with GPU-accelerated computations, ensuring that operations
do not exceed available memory.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>int</strong>: The amount of free GPU memory in bytes.</p></li>
</ul>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">free_mem</span> <span class="o">=</span> <span class="n">get_gpu_free_mem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available GPU Memory: </span><span class="si">{</span><span class="n">free_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_maxmem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_maxmem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_maxmem" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the total memory capacity of the GPU.</p>
<p>This function queries the GPU device to determine its total available
memory, representing the total VRAM capacity of the GPU.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>int</strong>: The total GPU memory in bytes.</p></li>
</ul>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_mem</span> <span class="o">=</span> <span class="n">get_gpu_maxmem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total GPU Memory: </span><span class="si">{</span><span class="n">total_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_pci_bus_id">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_pci_bus_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_pci_bus_id" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the PCI Bus ID of the GPU.</p>
<p>This function queries the GPU device and returns its PCI Bus ID,
which uniquely identifies the GPU within the system. The PCI Bus ID
is useful for multi-GPU setups, debugging, and device management.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: The PCI Bus ID of the GPU in the format “Domain:Bus:Device.Function”
(e.g., “0000:01:00.0”).</p></li>
</ul>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pci_id</span> <span class="o">=</span> <span class="n">get_gpu_pci_bus_id</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU PCI Bus ID: </span><span class="si">{</span><span class="n">pci_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_compute_capability">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_compute_capability</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_compute_capability" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the compute capability of the GPU.</p>
<p>Compute capability represents the GPU architecture version and determines
its compatibility with various CUDA features. Higher compute capability
values indicate support for more advanced features and optimizations.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: The compute capability of the GPU as a string in the format “major.minor”
(e.g., “7.5” for NVIDIA Turing GPUs).</p></li>
</ul>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">capability</span> <span class="o">=</span> <span class="n">get_compute_capability</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU Compute Capability: </span><span class="si">{</span><span class="n">capability</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_max_grid_per_block">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_max_grid_per_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_max_grid_per_block" title="Link to this definition">¶</a></dt>
<dd><p>Retrieve the maximum number of grid blocks per multiprocessor.</p>
<p>This function returns the maximum number of grid blocks that can be active
per multiprocessor on the GPU. This value is essential for optimizing
parallel workloads and ensuring efficient resource utilization.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>unsigned int</strong>: The maximum number of grid blocks per multiprocessor.</p></li>
</ul>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_grid_blocks</span> <span class="o">=</span> <span class="n">get_max_grid_per_block</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max grid blocks per multiprocessor: </span><span class="si">{</span><span class="n">max_grid_blocks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The returned value depends on the GPU’s compute capability.</p></li>
<li><p>For instance, GPUs with Compute Capability 2.x support up to
8 active blocks per multiprocessor, while Compute Capability 3.x
and higher can support up to 16 or more active blocks per multiprocessor.
Refer to NVIDIA’s CUDA programming guide for specific values per architecture.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_grid">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_grid" title="Link to this definition">¶</a></dt>
<dd><p>Automatically computes optimal grid and block sizes for GPU execution.</p>
<p>This function determines the best grid and block configuration for GPU execution based on
the dimensions of the display (or computational domain). It ensures that the computed grid
and block sizes are valid and compatible with the given width (<cite>w</cite>) and height (<cite>h</cite>).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>): The width of the display or computational domain. Must be greater than 0.</p></li>
<li><p><strong>h</strong> (<em>int</em>): The height of the display or computational domain. Must be greater than 0.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong>: A tuple containing:
- <cite>grid</cite>: (<em>y, x</em>) - The computed grid size (number of blocks in each dimension).
- <cite>block</cite>: (<em>yy, xx</em>) - The computed block size (number of threads per block in each dimension).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>:
- If <cite>w</cite> or <cite>h</cite> is less than or equal to 0.
- If the computed grid and block sizes are not valid (i.e., they do not exactly cover the input dimensions).</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function first determines possible divisors of <cite>w</cite> and <cite>h</cite>, then selects block sizes that
do not exceed 32 (a common maximum block size for GPU execution).</p></li>
<li><p>The final grid size is determined by dividing the input dimensions by the selected block sizes.</p></li>
<li><p>If the computed configuration is invalid (i.e., <cite>yy * y != h</cite> or <cite>xx * x != w</cite>), an assertion
error is raised, suggesting that manual configuration might be necessary.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="n">block_grid</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>  <span class="c1"># Output: (4, 4) (16, 16)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.conv">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">conv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.conv" title="Link to this definition">¶</a></dt>
<dd><p>Convert a value to a human-readable format,
scaling it by powers of 1024 (e.g., KB, MB, GB).</p>
<p>This function divides the input value <cite>v</cite> by 1024 repeatedly until
it is less than or equal to 1024. It then returns the value with its
appropriate unit (e.g., KB, MB, GB) based on the number of divisions performed.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>v</strong> (<em>float</em> or <em>int</em>): The value to be converted (typically representing bytes or data size).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: A human-readable string representing the value with an appropriate unit, rounded to 3 decimal places.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function uses the following units:
- 1024 bytes = 1 KB
- 1024 KB = 1 MB
- 1024 MB = 1 GB
- and so on…</p></li>
<li><p>If the input value <cite>v</cite> is smaller than 1024, it will be returned as is with the first unit.</p></li>
<li><p>The function ensures that the appropriate unit is selected based on the scale of <cite>v</cite>.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">conv</span><span class="p">(</span><span class="mi">1048576</span><span class="p">)</span>  <span class="c1"># Returns &#39;1.0 MB&#39;</span>
<span class="n">conv</span><span class="p">(</span><span class="mi">123456789</span><span class="p">)</span>  <span class="c1"># Returns &#39;117.74 MB&#39;</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_and_grid_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_and_grid_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_and_grid_info" title="Link to this definition">¶</a></dt>
<dd><p>Calculate and display the appropriate GPU block and grid dimensions for a given image size.</p>
<p>This function computes the grid and block sizes required for optimal GPU parallelization.
It utilizes the <cite>block_grid</cite> function to determine the best block and grid sizes based on the
provided width (<cite>w</cite>) and height (<cite>h</cite>) of the image or display.</p>
<p>The block and grid sizes are then validated to ensure they can correctly cover the entire area.
If the validation fails, assertions are raised. Afterward, the function prints the resulting
grid and block sizes.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>): The width of the image or display (must be greater than 0).</p></li>
<li><p><strong>h</strong> (<em>int</em>): The height of the image or display (must be greater than 0).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>:
- If either <cite>w</cite> or <cite>h</cite> is non-positive.
- If the calculated grid and block sizes do not properly cover the image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: This function only prints the GPU grid and block information. It does not return any values.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">block_and_grid_info</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">)</span>
<span class="c1"># Output:</span>
<span class="c1"># GPU GRID        : (grid_y=34.000000, grid_x=60.000000)</span>
<span class="c1"># GPU BLOCK       : (block_y=32.000000, block_x=32.000000)</span>
</pre></div>
</div>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The grid is determined by the number of blocks required to cover the image’s height and width.</p></li>
<li><p>The block size refers to the size of each individual block of threads in the GPU.</p></li>
<li><p>This function assumes the GPU processing will be optimized for the calculated grid and block sizes.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_info" title="Link to this definition">¶</a></dt>
<dd><p>Display detailed GPU information, including memory, compute capability, and PCI bus ID.</p>
<p>This function retrieves and prints various details about the GPU, including:
- The installed CuPy version.
- The maximum grid size per block supported by the GPU.
- The available and total GPU memory, both in bytes and human-readable formats.
- The PCI Bus ID of the GPU.
- The compute capability of the GPU.</p>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: This function prints GPU-related information to the console.</p></li>
</ul>
<p><strong>Example output:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_gpu_info</span><span class="p">()</span>
<span class="c1"># Output:</span>
<span class="c1"># CUPY VERSION           : 11.2.0</span>
<span class="c1"># GPU MAX GRID PER BLOCK : 65535</span>
<span class="c1"># GPU FREE MEMORY        : (mem=8388608000.000000, (8.0 GB))</span>
<span class="c1"># GPU MAX MEMORY         : (mem=17179869184.000000, (16.0 GB))</span>
<span class="c1"># GPU PCI BUS ID         : (bus=0000:01:00.0)</span>
<span class="c1"># GPU CAPABILITY         : (capa=7.5)</span>
</pre></div>
</div>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function relies on CuPy for GPU memory information.</p></li>
<li><p>The <cite>conv</cite> function is used to convert raw memory values into a more readable format (e.g., GB).</p></li>
<li><p>This function is useful for debugging and verifying GPU resource availability before launching CUDA-based operations.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Perform GPU-accelerated color inversion on a Pygame surface (returns a copy).</p>
<p>This function transfers the image data from a <cite>pygame.Surface</cite> to the GPU,
inverts the color values using CuPy, and then reconstructs a new surface
with the modified pixel data.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A Pygame surface object (24-bit or 32-bit) containing the image to be inverted.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with inverted colors, preserving the original format (BGR or BGRA).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If the surface cannot be referenced as a 1D buffer or has zero length.</p></li>
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> object.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>Uses CuPy to perform the inversion directly on the GPU for optimal performance.</p></li>
<li><p>Automatically detects whether the surface is 24-bit (BGR) or 32-bit (BGRA).</p></li>
<li><p>Synchronizes the GPU to ensure completion before returning the processed image.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">inverted_surface</span> <span class="o">=</span> <span class="n">invert_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">inverted_surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Perform in-place GPU-accelerated color inversion on a Pygame surface.</p>
<p>This function directly modifies the pixel data of the given <cite>pygame.Surface</cite>
by inverting its color values using GPU processing via CuPy. The inversion
is performed in-place, meaning the original surface is altered without
creating a new one.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The Pygame surface whose pixel colors will be inverted.
Must be a valid 24-bit (BGR) or 32-bit (BGRA) surface.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>ValueError</strong>: If the surface buffer cannot be accessed or has zero length.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function transfers the pixel data to the GPU, performs the inversion,
and copies the modified pixels back to the original surface.</p></li>
<li><p>Uses CuPy for efficient GPU computation.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">invert_gpu_inplace</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Perform in-place inversion of a BGR pixel buffer using the GPU.</p>
<p>This function takes a contiguous 1D BGR buffer (as a NumPy array or memoryview),
transfers it to the GPU, inverts the pixel values (255 - pixel value), and
writes the result back into the original buffer.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> or <em>memoryview</em>): A contiguous 1D array representing the BGR pixel buffer. The buffer must be mutable and non-empty.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>bgr_array</cite> is not a NumPy array or a memoryview.</p></li>
<li><p><strong>ValueError</strong>: If <cite>bgr_array</cite> is empty (has zero length).</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function modifies <cite>bgr_array</cite> in place.</p></li>
<li><p>Uses CUDA-enabled CuPy for GPU acceleration.</p></li>
<li><p>Suitable for high-performance image processing where in-place modification is necessary.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Example BGR array</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to CuPy array</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Invert colors in place</span>
<span class="n">invert_buffer_gpu</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to NumPy array</span>
<span class="n">inverted_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inverted_bgr_array</span><span class="p">)</span>  <span class="c1"># Output: [  0 255 255 255   0 255 255 255   0]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_rgb_array_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_rgb_array_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_rgb_array_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Inverts the RGB values of an image (3D numpy array or memoryview) in place using GPU.</p>
<p>This function performs an in-place inversion of the RGB channels in the input array.
It operates on the assumption that the input <cite>rgb_array</cite> is a 3D numpy array or memoryview
with shape (height, width, 3), where the last dimension represents the RGB color channels.</p>
<p><strong>Note</strong>: This operation is performed using GPU to speed up the computation.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em> or <em>memoryview</em>): A 3D array or memoryview of shape (height, width, 3) containing the RGB values of the image. The dtype must be <em>numpy.uint8</em>. If <cite>rgb_array</cite> is a memoryview, it should be of a compatible type.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>rgb_array</cite> is not a <em>numpy.ndarray</em> or <em>memoryview</em>.</p></li>
<li><p><strong>ValueError</strong>: If the <cite>rgb_array</cite> is not of dtype <em>numpy.uint8</em> or does not have 3 dimensions. If the width or height of the array is zero.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>This function directly modifies the input <cite>rgb_array</cite> by inverting the RGB channels using GPU-accelerated operations. The inversion is done in place, meaning the original array will be updated. The GPU is used to perform the inversion efficiently.</p>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a white image of shape (100, 100, 3)</span>
<span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

<span class="c1"># Invert the image colors in place</span>
<span class="n">invert_rgb_array_inplace</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">)</span>

<span class="c1"># Print the color of the first pixel, should be black [0, 0, 0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Sepia shader to a Pygame surface and return a new surface with the Sepia effect applied.</p>
<p>This function works with Pygame surfaces of both 32-bit and 24-bit color depth.
It uses GPU-based computations to transform the pixel colors by applying a Sepia filter.</p>
<p>The function first checks the type of the provided surface to ensure it’s a valid
Pygame Surface. Then it extracts the pixel data from the surface, applies the Sepia
filter using a GPU-based kernel, and returns a new Pygame surface with the transformed image.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A Pygame Surface object containing the image to which the Sepia filter will be applied. The surface is expected to be in 32-bit or 24-bit format.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame Surface object with the same dimensions and the Sepia filter applied, in the “RGB” format.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the Sepia effect efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the Sepia effect is returned.</p></li>
<li><p>Ensure that the Pygame surface is in a compatible format (24-bit or 32-bit) before applying the filter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sepia filter</span>
<span class="n">sepia_surface</span> <span class="o">=</span> <span class="n">sepia_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sepia_surface</span><span class="p">,</span> <span class="s2">&quot;sepia_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_rgb_array_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_rgb_array_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_rgb_array_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Sepia filter in-place to an RGB image array using GPU acceleration.</p>
<p>This function processes a 32-bit or 24-bit image in-place by modifying the provided
<cite>numpy.ndarray</cite> of shape (w, h, 3) containing uint8 RGB values. The Sepia effect
is applied directly to the input array without creating a new array.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em>): A 3D numpy array with shape (w, h, 3), representing an image with RGB pixel values in the uint8 data type. The shape should represent the width (w), height (h), and three channels (Red, Green, Blue).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: This function modifies the input <cite>rgb_array</cite> in-place and returns nothing.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the Sepia effect efficiently.</p></li>
<li><p>The input array is modified directly; no new array is created.</p></li>
<li><p>Ensure that the input array is of dtype <cite>numpy.uint8</cite> and has three dimensions representing the RGB channels.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample RGB image (100x100 pixels)</span>
<span class="n">rgb_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">rgb_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_rgb_array_gpu</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_rgb_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Sepia filter to a BGR or BGRA image buffer on the GPU (in-place).</p>
<p>This function uses a GPU kernel to apply a Sepia effect to an image stored in either a
BGR or BGRA format. The operation is performed on the input image buffer (<cite>bgr_array</cite>),
which is a 1D array or memoryview representing the pixel data in either BGR or BGRA format.</p>
<p>The function assumes the buffer is laid out as a 1D array, where each pixel consists of
3 or 4 bytes (depending on whether it is in BGR or BGRA format). The Sepia effect is applied
in parallel on the GPU using a CUDA kernel, and the result is stored directly in the input
buffer.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid_</strong> (<em>tuple</em>): The block grid dimensions to be used for the kernel launch, typically obtained
from a helper function such as <cite>block_grid()</cite>.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): The block dimensions to be used for the kernel launch, typically obtained
from a helper function such as <cite>block_grid()</cite>.</p></li>
<li><p><strong>w</strong> (<em>Py_ssize_t</em>): The width of the image, in pixels. Must be greater than 0.</p></li>
<li><p><strong>h</strong> (<em>Py_ssize_t</em>): The height of the image, in pixels. Must be greater than 0.</p></li>
<li><p><strong>bgr_array</strong> (<em>unsigned char [::1]</em>): A 1D array or memoryview containing the image pixel data. This array represents
the image in either BGR (3 channels) or BGRA (4 channels) format, with each pixel
occupying 3 or 4 consecutive bytes.</p></li>
<li><p><strong>format_32</strong> (<em>bint</em>, optional): A boolean flag indicating whether the input array is in BGRA format (True) or BGR
format (False). Default is False (BGR format).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: This function modifies the input <cite>bgr_array</cite> in-place and returns nothing.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>bgr_array</cite> is not a valid numpy.ndarray or memoryview.</p></li>
<li><p><strong>ValueError</strong>: If the dimensions of the input image or the buffer length do not match
the expected values based on the width, height, and pixel format.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the Sepia effect efficiently.</p></li>
<li><p>The input array is modified directly; no new array is created.</p></li>
<li><p>Ensure that the input array is of dtype <cite>numpy.uint8</cite> and has three or four dimensions representing the RGB or RGBA channels.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Bright Pass Filter (BPF) effect to a Pygame surface using GPU acceleration.</p>
<p>This function applies a Bright Pass Filter to an image represented by a Pygame.Surface.
The filter retains pixels with brightness values above a specified threshold and sets
others to black. The operation is performed on the GPU to enhance performance.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input surface (image) on which the Bright Pass Filter effect will be applied.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optional): The brightness threshold in the range [0, 255]. Pixels with a brightness value
greater than or equal to the threshold will retain their color, while those below will be set to black.
Default is 128.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame.Surface with the Bright Pass Filter effect applied, in RGB format, with the same width and height as the input surface.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> type.</p></li>
<li><p><strong>ValueError</strong>: If there is an issue referencing the surface pixels into a 3D array, or if the surface dimensions are invalid.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the Bright Pass Filter efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the Bright Pass Filter effect is returned.</p></li>
<li><p>Ensure that the Pygame surface is in a compatible format (24-bit or 32-bit) before applying the filter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_surface</span> <span class="o">=</span> <span class="n">bpf_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bpf_surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_inplace_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_inplace_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_inplace_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Bright Pass Filter (BPF) to a Pygame surface in-place using GPU acceleration.</p>
<p>This function applies a Bright Pass Filter effect to an image on the GPU. The filter retains
pixels with brightness values greater than or equal to a specified threshold, setting others to black.
The operation is done in-place, modifying the input surface directly.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input surface (image) on which the Bright Pass Filter effect will be applied. The surface should be in RGB format.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Specifies the grid configuration for the GPU kernel. This determines how the work is divided across multiple threads in the GPU. Grid dimensions should match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Specifies the block configuration for the GPU kernel. This defines the number of threads within a block. The maximum number of threads per block is 1024. Block size should be chosen to optimize performance on the hardware.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optional): The brightness threshold (in the range [0, 255]) that determines which pixels are kept. Pixels with a brightness value greater than or equal to the threshold remain unchanged, while pixels below the threshold are set to black. Default is 128.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: The function modifies the input <cite>surface_</cite> in-place and returns nothing.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> type.</p></li>
<li><p><strong>ValueError</strong>: If there is an issue referencing the surface pixels into a 3D array, or if the surface dimensions are invalid.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the Bright Pass Filter efficiently.</p></li>
<li><p>The input surface is modified directly; no new surface is created.</p></li>
<li><p>Ensure that the Pygame surface is in a compatible format (24-bit or 32-bit) before applying the filter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_inplace_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a band-pass filter (BPF) to an image buffer using GPU acceleration.</p>
<p>This function processes an image buffer represented by a 1D array or memoryview in either BGR or BGRA format.
The BPF retains pixels with brightness values within a specified range and sets others to black.
The operation is performed on the GPU to enhance performance.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>): Grid size for GPU kernel execution (blocks per grid).</p></li>
<li><p><strong>block</strong> (<em>tuple</em>): Block size for GPU kernel execution (threads per block).</p></li>
<li><p><strong>w</strong> (<em>int</em>): Width of the image in pixels.</p></li>
<li><p><strong>h</strong> (<em>int</em>): Height of the image in pixels.</p></li>
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> or <em>memoryview</em>): Input image buffer in BGR or BGRA format.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optional): Threshold value used for filtering (default: 128).</p></li>
<li><p><strong>format_32</strong> (<em>bool</em>, optional): If True, treats the input buffer as BGRA (4 bytes per pixel). If False, treats it as BGR (3 bytes per pixel).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: The function modifies <cite>bgr_array</cite> in-place with the filtered image.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>bgr_array</cite> is not a numpy.ndarray or memoryview.</p></li>
<li><p><strong>ValueError</strong>: If <cite>bgr_array</cite> is empty or does not match the expected size.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to apply the BPF efficiently.</p></li>
<li><p>The input array is modified directly; no new array is created.</p></li>
<li><p>Ensure that the input array is of dtype <cite>numpy.uint8</cite> and has three or four dimensions representing the RGB or RGBA channels.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the BPF with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">filtered_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Converts a Pygame surface to grayscale using GPU acceleration.</p>
<p>This function takes a Pygame surface in 24-bit or 32-bit format, processes
it on the GPU to convert it to grayscale, and returns a new 24-bit grayscale surface.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A Pygame surface with a 24-bit or 32-bit color format.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new 24-bit grayscale Pygame surface.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a Pygame surface.</p></li>
<li><p><strong>ValueError</strong>: If the surface cannot be converted into a 3D array view, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to perform the grayscale conversion efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the grayscale effect is returned.</p></li>
<li><p>Ensure that the Pygame surface is in a compatible format (24-bit or 32-bit) before applying the filter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_lum_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_lum_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_lum_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Converts a Pygame surface to grayscale using GPU acceleration with a luminance-based method.</p>
<p>This function takes a Pygame surface in 24-bit or 32-bit format, processes
it on the GPU using a luminance-based grayscale conversion, and returns
a new 24-bit grayscale Pygame surface.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A Pygame surface with a 24-bit or 32-bit color format.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new 24-bit grayscale Pygame surface.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a Pygame surface.</p></li>
<li><p><strong>ValueError</strong>: If the surface cannot be converted into a 3D array view, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to perform the grayscale conversion efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the grayscale effect is returned.</p></li>
<li><p>Ensure that the Pygame surface is in a compatible format (24-bit or 32-bit) before applying the filter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_lum_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_generic_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_generic_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_generic_filter_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a median filter to a Pygame surface using GPU acceleration.</p>
<p>This function utilizes a generic median filter, which processes each
pixel based on neighboring values. The filter operates on 24-bit and
32-bit surfaces by applying a kernel function.</p>
<p><strong>Performance Consideration:</strong>
The median filter uses a kernel with a buffer of type <cite>double</cite>, which
may result in lower performance compared to specialized GPU-based median
filtering methods.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input Pygame surface, expected to be in 24-bit or 32-bit format.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, optional): The size of the neighborhood window used for the median filter. Must be greater than zero. Default is 5.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the median filter applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If <cite>size_</cite> is less than or equal to zero, or if the input surface has zero width or height.</p></li>
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function leverages CuPy (<cite>cp.asarray</cite>) for GPU-accelerated computation.</p></li>
<li><p>The filter operates on each color channel (R, G, B) separately.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_generic_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_filter_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a median filter to a Pygame surface using GPU acceleration.</p>
<p>The median filter is a non-linear filter that reduces noise by replacing
each pixel with the median value of its surrounding neighbors.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input Pygame surface to be processed.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, optional): The size of the neighborhood considered for median filtering. Must be greater than zero. Default is 5.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the median filter applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>: If <cite>size_</cite> is not greater than zero.</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> is not a valid Pygame surface, or if the surface cannot be referenced as a 3D array, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function leverages CuPy (<cite>cp.asarray</cite>) for GPU-accelerated computation.</p></li>
<li><p>The filter operates on each color channel (R, G, B) separately.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_5x5_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a 5x5 Gaussian blur to an image using GPU-accelerated processing.</p>
<p>This function convolves each RGB channel of the given surface with a
5x5 Gaussian blur kernel to create a smoothing effect while preserving edges.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A 24-bit or 32-bit Pygame surface to be blurred.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the applied Gaussian blur in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid Pygame surface.</p></li>
<li><p><strong>ValueError</strong>: If the surface dimensions are invalid or pixel data cannot be accessed.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function uses <cite>pixels3d(surface_)</cite> to extract the pixel array.</p></li>
<li><p>The computation is performed on the GPU for efficiency.</p></li>
<li><p><cite>gaussian_5x5_cupy</cite> is called to apply the blur effect.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 5x5 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_5x5_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_3x3_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_3x3_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_3x3_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a 3x3 Gaussian blur to a Pygame surface using GPU acceleration.</p>
<p>This function converts a given <cite>pygame.Surface</cite> to a GPU-compatible array,
applies a 3x3 Gaussian blur filter to each color channel (R, G, B), and
returns a new blurred <cite>pygame.Surface</cite>.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A 24-bit or 32-bit <cite>pygame.Surface</cite> representing the input image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new <cite>pygame.Surface</cite> with the Gaussian blur effect applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface has invalid dimensions or cannot be converted into an array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function assumes that <cite>gaussian_kernel_3x3</cite> is predefined.</p></li>
<li><p><cite>cp.cuda.Stream.null.synchronize()</cite> ensures the GPU operations complete before returning.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 3x3 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_3x3_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sobel_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sobel_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sobel_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply the Sobel edge detection filter to a grayscale image using GPU acceleration.</p>
<p>This function assumes the input image is grayscale, meaning the same intensity
is present in all three RGB channels. It applies the Sobel filter using only the red
channel (<cite>R</cite>), though the green (<cite>G</cite>) or blue (<cite>B</cite>) channels could also be used.</p>
<p>If the input image is not truly grayscale, the Sobel effect may vary slightly because
the RGB channels might have different intensities.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A 24-bit or 32-bit <cite>pygame.Surface</cite> representing the input image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new <cite>pygame.Surface</cite> with the Sobel edge detection effect applied in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface has invalid dimensions or cannot be converted into an array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function assumes that <cite>sobel_cupy()</cite> is implemented to process the GPU array.</p></li>
<li><p>The final image retains the <cite>RGB</cite> format, but only the red channel is modified.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sobel edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">sobel_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.prewitt_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">prewitt_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.prewitt_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply the Prewitt edge detection algorithm to a grayscale image using GPU acceleration.</p>
<p>This function assumes the input image is grayscale, meaning the same intensity
is present in all three RGB channels. It applies the Prewitt filter using only the red
channel (<cite>R</cite>), though the green (<cite>G</cite>) or blue (<cite>B</cite>) channels could also be used.</p>
<p>If the input image is not truly grayscale, the Prewitt effect may vary slightly because
the RGB channels might have different intensities.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A 24-bit or 32-bit <cite>pygame.Surface</cite> representing the input image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new <cite>pygame.Surface</cite> with the Prewitt edge detection effect applied in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface has invalid dimensions or cannot be converted into an array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function assumes that <cite>prewitt_cupy()</cite> is implemented to process the GPU array.</p></li>
<li><p>The final image retains the <cite>RGB</cite> format, but only the red channel is modified.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Prewitt edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">prewitt_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.canny_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">canny_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.canny_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply the Canny edge detection algorithm to a grayscale image using GPU acceleration.</p>
<p>This function assumes the input image is grayscale, meaning the same intensity
is present in all three RGB channels. It applies the Canny edge detection algorithm
using only the red channel (<cite>R</cite>), though the green (<cite>G</cite>) or blue (<cite>B</cite>) channels could
also be used. If the input image is not truly grayscale, the Canny effect may vary
slightly because the RGB channels might have different intensities.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A 24-bit or 32-bit <cite>pygame.Surface</cite> representing the input image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new <cite>pygame.Surface</cite> with the Canny edge detection effect applied in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface has invalid dimensions or cannot be converted into an array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function assumes that <cite>canny_cupy()</cite> is implemented to process the GPU array.</p></li>
<li><p>The final image retains the <cite>RGB</cite> format, but only the red channel is modified.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Canny edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">canny_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.color_reduction_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">color_reduction_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.color_reduction_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a color reduction effect to an image using GPU acceleration.</p>
<p>This function reduces the number of unique colors in the image by quantizing each RGB channel.
For example, if <cite>color_number=8</cite>, each channel will have 8 distinct levels (0, 32, 64, …, 255),
resulting in a total of 8^3 possible colors.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input surface (image) to which the color reduction will be applied.</p></li>
<li><p><strong>color_number</strong> (<em>int</em>, optional): The number of colors (levels) to reduce each RGB channel to. The default value is 8. The number of colors in the palette will be <cite>color_number^3</cite>.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new surface with the color reduction effect applied, in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If the <cite>surface_</cite> argument is not a valid <cite>pygame.Surface</cite> instance.</p></li>
<li><p><strong>ValueError</strong>: If the <cite>color_number</cite> is less than or equal to 0 or if the surface has invalid dimensions.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The color reduction is achieved by quantizing each RGB color channel.</p></li>
<li><p>The function works with 32-bit and 24-bit images (Pygame Surface format).</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the color reduction with a palette size of 8</span>
<span class="n">reduced_surface</span> <span class="o">=</span> <span class="n">color_reduction_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">color_number</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">reduced_surface</span><span class="p">,</span> <span class="s2">&quot;reduced_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsv_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsv_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsv_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a hue rotation effect to an image using GPU acceleration.</p>
<p>This function modifies the hue of each pixel in the image while preserving its
saturation and brightness, effectively shifting colors while maintaining overall
image structure.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input surface (image) on which the hue rotation effect will be applied.</p></li>
<li><p><strong>val_</strong> (<em>float</em>): The hue shift value, which must be within the range [0.0, 1.0].
- <cite>0.0</cite> corresponds to a -180° shift (full backward rotation).
- <cite>0.5</cite> represents 0° shift (no change).
- <cite>1.0</cite> corresponds to a +180° shift (full forward rotation).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Specifies the CUDA grid dimensions for kernel execution.
- Example: <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>.
- The grid size should be tuned according to the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Specifies the CUDA block dimensions for kernel execution.
- Example: <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>.
- The total number of threads (<cite>block_x * block_y</cite>) must not exceed 1024 due to GPU hardware limitations.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new surface containing the hue-modified image, returned in 24-bit RGB format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite> instance.</p></li>
<li><p><strong>ValueError</strong>: If the input surface has zero width or height, if <cite>val_</cite> is out of the valid range [0.0, 1.0], or if the surface pixels cannot be referenced as a 3D array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The input image must be in RGB format before applying this transformation.</p></li>
<li><p>The function performs hue rotation using GPU acceleration with CuPy for optimized performance.</p></li>
<li><p>The transformation works by converting RGB to HSV, modifying the H (hue) channel, and then converting it back to RGB.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the hue rotation with a shift value of 0.5 (no change)</span>
<span class="n">rotated_surface</span> <span class="o">=</span> <span class="n">hsv_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">val_</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">grid_</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">block_</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rotated_surface</span><span class="p">,</span> <span class="s2">&quot;rotated_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mult_downscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mult_downscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mult_downscale_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Perform bloom downscaling by progressively reducing image resolution.</p>
<p>This function downscales an input GPU-based image into four progressively
smaller sub-arrays with resolutions reduced by factors of 2, 4, 8, and 16.
It is compatible with 24-bit and 32-bit images (RGB format, uint8).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array</strong> (<em>cupy.ndarray</em>): A 3D CuPy array with shape (height, width, 3) and dtype uint8,
representing an RGB image stored on the GPU.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>tuple of cupy.ndarray</strong>: A tuple containing four downscaled versions of the input image
with shapes (H/2, W/2, 3), (H/4, W/4, 3), (H/8, W/8, 3), and (H/16, W/16, 3).</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function performs downscaling using <cite>cupyx.scipy.ndimage.zoom</cite>,
applying nearest-neighbor interpolation (<cite>order=0</cite>) to preserve hard edges.</p></li>
<li><p>Pixels outside the boundaries are filled with zero (<cite>mode=’constant’, cval=0.0</cite>).</p></li>
<li><p>GPU synchronization is performed to ensure all CUDA operations complete before returning.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">downscaled_images</span> <span class="o">=</span> <span class="n">mult_downscale_gpu</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">)</span>

<span class="c1"># Access the downscaled images</span>
<span class="n">image_2x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">image_4x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_8x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">image_16x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.upscale_c">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">upscale_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.upscale_c" title="Link to this definition">¶</a></dt>
<dd><p>Upscale an image on the GPU using interpolation.</p>
<p>This function resizes a GPU-based image to the specified <cite>new_width</cite> and <cite>new_height</cite>
using the specified interpolation order. The resizing is performed using
<cite>cupyx.scipy.ndimage.zoom</cite>, which supports different interpolation methods.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>): A 3D GPU array (height x width x 3) representing an RGB image in <cite>uint8</cite> format.</p></li>
<li><p><strong>new_width</strong> (<em>int</em>): The desired width of the upscaled image.</p></li>
<li><p><strong>new_height</strong> (<em>int</em>): The desired height of the upscaled image.</p></li>
<li><p><strong>order_</strong> (<em>int</em>, optional, default=0): The interpolation order for resizing:
- <cite>0</cite>: Nearest-neighbor interpolation.
- <cite>1</cite>: Bilinear interpolation.
- <cite>3</cite>: Bicubic interpolation.
Higher orders provide smoother results but increase computation time.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>cupy.ndarray</strong>: The upscaled image as a GPU-based array with shape (<cite>new_height</cite>, <cite>new_width</cite>, 3).</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function ensures that the input array is of type <cite>uint8</cite> before processing.</p></li>
<li><p>The <cite>mode=’constant’, cval=0.0</cite> ensures that pixels outside the boundaries
are treated as zero during interpolation.</p></li>
<li><p>GPU synchronization (<cite>cp.cuda.Stream.null.synchronize()</cite>) is performed to
ensure all operations complete before returning the result.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">upscaled_image</span> <span class="o">=</span> <span class="n">upscale_c</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">new_width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">new_height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">order_</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Bloom Effect to a Pygame Surface using GPU Acceleration.</p>
<p>This function enhances bright regions of an image to create a glowing effect (bloom)
using a multi-step process that involves:
- Downscaling the image into progressively smaller sub-surfaces.
- Applying a bright-pass filter to isolate bright areas.
- Blurring the bright regions using a Gaussian filter.
- Upscaling and blending the processed layers back into the original surface.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input surface to apply the bloom effect on.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optional, default=128): The brightness threshold for the bright-pass filter.
Pixels with intensity above this value contribute to the bloom effect. Must be in range [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, optional, default=True): When <cite>True</cite>, only the lowest-resolution downsample (x16) is used for bloom.
When <cite>False</cite>, multiple downsampled layers (x2, x4, x8, x16) are processed and blended for a more detailed effect.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optional, default=pygame.BLEND_RGB_ADD): The blending mode used when merging the bloom effect back onto the original surface.
Common flags include:
- <cite>pygame.BLEND_RGB_ADD</cite> (default)
- <cite>pygame.BLEND_RGB_MULT</cite>, etc.</p></li>
<li><p><strong>factor_</strong> (<em>int</em>, optional, default=2): Determines how much the texture is downscaled.
Must be in the range [0, 4], corresponding to downscaling by:
- 1 (no reduction)
- 2 (half-size)
- 4 (quarter-size)
- 8 (eighth-size)</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: The input surface blended with the bloom effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If the input image is too small to be processed.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The bloom effect is achieved through a series of downscaling, filtering, and blending operations.</p></li>
<li><p>The <cite>pygame.BLEND_RGB_ADD</cite> flag is used to add the bloom effect to the original surface.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surface</span> <span class="o">=</span> <span class="n">bloom_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">factor_</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_surface</span><span class="p">,</span> <span class="s2">&quot;bloomed_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_array">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_array" title="Link to this definition">¶</a></dt>
<dd><p>Apply a Bloom Effect to an Image Represented as a GPU Array.</p>
<p>This function performs a bloom effect on a given <cite>gpu_array_</cite>, which represents an image on the GPU.
The process involves:
- Downscaling the image into progressively smaller versions (x2, x4, x8, x16).
- Applying a bright-pass filter to isolate high-intensity pixels.
- Blurring the bright regions to create a glow effect.
- Upscaling and blending the processed images to achieve the final bloom effect.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>): A 3D array representing the image in GPU memory. Must have dtype <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optional, default=128): The brightness threshold for the bright-pass filter. Pixels above this value contribute to bloom. Must be within [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, optional, default=True): When <cite>True</cite>, only the lowest-resolution downsample (x16) is used, reducing processing time. When <cite>False</cite>, multiple levels (x2, x4, x8, x16) are blended for a richer bloom effect.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optional, default=pygame.BLEND_RGB_ADD): The blending mode used when merging the bloom effect layers.</p></li>
<li><p><strong>mask_</strong> (<em>optional</em>, default=None): Unused parameter, reserved for future implementations.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>tuple of pygame.Surface</strong>: The processed bloom effect surfaces at different downscaling levels (s2, s4, s8, s16). If <cite>fast_</cite> is enabled, only <cite>s16</cite> is used.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The bloom effect is achieved through a series of downscaling, filtering, and blending operations.</p></li>
<li><p>The <cite>pygame.BLEND_RGB_ADD</cite> flag is used to add the bloom effect to the original surface.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert Pygame surface to CuPy array</span>
<span class="n">gpu_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surfaces</span> <span class="o">=</span> <span class="n">bloom_array</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Convert back to Pygame surfaces</span>
<span class="n">bloomed_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">make_surface</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bloom</span><span class="p">))</span> <span class="k">for</span> <span class="n">bloom</span> <span class="ow">in</span> <span class="n">bloomed_surfaces</span><span class="p">]</span>

<span class="c1"># Save the new images</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bloomed_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bloomed_images</span><span class="p">):</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_image</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;bloomed_image_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.cartoon_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">cartoon_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.cartoon_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a cartoon effect to a given surface using GPU acceleration.</p>
<p>This function processes an image to generate a cartoon-like effect by applying
edge detection, median filtering, and color quantization. The effect can also
include contour outlining if enabled.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image surface to be processed.</p></li>
<li><p><strong>sobel_threshold_</strong> (<em>int</em>, optional, default=128): The threshold value for the Sobel edge detection filter.</p></li>
<li><p><strong>median_kernel_</strong> (<em>int</em>, optional, default=2): Kernel size for median filtering (used to reduce noise while preserving edges).</p></li>
<li><p><strong>color_</strong> (<em>int</em>, optional, default=8): Number of maximum colors to be used in the cartoon effect (color reduction).</p></li>
<li><p><strong>contour_</strong> (<em>bool</em>, optional, default=False): Whether to draw contours on the edges detected in the image.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optional, default=BLEND_RGB_ADD): Blending mode used to combine the effect with the original image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: The transformed surface with the cartoon effect applied.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The cartoon effect is achieved through a series of edge detection, filtering, and blending operations.</p></li>
<li><p>The <cite>BLEND_RGB_ADD</cite> flag is used to add the cartoon effect to the original surface.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the cartoon effect</span>
<span class="n">cartoon_surface</span> <span class="o">=</span> <span class="n">cartoon_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">sobel_threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">median_kernel_</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color_</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">contour_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cartoon_surface</span><span class="p">,</span> <span class="s2">&quot;cartoon_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.blending_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">blending_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.blending_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Blend a source texture toward a destination texture (transition effect).</p>
<p>This function blends a source Pygame surface onto a destination surface, creating a transition effect
based on the specified percentage. The blending is performed using the following calculations:
- <strong>Alpha</strong>: <cite>outA = SrcA + DstA * (1 - SrcA)</cite>
- <strong>RGB</strong>: <cite>outRGB = SrcRGB + DstRGB * (1 - SrcA)</cite></p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>source_</strong> (<em>pygame.Surface</em>): The source surface to be blended.</p></li>
<li><p><strong>destination_</strong> (<em>pygame.Surface</em>): The destination surface onto which the source will be blended.</p></li>
<li><p><strong>percentage_</strong> (<em>float</em>): The blending percentage, a value between 0.0 and 100.0, representing the proportion of the source to blend with the destination.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new 24-bit Pygame surface with the blended result.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function assumes that the source and destination surfaces are of the same size.</p></li>
<li><p>The output surface is converted for fast blitting using the <cite>convert()</cite> method.</p></li>
<li><p>The blending mode used is <cite>BLEND_RGB_ADD</cite>, which adds the source color to the destination color. This mode can be adjusted by changing the <cite>flag_</cite> parameter.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load source and destination images</span>
<span class="n">source</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;source_image.png&#39;</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;destination_image.png&#39;</span><span class="p">)</span>

<span class="c1"># Apply blending with 50% source</span>
<span class="n">blended_surface</span> <span class="o">=</span> <span class="n">blending_gpu</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">)</span>

<span class="c1"># Save the blended image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blended_surface</span><span class="p">,</span> <span class="s1">&#39;blended_image.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a sharpening filter to the given pygame.Surface image using a generic filter kernel.</p>
<p>The function sharpens the input image by applying a sharpening kernel to each RGB channel
(red, green, blue) independently. The sharpened image is returned as a 24-bit pygame.Surface
format.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): A pygame surface object that represents the input image to be sharpened.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new pygame surface with the sharpened image in 24-bit format (RGB).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If the input surface is not a valid pygame.Surface or has zero dimensions.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The sharpening effect is achieved through convolution with a sharpening kernel.</p></li>
<li><p>The output surface is converted for fast blitting using the <cite>convert()</cite> method.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.ripple_effect_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">ripple_effect_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.ripple_effect_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a water drop (ripple) effect to a texture using GPU acceleration.</p>
<p>This function uses a CUDA kernel (<cite>ripple_kernel</cite>) to compute the ripple effect on the texture.
It works by manipulating the <cite>previous</cite> and <cite>current</cite> state of the ripple effect and applying
it to the texture. The effect is computed in parallel on the GPU, making it efficient for
handling large textures or simulations.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>): Tuple defining the grid size for CUDA kernel execution, e.g., (25, 25).
The grid size should match the texture size for efficient parallel processing.</p></li>
<li><p><strong>block</strong> (<em>tuple</em>): Tuple defining the block size for CUDA kernel execution, e.g., (32, 32).
The maximum number of threads is 1024 (block_x * block_y).</p></li>
<li><p><strong>w</strong> (<em>int</em>): The width of the texture and arrays.</p></li>
<li><p><strong>h</strong> (<em>int</em>): The height of the texture and arrays.</p></li>
<li><p><strong>previous</strong> (<em>cupy.ndarray</em>): A CuPy array of shape (w, h), containing the previous state of the ripple effect (float32).</p></li>
<li><p><strong>current</strong> (<em>cupy.ndarray</em>): A CuPy array of shape (w, h), containing the current state of the ripple effect (float32).</p></li>
<li><p><strong>texture_array</strong> (<em>cupy.ndarray</em>): A CuPy array of shape (w, h, 3), containing the source texture in RGB (uint8).</p></li>
<li><p><strong>background_array</strong> (<em>cupy.ndarray</em>): A CuPy array of shape (w, h, 3), representing the background texture to apply
the effect to (uint8).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong>: A tuple containing two CuPy arrays, the updated <cite>previous</cite> and <cite>current</cite> states of the ripple effect.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span>

<span class="c1"># Initialize previous and current ripple states</span>
<span class="n">previous</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">current</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Initialize texture and background arrays</span>
<span class="n">texture_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">background_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Apply ripple effect</span>
<span class="n">updated_previous</span><span class="p">,</span> <span class="n">updated_current</span> <span class="o">=</span> <span class="n">ripple_effect_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">background_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The grid and block sizes must be chosen appropriately based on the texture size and available GPU resources.</p></li>
<li><p>The kernel computation is done on the GPU using CuPy for faster execution.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen1_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen1_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen1_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Sharpen an image using a raw kernel.</p>
<p>This function sharpens the input image by applying a sharpening kernel to each RGB channel
(red, green, blue) independently. The borders are not computed with the kernel (value = 0).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image surface to be sharpened.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Grid dimensions for CUDA kernel execution, e.g., (25, 25). The grid values and block values must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Block dimensions for CUDA kernel execution, e.g., (32, 32). Maximum threads are 1024. Max threads = block_x * block_y.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the sharpened image in 24-bit format (RGB).</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration for efficient processing.</p></li>
<li><p>The sharpening effect is achieved through convolution with a sharpening kernel.</p></li>
<li><p>The output surface is converted for fast blitting using the <cite>convert()</cite> method.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen1_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mirroring_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mirroring_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mirroring_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mirror effect to an image using GPU acceleration.</p>
<p>This function creates a mirrored version of an image represented as a <cite>pygame.Surface</cite>.
It supports 32-bit and 24-bit image formats and outputs a 24-bit format image.
The mirror orientation (horizontal or vertical) is controlled using the <cite>format_</cite> parameter.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image as a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Defines the grid dimensions as <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>.
The grid and block dimensions must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Specifies the block dimensions as <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>.
The maximum number of threads per block is 1024, following the condition:
<cite>Max threads = block_x * block_y</cite>.</p></li>
<li><p><strong>format_</strong> (<em>bool</em>, optional, default=`False`): Determines the mirror orientation:
- <cite>False</cite> (0) → Horizontal mirroring (default).
- <cite>True</cite> (1) → Vertical mirroring.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A 24-bit <cite>pygame.Surface</cite> with the applied mirror effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> has an invalid format or dimensions (<cite>w</cite> or <cite>h</cite> is 0).</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> cannot be referenced as a 3D array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function extracts pixel data from <cite>surface_</cite> and converts it into a 3D array.</p></li>
<li><p>The <cite>mirroring_cupy</cite> function performs GPU-accelerated mirroring and returns the processed image.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.saturation_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">saturation_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.saturation_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Adjusts the saturation level of a given image using GPU acceleration.</p>
<p>This function modifies the saturation of an image represented as a <cite>pygame.Surface</cite>.
It supports 32-bit and 24-bit image formats, producing an output in 24-bit format.
The saturation adjustment value must be within the range [-1.0, 1.0].</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image as a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Defines the grid dimensions as <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>.
The grid and block dimensions must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Specifies the block dimensions as <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>.
The maximum number of threads per block is 1024, following the condition:
<cite>Max threads = block_x * block_y</cite>.</p></li>
<li><p><strong>val_</strong> (<em>float</em>, optional, default=`1.0`): Saturation adjustment level in the range <cite>[-1.0, 1.0]</cite>.
- <cite>-1.0</cite> → Completely desaturated (grayscale).
- <cite>0.0</cite> → No change in saturation.
- <cite>1.0</cite> → Fully saturated.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A 24-bit <cite>pygame.Surface</cite> with the adjusted saturation level.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> has an invalid format or dimensions (<cite>w</cite> or <cite>h</cite> is 0).</p></li>
<li><p><strong>ValueError</strong>: If <cite>val_</cite> is outside the range <cite>[-1.0, 1.0]</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function extracts pixel data from <cite>surface_</cite> and converts it into a 3D array.</p></li>
<li><p>The <cite>saturation_cupy</cite> function performs GPU-accelerated saturation adjustment
and returns the processed image.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bilateral_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bilateral_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bilateral_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a bilateral filter to a 32-bit or 24-bit image using the GPU.</p>
<p>A bilateral filter is a non-linear, edge-preserving, and noise-reducing
smoothing filter. It replaces the intensity of each pixel with a weighted
average of nearby pixels, where the weights are determined by both spatial
proximity and intensity differences, following a Gaussian distribution.</p>
<p>The filter parameters (sigma_r &amp; sigma_s) are pre-defined within the GPU kernel.
This function is compatible with 32-bit and 24-bit images.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image as a <cite>pygame.Surface</cite> object.</p></li>
<li><p><strong>kernel_size_</strong> (<em>int</em>): The kernel size, determining the number of neighboring pixels included in the calculation.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new 24-bit <cite>pygame.Surface</cite> with the bilateral filtering effect applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not an instance of <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface dimensions are zero or if <cite>kernel_size_</cite> is negative.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function extracts pixel data from <cite>surface_</cite> and converts it into a 3D array.</p></li>
<li><p>The <cite>bilateral_cupy</cite> function performs GPU-accelerated bilateral filtering and returns the processed image.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.emboss5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">emboss5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.emboss5x5_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply an emboss effect to a 32-bit or 24-bit image using a 5x5 convolution kernel.</p>
<dl class="simple">
<dt>The embossing kernel used:</dt><dd><p>[-2.0, -1.0,  0.0,  1.0,  2.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[ 0.0,  2.0,  4.0,  6.0,  8.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[-2.0, -1.0,  0.0,  1.0,  2.0]</p>
</dd>
</dl>
<p>Each RGB channel of the input image is processed independently using convolution.
The input image must be in 32-bit or 24-bit format, and the output will be a 24-bit image.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input image as a <cite>pygame.Surface</cite> object.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new 24-bit <cite>pygame.Surface</cite> with the emboss effect applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not an instance of <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the surface’s pixel data cannot be accessed or if its width/height is zero.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function extracts pixel data from <cite>surface_</cite> and converts it into a 3D array.</p></li>
<li><p>The <cite>emboss_cupy</cite> function performs GPU-accelerated embossing and returns the processed image.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.area24_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">area24_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cupy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=cupy.float32,</span> <span class="pre">copy=False)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.area24_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a color overlay to a specified area in a 24-bit RGB image using GPU acceleration.</p>
<p>This function modifies the color of a region in the <cite>rgb_array</cite> at coordinates <cite>(x, y)</cite>,
blending it with the given <cite>color</cite> based on the <cite>mask_alpha</cite> and <cite>intensity</cite> parameters.
It utilizes CuPy for fast GPU-based computation.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>x</strong> (<em>int</em>):
X-coordinate of the target pixel in the image.</p></li>
<li><p><strong>y</strong> (<em>int</em>):
Y-coordinate of the target pixel in the image.</p></li>
<li><p><strong>rgb_array</strong> (<em>cupy.ndarray</em>):
A 3D array representing the RGB image stored in GPU memory.
Must have a shape of <cite>(height, width, 3)</cite>.</p></li>
<li><p><strong>mask_alpha</strong> (<em>cupy.ndarray</em>):
Alpha mask determining the transparency effect applied to the color overlay.
Must match the shape of <cite>rgb_array</cite>.</p></li>
<li><p><strong>intensity</strong> (<em>float</em>, optional, default=`1.0`):
Scaling factor for the overlay effect.
Determines how strongly the <cite>color</cite> blends with the original image.
Must be in the range <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>color</strong> (<em>cupy.ndarray</em>, optional, default=`[128.0, 128.0, 128.0]`):
A 3-element array representing the RGB color to be blended.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>tuple</em>):
The modified RGB values at <cite>(x, y)</cite> after applying the effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If <cite>x</cite> or <cite>y</cite> is out of bounds.</p></li>
<li><p><strong>ValueError</strong>: If <cite>intensity</cite> is not within <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>rgb_array</cite> or <cite>mask_alpha</cite> have incompatible shapes.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration with CuPy for fast image processing.</p></li>
<li><p>The color blending effect is based on the alpha mask and intensity, allowing for customizable transparency.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.brightness_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">brightness_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brightness_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.brightness_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Adjusts the brightness of a given image using GPU acceleration.</p>
<p>This function modifies the brightness of a <cite>pygame.Surface</cite> by applying a
GPU-accelerated transformation. It efficiently processes 24-bit and 32-bit
images, leveraging CUDA for parallel computation.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image to be processed. Must be in 24-bit or 32-bit format.</p></li>
<li><p><strong>brightness_factor</strong> (<em>float</em>):
The brightness scaling factor.
- Values greater than <cite>1.0</cite> increase brightness.
- Values between <cite>0.0</cite> and <cite>1.0</cite> decrease brightness.
- <cite>1.0</cite> keeps the original brightness.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
Grid dimensions <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>.
Defines how the image is divided for parallel GPU execution.
Must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
Block dimensions <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>.
Determines the number of threads per block for CUDA execution.
The product <cite>block_x * block_y</cite> must not exceed <cite>1024</cite> (CUDA’s max thread limit per block).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new surface with modified brightness in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not of type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>brightness_factor</cite> is negative.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function leverages GPU acceleration to efficiently process the image,
making it suitable for large images or real-time applications.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsl_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies HSL (Hue, Saturation, Lightness) rotation to an image using GPU acceleration.</p>
<p>This function rotates the color of the pixels in an image or texture represented by a <cite>pygame.Surface</cite>
by modifying the hue component of the HSL color model. It supports both 24-bit and 32-bit image formats.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image surface to be processed.</p></li>
<li><p><strong>val_</strong> (<em>float</em>):
A float representing the hue rotation value. The hue is adjusted by rotating its value in the HSL color space.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>, optional):
Grid dimensions <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>. Defines how the image is divided for parallel GPU execution.
The grid and block dimensions must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>, optional):
Block dimensions <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>. Specifies the number of threads per block for CUDA execution.
The maximum number of threads per block is 1024, so <cite>block_x * block_y</cite> should not exceed this limit.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new <cite>pygame.Surface</cite> with the modified hue based on the given rotation value.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function applies a GPU-accelerated operation to rotate the hue component of the image, enabling efficient processing for large images or real-time applications.</p></li>
<li><p>The <cite>grid_</cite> and <cite>block_</cite> parameters are optional but must be provided for parallel processing to work optimally on the GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.dithering_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">dithering_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.dithering_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a dithering effect to an image using GPU acceleration.</p>
<p>This function applies a dithering effect to an RGB image using a CUDA kernel. The operation is performed
on the GPU for fast processing. The image is first normalized, processed using the dithering kernel,
and then converted back to 8-bit format.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>):
A CuPy array of shape <cite>(w, h, 3)</cite> containing the image data in RGB format. Must be of dtype <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
CUDA grid dimensions <cite>(grid_y, grid_x)</cite>. Defines how the computation is distributed across the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
CUDA block dimensions <cite>(block_y, block_x)</cite>. The number of threads per block should not exceed 1024.</p></li>
<li><p><strong>factor_</strong> (<em>float</em>, optional, default=`1.0`):
A factor controlling the dithering intensity. A higher value increases the dithering effect.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new <cite>pygame.Surface</cite> containing the processed image in RGB format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>gpu_array_</cite> is not a CuPy ndarray.</p></li>
<li><p><strong>ValueError</strong>: If <cite>gpu_array_</cite> is not of dtype <cite>cupy.uint8</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function uses a CUDA kernel (<cite>dithering_kernel</cite>) for high-performance processing.</p></li>
<li><p>The input image is normalized to [0, 1] before processing and then converted back to [0, 255].</p></li>
<li><p>The grid and block sizes must be chosen appropriately based on the image dimensions and GPU resources.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.fisheye_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">fisheye_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_texture</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.fisheye_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a fisheye lens effect to a pygame.Surface using GPU acceleration.</p>
<p>This function applies a fisheye distortion effect to a given surface using CUDA-based processing.
It is optimized for real-time rendering and can be used to display game scenes through a lens effect.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
Input pygame surface in 24-bit or 32-bit format.</p></li>
<li><p><strong>focal</strong> (<em>float</em>):
Focal length of the fisheye effect, controlling the strength of the distortion.</p></li>
<li><p><strong>focal_texture</strong> (<em>float</em>):
Texture focal length, further adjusting the fisheye intensity.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
CUDA grid dimensions <cite>(grid_y, grid_x)</cite>. Defines how computation is distributed across the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
CUDA block dimensions <cite>(block_y, block_x)</cite>. The maximum number of threads per block should not exceed 1024.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new <cite>pygame.Surface</cite> with the applied fisheye lens effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite> instance.</p></li>
<li><p><strong>ValueError</strong>: If the function cannot access the pixel data of <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function leverages CUDA for high-performance image processing.</p></li>
<li><p>The effect is applied directly to the input surface and returned as a transformed surface.</p></li>
<li><p>Ensure that the grid and block values are chosen to match the texture and array sizes for optimal performance.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.swirl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">swirl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.swirl_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a swirl distortion effect to an image using GPU acceleration.</p>
<p>This function creates a swirl effect on a given <cite>pygame.Surface</cite> by applying a CUDA-based
transformation. The effect distorts pixels radially around a specified center point.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
Input surface, must be in 24-bit or 32-bit format.</p></li>
<li><p><strong>rad</strong> (<em>float</em>):
Rotation angle in radians, controlling the intensity of the swirl.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
CUDA grid size, typically <cite>(grid_y, grid_x)</cite>. Defines how computation is distributed across the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
CUDA block size, typically <cite>(block_y, block_x)</cite>. The number of threads per block should not exceed 1024.</p></li>
<li><p><strong>centre_x</strong> (<em>int</em>):
X-coordinate of the swirl center (must be greater than 0).</p></li>
<li><p><strong>centre_y</strong> (<em>int</em>):
Y-coordinate of the swirl center (must be greater than 0).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new <cite>pygame.Surface</cite> with the applied swirl effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If the input surface cannot be referenced as a 3D array.</p></li>
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function operates directly on the GPU using CuPy for high performance.</p></li>
<li><p>Ensure <cite>grid_</cite> and <cite>block_</cite> are correctly configured for optimal execution.</p></li>
<li><p>The function calls <cite>swirl_cupy</cite>, which handles the actual GPU-based processing.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wave_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wave_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wave_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Creates a wave effect on an image using GPU acceleration.</p>
<p>This function applies a wave distortion effect to a given <cite>pygame.Surface</cite> by applying a CUDA-based
transformation. The effect creates a realistic wave motion across the image based on the specified
angle and block size.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image surface, which must be in 24-bit or 32-bit format.</p></li>
<li><p><strong>rad_</strong> (<em>float</em>):
A variable angle in radians that controls the wave effect.</p></li>
<li><p><strong>size_</strong> (<em>int</em>):
The block size for the wave effect. For a realistic wave, it’s recommended to keep the size below 15.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
CUDA grid size, typically <cite>(grid_y, grid_x)</cite>, defines how computation is distributed across the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
CUDA block size, typically <cite>(block_y, block_x)</cite>, the number of threads per block should not exceed 1024.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new <cite>pygame.Surface</cite> with the wave effect applied. It is recommended to rescale the image to hide any visible
distortions around the left and bottom borders, especially if a texture wraparound effect is noticeable.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>Example usage:
<cite>IMAGE = wave_gpu(IMAGE, 8 * math.pi/180.0 + FRAME/10, 8, grid, block)</cite>
<cite>IMAGE = scale(IMAGE, (WIDTH + 16, HEIGHT + 16))</cite> to hide the wraparound effect.</p></li>
<li><p>The function operates directly on the GPU using CuPy for high performance.</p></li>
<li><p>Ensure that the grid and block configurations are correctly selected for optimal performance.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.chromatic_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">chromatic_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.chromatic_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a chromatic displacement effect to a given surface using GPU acceleration.</p>
<p>This effect creates a color separation by shifting the RGB channels based on the specified
horizontal and vertical displacement values. The function is optimized for 24-bit and 32-bit image formats.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input surface to be processed. Must be in 24-bit or 32-bit format.</p></li>
<li><p><strong>delta_x</strong> (<em>int</em>):
Horizontal displacement for the chromatic shift. Affects the red and blue channels, creating a color separation effect.
A value of zero results in no horizontal displacement (if <cite>fx</cite> is low).</p></li>
<li><p><strong>delta_y</strong> (<em>int</em>):
Vertical displacement for the chromatic shift. Functions similarly to <cite>delta_x</cite>, but applies to vertical movement.
A value of zero results in no vertical displacement (if <cite>fx</cite> is low).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing grid dimensions, e.g., <cite>(25, 25)</cite>. Defines the division of the image for GPU processing, and
must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing block dimensions, e.g., <cite>(32, 32)</cite>. Determines the number of threads per block in GPU processing.
The product <cite>block_x * block_y</cite> must not exceed 1024 (the CUDA limit for threads per block).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, optional, default=`0.999`):
A zoom factor controlling the image scale after processing. Must be in the range <cite>(0.0, 1.0)</cite>. Default is <cite>1.0</cite> (no zoom).</p></li>
<li><p><strong>fx</strong> (<em>float</em>, optional, default=`0.05`):
Intensity of the chromatic effect, controlling the color separation strength. Must be within the range <cite>[0.0, 0.2]</cite>. Default is <cite>0.05</cite>.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>cupy.ndarray</em>):
A CuPy array representing the processed image with the chromatic displacement effect applied.
The output format is a 24-bit image.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not of type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> has zero width or height.</p></li>
<li><p><strong>ValueError</strong>: If <cite>delta_x</cite> or <cite>delta_y</cite> is negative.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function leverages GPU acceleration for efficient chromatic displacement.</p></li>
<li><p>Ensure that the grid and block sizes are chosen appropriately for the image size and GPU capabilities.</p></li>
<li><p>The <cite>fx</cite> parameter controls the strength of the chromatic separation effect,
and <cite>zoom</cite> allows for resizing after the transformation.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.rgb_split_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">rgb_split_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.rgb_split_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply an RGB split effect to an image using GPU acceleration.</p>
<p>This function shifts the red, green, and blue channels of an image by <cite>delta_x</cite> and <cite>delta_y</cite>
to create a chromatic aberration (glitch) effect. The transformation is performed entirely on
the GPU using CuPy.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image in a 24-bit or 32-bit format.</p></li>
<li><p><strong>delta_x</strong> (<em>float</em>):
The horizontal shift applied to the RGB channels. A positive value shifts the channels to the right,
and a negative value shifts them to the left.</p></li>
<li><p><strong>delta_y</strong> (<em>float</em>):
The vertical shift applied to the RGB channels. A positive value shifts the channels down,
and a negative value shifts them up.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid size for CUDA execution, defining the distribution of computation across the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block size, which determines the number of threads per block in GPU execution.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
A new surface with the RGB split effect applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>delta_x</cite> or <cite>delta_y</cite> are non-positive values or if the function cannot access the pixel data from <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The RGB split effect creates a chromatic distortion, commonly used in glitch effects.</p></li>
<li><p><cite>delta_x</cite> and <cite>delta_y</cite> define how far the color channels are shifted.</p></li>
<li><p>Ensure <cite>grid_</cite> and <cite>block_</cite> values are optimized for GPU execution.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.zoom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">zoom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.zoom_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Applies a zoom effect using GPU acceleration.</p>
<p>This function processes a <cite>pygame.Surface</cite> by mapping its pixel data to GPU memory
and applying a zoom transformation. It utilizes CUDA acceleration for high-performance image processing.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input surface to be processed. Must be a 24-bit or 32-bit format image.</p></li>
<li><p><strong>centre_x</strong> (<em>unsigned int</em>):
The x-coordinate of the zoom center. Must be greater than or equal to 0.</p></li>
<li><p><strong>centre_y</strong> (<em>unsigned int</em>):
The y-coordinate of the zoom center. Must be greater than or equal to 0.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid dimensions. Defines the division of the image for parallel GPU processing.
The values must match the texture and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block dimensions. Determines the number of threads per block in GPU execution.
The product <cite>block_x * block_y</cite> must not exceed <cite>1024</cite> (CUDA limit).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, optional):
A zoom factor controlling the scaling of the image. Must be within the range <cite>(0.0, 1.0]</cite>. Default is <cite>1.0</cite> (no scaling).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>CuPy ndarray</em>):
A CuPy array containing the transformed image with zoom applied, in 24-bit format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>:
- If the width or height of <cite>surface_</cite> is 0.
- If <cite>zoom</cite> is not within the range <cite>(0.0, 1.0]</cite>.
- If <cite>centre_x</cite> or <cite>centre_y</cite> is negative.
- If <cite>surface_</cite> cannot be mapped to a 3D array.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function performs the zoom effect by mapping pixel data to GPU memory and using CUDA for high-performance processing.</p></li>
<li><p>Ensure <cite>grid_</cite> and <cite>block_</cite> are optimized for your GPU’s capabilities and the image size.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wavelength_map_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wavelength_map_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wavelength_map_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a channel-specific color effect (redscale, greenscale, or bluescale) to an image.</p>
<p>This function applies a redscale, greenscale, or bluescale effect to a given <cite>pygame.Surface</cite> image.
It isolates and emphasizes one of the color channels (Red, Green, or Blue) depending on the provided
<cite>layer_</cite> parameter. The operation is performed using GPU acceleration for better performance.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image to which the effect will be applied.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid configuration. The grid values should match the image
and array sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block configuration. The block values determine how many threads
are launched per block.</p></li>
<li><p><strong>layer_</strong> (<em>unsigned short int</em>, optional):
Specifies which color channel to isolate. The default is <cite>0</cite> (Red channel). The values are:
- <cite>0</cite> for Red channel
- <cite>1</cite> for Green channel
- <cite>2</cite> for Blue channel</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
The image with the selected channel effect (redscale, greenscale, or bluescale) applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If the <cite>layer_</cite> value is not within the range of 0 to 2.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function uses GPU acceleration for high-performance image processing.</p></li>
<li><p>The <cite>layer_</cite> parameter determines which color channel is emphasized.</p></li>
<li><p>The result is a new <cite>pygame.Surface</cite> with the selected color channel effect applied.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply a heatmap effect to an image with optional inversion.</p>
<p>This function applies a heatmap effect to an image using GPU acceleration. The heatmap effect is typically
used to visualize intensity or magnitude across a 2D surface. The effect can be inverted based on the <cite>invert_</cite>
parameter, changing the color representation.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input image to which the heatmap effect will be applied.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid configuration. The grid values should match the texture
and array sizes for parallel execution on the GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block configuration. It defines the number of threads per block
for GPU execution. The product <cite>block_x * block_y</cite> must not exceed <cite>1024</cite> (CUDA’s maximum threads per block).</p></li>
<li><p><strong>invert_</strong> (<em>boolean</em>, optional):
If <cite>True</cite>, the color range of the heatmap is reversed (inverted). The default is <cite>False</cite>, meaning no inversion.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
The image with the heatmap effect applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>invert_</cite> is not a boolean.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function uses GPU acceleration for high-performance image processing.</p></li>
<li><p>The inversion of the heatmap allows for a different color representation.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Apply heatmap effect in place to a pygame.Surface.</p>
<p>This function applies a heatmap effect to the input surface in place, modifying the pixel data directly
without returning a new surface. The heatmap visualization enhances the intensity of the image based on a color
mapping, with the option to invert the color effect.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The surface on which the heatmap effect will be applied. The surface must be a valid <cite>pygame.Surface</cite> containing
pixel data in a 3D array (RGB channels).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid configuration for parallel GPU execution. The grid values must
match the array and texture sizes.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block configuration. It defines the number of threads per block
for GPU computation. The product <cite>block_x * block_y</cite> must not exceed <cite>1024</cite> (CUDA’s maximum threads per block).</p></li>
<li><p><strong>invert_</strong> (<em>boolean</em>, optional):
If <cite>True</cite>, the heatmap effect is inverted, reversing the color range. Default is <cite>False</cite> (no inversion).</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>void</em>):
This function modifies the <cite>surface_</cite> directly and does not return a value.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>invert_</cite> is not a boolean.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>The function uses GPU acceleration for high-performance image processing.</p></li>
<li><p>The effect is applied in place, meaning the input <cite>surface_</cite> is modified directly.</p></li>
<li><p>The inversion of the heatmap allows for a reversed color representation.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.predator_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">predator_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.predator_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Apply predator vision effect using GPU acceleration.</p>
<p>This function processes the input <cite>pygame.Surface</cite> to apply a predator vision effect using GPU acceleration. The
effect simulates a vision filter with bloom and colormap adjustments, which can be customized based on the
provided parameters.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input surface to process.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
A tuple <cite>(grid_y, grid_x)</cite> representing the grid dimensions for CUDA kernel execution.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
A tuple <cite>(block_y, block_x)</cite> representing the block dimensions for CUDA kernel execution.</p></li>
<li><p><strong>bloom_smooth</strong> (<em>unsigned int</em>, optional):
The smoothing factor for the bloom effect. Default is <cite>50</cite>.</p></li>
<li><p><strong>bloom_threshold</strong> (<em>unsigned int</em>, optional):
The intensity threshold for the bloom effect. Default is <cite>50</cite>.</p></li>
<li><p><strong>inv_colormap</strong> (<em>boolean</em>, optional):
Whether to invert the colormap. Default is <cite>False</cite>.</p></li>
<li><p><strong>blend</strong> (<em>int</em>, optional):
The blending mode for final rendering. Default is <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
<li><p><strong>bloom_flag</strong> (<em>boolean</em>, optional):
Flag to enable the bloom effect. Default is <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>):
The processed surface with the applied predator vision effect.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>bloom_smooth</cite>, <cite>bloom_threshold</cite> are not positive integers or if <cite>blend</cite> is not a valid blend mode.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function uses GPU acceleration to apply a fast predator vision effect.</p></li>
<li><p>The bloom effect simulates glowing areas of high intensity, and the colormap can be inverted for different visual effects.</p></li>
<li><p>The <cite>blend</cite> and <cite>bloom_flag</cite> parameters allow for customization of the final rendering effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.downscale_surface_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">downscale_surface_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.downscale_surface_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Downscale a pygame surface using CUDA on CuPy.</p>
<p>This function extracts pixel data from a <cite>pygame.Surface</cite>, transfers it to the GPU, applies a
downscaling operation using a CUDA kernel, and returns the processed image in a byte buffer.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>):
The input surface to be downscaled.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>):
CUDA grid dimensions for kernel execution.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>):
CUDA block dimensions for kernel execution.</p></li>
<li><p><strong>zoom</strong> (<em>float</em>):
The scaling factor for downscaling. Must be in the range <cite>[0.0, 0.9999]</cite>.</p></li>
<li><p><strong>w2</strong> (<em>int</em>):
The target width of the downscaled image.</p></li>
<li><p><strong>h2</strong> (<em>int</em>):
The target height of the downscaled image.</p></li>
</ul>
<p><strong>Returns:</strong></p>
<ul class="simple">
<li><p>(<em>bytes</em>):
The downscaled image in RGB format as a byte buffer.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: If <cite>zoom</cite> is not in the range <cite>[0.0, 0.9999]</cite>, or if <cite>w2</cite> or <cite>h2</cite> are non-positive values.</p></li>
</ul>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function uses GPU acceleration with CuPy for efficient downscaling.</p></li>
<li><p>The downscaled image is returned as a byte buffer in RGB format.</p></li>
<li><p>Ensure that the grid and block values are optimized for GPU performance.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader_gpu</a><ul>
<li><a class="reference internal" href="#gpu-accelerated-image-processing-library">1. GPU-Accelerated Image Processing Library</a></li>
<li><a class="reference internal" href="#key-features-use-cases">2. Key Features &amp; Use Cases</a></li>
<li><a class="reference internal" href="#use-case">3. Use Case</a></li>
<li><a class="reference internal" href="#potential-applications">4. Potential Applications</a></li>
<li><a class="reference internal" href="#summary">5. Summary</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Cython list methods</a><ul>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_free_mem"><code class="docutils literal notranslate"><span class="pre">get_gpu_free_mem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_maxmem"><code class="docutils literal notranslate"><span class="pre">get_gpu_maxmem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_pci_bus_id"><code class="docutils literal notranslate"><span class="pre">get_gpu_pci_bus_id()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_compute_capability"><code class="docutils literal notranslate"><span class="pre">get_compute_capability()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_max_grid_per_block"><code class="docutils literal notranslate"><span class="pre">get_max_grid_per_block()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_grid"><code class="docutils literal notranslate"><span class="pre">block_grid()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.conv"><code class="docutils literal notranslate"><span class="pre">conv()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_and_grid_info"><code class="docutils literal notranslate"><span class="pre">block_and_grid_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_info"><code class="docutils literal notranslate"><span class="pre">get_gpu_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu"><code class="docutils literal notranslate"><span class="pre">invert_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">invert_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">invert_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_rgb_array_inplace"><code class="docutils literal notranslate"><span class="pre">invert_rgb_array_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_rgb_array_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_rgb_array_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_inplace_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_inplace_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_lum_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_lum_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_generic_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_generic_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_5x5_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_3x3_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_3x3_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sobel_gpu"><code class="docutils literal notranslate"><span class="pre">sobel_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.prewitt_gpu"><code class="docutils literal notranslate"><span class="pre">prewitt_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.canny_gpu"><code class="docutils literal notranslate"><span class="pre">canny_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.color_reduction_gpu"><code class="docutils literal notranslate"><span class="pre">color_reduction_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsv_gpu"><code class="docutils literal notranslate"><span class="pre">hsv_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mult_downscale_gpu"><code class="docutils literal notranslate"><span class="pre">mult_downscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.upscale_c"><code class="docutils literal notranslate"><span class="pre">upscale_c()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_gpu"><code class="docutils literal notranslate"><span class="pre">bloom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_array"><code class="docutils literal notranslate"><span class="pre">bloom_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.cartoon_gpu"><code class="docutils literal notranslate"><span class="pre">cartoon_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.blending_gpu"><code class="docutils literal notranslate"><span class="pre">blending_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.ripple_effect_gpu"><code class="docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen1_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen1_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mirroring_gpu"><code class="docutils literal notranslate"><span class="pre">mirroring_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.saturation_gpu"><code class="docutils literal notranslate"><span class="pre">saturation_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bilateral_gpu"><code class="docutils literal notranslate"><span class="pre">bilateral_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.emboss5x5_gpu"><code class="docutils literal notranslate"><span class="pre">emboss5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.area24_gpu"><code class="docutils literal notranslate"><span class="pre">area24_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.brightness_gpu"><code class="docutils literal notranslate"><span class="pre">brightness_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsl_gpu"><code class="docutils literal notranslate"><span class="pre">hsl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.dithering_gpu"><code class="docutils literal notranslate"><span class="pre">dithering_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.fisheye_gpu"><code class="docutils literal notranslate"><span class="pre">fisheye_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.swirl_gpu"><code class="docutils literal notranslate"><span class="pre">swirl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wave_gpu"><code class="docutils literal notranslate"><span class="pre">wave_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.chromatic_gpu"><code class="docutils literal notranslate"><span class="pre">chromatic_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.rgb_split_gpu"><code class="docutils literal notranslate"><span class="pre">rgb_split_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.zoom_gpu"><code class="docutils literal notranslate"><span class="pre">zoom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wavelength_map_gpu"><code class="docutils literal notranslate"><span class="pre">wavelength_map_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.predator_gpu"><code class="docutils literal notranslate"><span class="pre">predator_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.downscale_surface_gpu"><code class="docutils literal notranslate"><span class="pre">downscale_surface_gpu()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="Shader.html"
                          title="previous chapter">Shader</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="PygameTools.html"
                          title="next chapter">PygameTools</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader_gpu.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             >next</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Shader"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PygameShader 1.0.11 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>