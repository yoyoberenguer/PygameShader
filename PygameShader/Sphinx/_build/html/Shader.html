
<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader &#8212; PygameShader 1.0.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=9306f2a9"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Shader_gpu" href="Shader_gpu.html" />
    <link rel="prev" title="Welcome to PygameShader’s documentation!" href="index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to PygameShader’s documentation!"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PygameShader 1.0.11 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader">
<h1>Shader<a class="headerlink" href="#shader" title="Link to this heading">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader.pyx</span></code></p>
<hr class="docutils" />
<section id="high-performance-image-processing-library">
<h2>1. High-Performance Image Processing Library<a class="headerlink" href="#high-performance-image-processing-library" title="Link to this heading">¶</a></h2>
<p>This library is a Cython-based module designed for high-performance image processing and manipulation.
By leveraging Cython’s ability to combine Python’s ease of use with C-like performance, it is optimized
for computationally intensive tasks such as real-time image processing, game development, computer vision,
and artistic effects.</p>
</section>
<section id="key-features">
<h2>2. Key Features<a class="headerlink" href="#key-features" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Color space conversions</strong> (RGB, grayscale, HSL, HSV)</p></li>
<li><p><strong>Image transformations</strong> (mirroring, pixelation, resizing)</p></li>
<li><p><strong>Visual effects</strong> (distortions, filters, artistic effects)</p></li>
<li><p><strong>Advanced image processing</strong> (edge detection, sharpening, blending)</p></li>
<li><p><strong>Physical simulations</strong> (ripple effects, heat convection)</p></li>
<li><p><strong>Performance optimizations</strong> (multi-threading, memory-efficient operations)</p></li>
</ul>
</section>
<section id="library-functional-overview">
<h2>3. Library Functional Overview<a class="headerlink" href="#library-functional-overview" title="Link to this heading">¶</a></h2>
<p><strong>Color Manipulation</strong></p>
<ul class="simple">
<li><p><strong>Color Conversions</strong>: <cite>bgr</cite>, <cite>brg</cite>, <cite>grey</cite>, <cite>sepia</cite>, <cite>hsl_effect</cite>, <cite>hsv_effect</cite></p></li>
<li><p><strong>Brightness &amp; Saturation</strong>: <cite>brightness</cite>, <cite>saturation</cite>, <cite>brightness_exclude</cite>, <cite>brightness_bpf</cite></p></li>
<li><p><strong>Color Inversion</strong>: <cite>invert</cite></p></li>
</ul>
<p><strong>Visual Effects</strong></p>
<ul class="simple">
<li><p><strong>Filters</strong>: <cite>median</cite>, <cite>sobel</cite>, <cite>bloom</cite>, <cite>posterize_surface</cite></p></li>
<li><p><strong>Distortions</strong>: <cite>wave</cite>, <cite>swirl</cite>, <cite>fisheye</cite>, <cite>horizontal_glitch</cite>, <cite>horizontal_sglitch</cite></p></li>
<li><p><strong>Artistic Effects</strong>: <cite>painting</cite>, <cite>cartoon</cite>, <cite>dithering</cite>, <cite>dithering_atkinson</cite></p></li>
</ul>
<p><strong>Advanced Image Processing</strong></p>
<ul class="simple">
<li><p><strong>Edge Detection &amp; Sharpening</strong>: <cite>sobel</cite>, <cite>sobel_fast</cite>, <cite>sharpen</cite>, <cite>sharpen32</cite></p></li>
<li><p><strong>Blending &amp; Compositing</strong>: <cite>blend</cite>, <cite>alpha_blending</cite>, <cite>alpha_blending_inplace</cite></p></li>
<li><p><strong>Heatmap Effects</strong>: <cite>heatmap</cite>, <cite>predator_vision</cite></p></li>
</ul>
<p><strong>Physical Simulations</strong></p>
<ul class="simple">
<li><p><strong>Ripple Effects</strong>: <cite>ripple</cite>, <cite>ripple_seabed</cite></p></li>
<li><p><strong>Heat Convection</strong>: <cite>heatconvection</cite></p></li>
<li><p><strong>Plasma Effects</strong>: <cite>plasma</cite>, <cite>plasma_config</cite></p></li>
</ul>
<p><strong>Utility Functions</strong></p>
<ul class="simple">
<li><p><strong>Image Transformations</strong>: <cite>mirroring</cite>, <cite>pixelation</cite>, <cite>bilinear</cite></p></li>
<li><p><strong>Color Mapping</strong>: <cite>wavelength2rgb</cite>, <cite>custom_map</cite></p></li>
<li><p><strong>Optimized Functions</strong>: <cite>bgr_1d</cite>, <cite>grey_1d</cite>, <cite>invert1d</cite></p></li>
</ul>
<p><strong>Special Effects</strong></p>
<ul class="simple">
<li><p><strong>Retro TV Scanlines</strong>: <cite>tv_scan</cite></p></li>
<li><p><strong>Blood Effects</strong>: <cite>blood</cite></p></li>
<li><p><strong>Dirt &amp; Lens Distortion</strong>: <cite>dirt_lens</cite></p></li>
</ul>
<p><strong>Performance &amp; Optimization</strong></p>
<ul class="simple">
<li><p><strong>Memory Efficiency</strong>: Optimized for <cite>1D</cite> and <cite>3D</cite> pixel arrays</p></li>
<li><p><strong>Parallel Processing</strong>: Uses <cite>nogil</cite> for multi-threaded execution</p></li>
</ul>
</section>
<section id="target-applications">
<h2>4. Target Applications<a class="headerlink" href="#target-applications" title="Link to this heading">¶</a></h2>
<p>This library is ideal for:
- <strong>Game Development</strong>: Real-time visual effects, distortions, blending
- <strong>Computer Vision</strong>: Preprocessing images for machine learning &amp; analysis
- <strong>Artistic Applications</strong>: Creative effects for images and videos
- <strong>Scientific Visualization</strong>: Simulating physical phenomena (heat, ripples)</p>
</section>
<section id="summary">
<h2>5. Summary<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>This Cython-based library is a powerful toolkit for image processing,
combining high-performance optimizations with a vast range of visual effects
and transformations. It is particularly suited for real-time and high-performance
applications, making it an essential tool for game developers, computer vision
engineers, and creative professionals.</p>
</section>
<section id="cython-list-methods">
<h2>6. Cython list methods<a class="headerlink" href="#cython-list-methods" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convert an image from RGB(A) to BGR(A) format (in-place).
Converts the game display, image, or surface from RGB(A) to BGR(A) format.
The alpha channel will be ignored in the process, but it is retained in case of a 32-bit surface.</p>
<p>RGB is commonly used in image editing and display applications, where the order is red, green, and blue.
On the other hand, BGR is often used in image processing applications, where the order is blue, green, and red.</p>
<p><strong>Note</strong>: This function operates in-place, meaning it modifies the original surface.</p>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (Pygame surface)
Pygame surface (either display or image) with a compatible format
(24-bit or 32-bit, with or without transparency/alpha channel).</p>
<p><strong>Returns:</strong></p>
<p>void; modifies the surface in-place.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_copy" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convert an image format from RGB(A) to BGR(A) and return a new surface (copy).
This function converts the pixel data of an input image from RGB(A) to BGR(A) format.
The Alpha channel (if present) will be retained, but the order of the color channels
is switched from RGB to BGR. This is useful when working with image processing libraries
that expect the BGR format (such as OpenCV), while the RGB format is commonly used in
display and image editing applications.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">bgr_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (Pygame Surface)
A Pygame Surface object representing the image. The surface can be in 24-bit or
32-bit format (with or without an alpha channel). The function assumes the image
is in RGB(A) format and will convert it to BGR(A).</p>
<p><strong>Returns:</strong></p>
<p>A new Pygame Surface object with the converted BGR(A) pixel format.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_3d" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convert an RGB(A) array (shape: w, h, n) with uint8 data type to BGR(A) format (inplace).
This function directly processes a 3D array (such as an image or surface) from RGB(A) format
to BGR(A) format. It assumes that the input array is in RGB or RGBA format, and it switches
the red and blue channels to convert it to BGR or BGRA format respectively. The operation
is done in place, modifying the original array.</p>
<p>RGB is the common color order used in display and image editing applications, where the color
channels are arranged as red, green, blue. On the other hand, BGR is often used in image
processing applications, where the color channels are arranged as blue, green, red.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_3d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D numpy array of shape (w, h, n), where <cite>w</cite> is the width, <cite>h</cite> is the height,
and <cite>n</cite> is the number of channels (3 for RGB, 4 for RGBA). The array should have
uint8 data type (values between 0 and 255), and contain pixel data in RGB(A) format.</p>
<p><strong>Returns:</strong></p>
<p>void
This function modifies the input array in place and does not return any value.</p>
<p><strong>Raises:</strong></p>
<p><strong>ValueError</strong>
If the input array shape is not compatible with RGB(A) (i.e., it does not have
the shape (w, h, 3) or (w, h, 4)).</p>
<p><strong>TypeError</strong>
If the input array does not have the uint8 (unsigned byte) data type.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convert a 1D array of uint8 data type from RGB(A) to BGR(A) format (inplace).
This function processes a 1D array directly, converting the color channels from
the RGB(A) format to the BGR(A) format. The conversion is done in place, modifying
the original array. The <cite>format_32</cite> flag determines whether the input is in RGB
(24-bit) or RGBA (32-bit) format.</p>
<p>RGB is the standard color order used in many image editing and display applications,
where the order of the color channels is red, green, and blue. In contrast, BGR is
often used in image processing, where the color channels are arranged as blue,
green, and red.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_1d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray or bytearray)
A 1D array (or buffer) of pixel data in RGB(A) format, with uint8 data type
(values between 0 and 255). The array length should be a multiple of 3 (for RGB)
or 4 (for RGBA). The array contains the pixel color values that will be converted
from RGB(A) to BGR(A) format.</p>
<p><strong>format_32</strong> (bool, optional)
A boolean flag indicating the format of the input array.
- <cite>True</cite> indicates the array is in ‘RGB’ (24-bit, 3 channels).
- <cite>False</cite> (default) indicates the array is in ‘RGBA’ (32-bit, 4 channels).</p>
<p><strong>Returns:</strong></p>
<p>void
The function modifies the input array in place and does not return any value.</p>
<p><strong>Raises:</strong></p>
<p><strong>TypeError</strong>
If the input array does not have a <cite>uint8</cite> data type.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d_cp" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convert a 1D array from RGB(A) to BGR(A) format and return a new copy.
This function takes a 1D array (or memoryview slice) that contains pixel data in
RGB(A) order and produces a new 1D array with the color channels reordered to
BGR(A). This conversion is useful when interfacing with libraries or routines
that expect pixels in BGR(A) format instead of the more common RGB(A) order.</p>
<p>The function assumes that the input array is of type uint8, and its length should
be a multiple of 3 (for RGB data) or 4 (for RGBA data). The <cite>format_32</cite> flag indicates
whether the input contains 32-bit pixels (True for RGBA, False for RGB).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_bgr_array</span> <span class="o">=</span> <span class="n">bgr_1d_cp</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray or memoryview slice, shape <cite>(w,)</cite>, dtype <cite>uint8</cite>)
A 1D array or buffer containing pixel data in RGB(A) order.
(For instance, if the image is RGB, the array length should be 3 * number_of_pixels.)</p>
<p><strong>format_32</strong> (bool, optional)
A flag indicating the pixel format:
- <cite>False</cite> (default): the input is assumed to be 24-bit (RGB, 3 channels).
- <cite>True</cite>: the input is assumed to be 32-bit (RGBA, 4 channels).</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new 1D array (uint8) with the pixel data converted to BGR(A) order.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg" title="Link to this definition">¶</a></dt>
<dd><p>Convert a Pygame surface from RGB(A) to BRG(A) format in-place.
This function modifies the given surface by swapping the red and green color channels,
converting an image from RGB(A) order to BRG(A) order. The alpha channel, if present,
is preserved but ignored during the conversion process.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface or display surface compatible with 24-bit (RGB) or 32-bit (RGBA) pixel formats.
The function operates directly on the provided surface.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input surface in-place and does not return a new surface.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_copy" title="Link to this definition">¶</a></dt>
<dd><p>Convert an image from RGB(A) to BRG(A) format and return a new copy.
This function swaps the red and green channels of an image while preserving
the blue channel. It creates and returns a new surface with the modified
color format, leaving the original surface unchanged.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_surface</span> <span class="o">=</span> <span class="n">brg_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface or display surface in 24-bit (RGB) or 32-bit (RGBA) format.
The alpha channel (if present) will be ignored.</p>
<p><strong>Returns:</strong></p>
<p><strong>pygame.Surface</strong>
A new surface with the color channels converted to BRG format.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_3d" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 3D array from RGB(A) to BRG(A) format (inplace).
This function swaps the red and green channels while preserving the blue
and alpha channels (if present). It modifies the input array directly
without creating a copy.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray, shape (w, h, n), dtype uint8)
A 3D array representing an image, where pixel values range from 0 to 255.
The last dimension (n) must be 3 (RGB) or 4 (RGBA).</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function operates inplace and does not return a new array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 1D array of RGB(A) pixel data to BRG(A) format in-place.
This function swaps the red and blue channels of an input array or buffer
representing RGB or RGBA pixel data. It works on both 24-bit (RGB) and
32-bit (RGBA) formats.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_1d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>  <span class="c1"># Converts an RGB(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray or bytearray)
A 1D array of shape (w,) containing uint8 pixel data (values 0-255).
Can be either a NumPy array or a raw byte buffer.</p>
<p><strong>format_32</strong> (bool, optional, default = False)
- True: Treats the input as an RGB (24-bit) buffer.
- False: Treats the input as an RGBA (32-bit) buffer.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The operation is performed in-place, modifying <cite>rgb_array</cite> directly.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Converts a 1D array of uint8 BGR(A) pixel data to BRG(A) format and returns a new array.
Unlike the in-place version (<cite>brg_1d</cite>), this function creates and returns a
new array with the red and blue channels swapped.</p>
<p>BRG stands for Blue, Red, Green.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_array</span> <span class="o">=</span> <span class="n">brg_1d_cp</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>  <span class="c1"># Converts an BGR(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray or bytearray)
A 1D array of shape (w,) containing uint8 pixel data (values 0-255).
Can be either a NumPy array or a raw byte buffer.</p>
<p><strong>format_32</strong> (bool, optional, default = False)
- True: Treats the input as a BGR (24-bit) buffer.
- False: Treats the input as a BGRA (32-bit) buffer.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new array of shape (w,) with the BRG(A) pixel format (copied).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey" title="Link to this definition">¶</a></dt>
<dd><p>Convert an image to grayscale while preserving luminosity (in-place).
A grayscale image has a single channel representing pixel intensity or brightness,
where pixel values range from 0 (black) to 255 (white). This function computes the
grayscale values based on luminosity, preserving perceived brightness from the original color image.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grey</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface or display surface compatible object, with an image in
24-bit or 32-bit format. The surface may include transparency or an alpha
channel.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input surface in place and does not return a new surface.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_copy" title="Link to this definition">¶</a></dt>
<dd><p>Convert an image to grayscale while preserving luminosity and return a new surface.
A grayscale image has a single channel representing pixel intensity or brightness,
with pixel values typically ranging from 0 (black) to 255 (white). This function
converts the original image to grayscale based on luminosity, preserving perceived
brightness from the color image. The alpha channel is preserved in images with
transparency (RGBA format), but it is not altered.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">grey_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface or display surface compatible object, with an image in
24-bit or 32-bit format. The surface may include transparency (alpha channel).</p>
<p><strong>Returns:</strong></p>
<p><strong>pygame.Surface</strong>
A new surface object containing the grayscale image. The original surface remains unchanged.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_2d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_2d" title="Link to this definition">¶</a></dt>
<dd><p>Convert an image into a 2D grayscale array.
A grayscale image has a single channel representing pixel intensity or brightness,
with pixel values typically ranging from 0 (black) to 255 (white). This function
converts the input image to grayscale based on luminosity, preserving the intensity
from the original color image. The alpha channel, if present, will be ignored in the
output.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gray</span> <span class="o">=</span> <span class="n">grey_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface or display surface-compatible object, with an image in
24-bit or 32-bit format. The surface may include transparency (alpha channel),
which will be ignored during the conversion.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A 2D NumPy array containing the grayscale image data. The array will have
shape (w, h) and dtype uint8, where each value represents pixel intensity.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_3d" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 3D array (w, h, n) in RGB(A) format to grayscale (with alpha) in place.
This function processes a 3D array directly, converting it to grayscale based on
luminosity while preserving the alpha channel (if present). The pixel values in
the resulting grayscale array represent intensity or brightness, ranging from
0 (black) to 255 (white).</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit image/surface</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

<span class="c1"># For a 32-bit image with alpha channel</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D NumPy array of shape (w, h, n) with dtype uint8, containing pixel data
in RGB(A) format. The values in the array range from 0 to 255. For 32-bit arrays
(RGBA), the alpha channel will be preserved but ignored in the grayscale conversion.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the input array in place and does not return a new array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 1D array of uint8 data (RGB(A)) to grayscale (with alpha) in place.
A grayscale image has a single channel representing pixel intensity or brightness,
with pixel values typically ranging from 0 (black) to 255 (white). This function
converts the input RGB(A) array to grayscale while preserving the alpha channel
(if present). The conversion is performed in place, modifying the original array.</p>
<p><strong>Example Usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit buffer (RGB)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># For a 32-bit buffer (RGBA)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">PIL</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">size</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">getdata</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">arr</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Set <cite>format_32</cite> to <cite>True</cite> if the array is a 32-bit buffer containing RGBA values.</p>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray or bytearray)
A 1D array or buffer containing pixel data in RGB(A) format, with dtype uint8
(unsigned char values ranging from 0 to 255).</p>
<p><strong>format_32</strong> (bool, optional)
If <cite>True</cite>, the function assumes the input is a 32-bit buffer (RGBA).
If <cite>False</cite>, the function assumes a 24-bit buffer (RGB).</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input array in place and does not return a new array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 1D array of uint8 BGR(A) data to grayscale (with alpha channel) and return a copy.
This function checks that the input array has the expected uint8 data type, and then converts
the pixel data from BGR or BGRA format to grayscale. The conversion preserves the alpha channel
(if present). It returns a new 1D NumPy array in grayscale format.</p>
<p>The grayscale conversion is based on the luminosity formula, which calculates the
brightness based on the red, green, and blue channels.</p>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D array containing pixel data in BGR(A) format, with dtype uint8. The pixel values
should range from 0 to 255. If the array represents a BGRA image, the alpha channel
will be preserved.</p>
<p><strong>format_32</strong> (bool, optional)
If <cite>True</cite>, the input array is assumed to be in BGRA (32-bit) format.
If <cite>False</cite>, the array is assumed to be in BGR (24-bit) format.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new 1D NumPy array of shape (w,) with dtype uint8, containing the grayscale
pixel data. If the input was in BGRA format, the alpha channel is preserved in the output.</p>
<p><strong>Raises:</strong></p>
<p><strong>TypeError</strong>
If the input array does not have dtype uint8, a <cite>TypeError</cite> will be raised.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia" title="Link to this definition">¶</a></dt>
<dd><p>Apply a sepia tone filter to an image, surface, or video game graphics (inplace).
Sepia toning is a technique used in photography and imaging where the image is given
a reddish-brown tint, simulating the warm tones of old photographs. It creates a
softer, dreamier aesthetic compared to standard grayscale, adding depth and a vintage look.</p>
<p>This function transforms the provided surface into an equivalent sepia-toned model,
adjusting the pixel colors accordingly while preserving the original structure. The
transformation is applied directly to the surface (inplace), and no new surface is returned.</p>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sepia</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_copy" title="Link to this definition">¶</a></dt>
<dd><p>Sepia model (New Surface)</p>
<p>Transform your video game/image or surface into an equivalent sepia model.</p>
<p>While traditional black-and-white photographs use a standard grayscale to create
highlights and shadows, sepia-toned photos use a reddish-brown tone to create that spectrum.
“Sepia is a softer manipulation of light.” This gives them a softer, dreamier aesthetic.</p>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">sepia_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_3d" title="Link to this definition">¶</a></dt>
<dd><p>Apply a sepia tone filter to a 3D RGB(A) image array (inplace).</p>
<p>This function processes a 3D NumPy array representing pixel data in RGB(A) format
and applies a sepia filter. The sepia effect is achieved by adjusting the red,
green, and blue channels according to predefined coefficients, creating a warm-toned,
vintage effect. The function modifies the input array directly and does not return anything.</p>
<p>Only arrays with shapes (w, h, 3) for RGB or (w, h, 4) for RGBA are supported.</p>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D array with shape (w, h, 3) for RGB or (w, h, 4) for RGBA pixel data, where
<cite>w</cite> is the width, <cite>h</cite> is the height, and <cite>3</cite> or <cite>4</cite> corresponds to the RGB or RGBA channels.
The array must have dtype uint8 (unsigned char) with pixel values ranging from 0 to 255.</p>
<p><strong>Raises:</strong></p>
<p><strong>ValueError</strong>
If the input array does not have the expected shape (w, h, 3) or (w, h, 4).</p>
<p><strong>TypeError</strong>
If the input array does not have dtype uint8.</p>
<p><strong>Notes:</strong></p>
<ul class="simple">
<li><p>This function modifies the input <cite>rgb_array</cite> directly (inplace).</p></li>
<li><p>If the input is in RGBA format, the alpha channel is preserved.</p></li>
<li><p>The sepia effect is applied by adjusting the luminosity of the RGB channels using a set of coefficients.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assuming rgb_array is a 3D NumPy array with shape (w, h, 3) for RGB or (w, h, 4) for RGBA:</span>
<span class="n">sepia_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_1d" title="Link to this definition">¶</a></dt>
<dd><p>Convert a 1D array of uint8 data (RGB(A)) to sepia equivalent (inplace).</p>
<p>While traditional black-and-white photographs use a standard grayscale to create
highlights and shadows, sepia-toned photos use a reddish-brown tone to create that spectrum.
“Sepia is a softer manipulation of light,” creating a softer, dreamier aesthetic.</p>
<p><strong>Example Usage:</strong></p>
<p>For a 24-bit image (RGB):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For a 32-bit image (RGBA):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 1D array of shape (w,) containing uint8 pixel data (values ranging from 0 to 255) in RGB(A) format.
Can be either a NumPy array or a raw byte buffer.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input is treated as a 24-bit RGB buffer.
If <cite>False</cite>, the input is treated as a 32-bit RGBA buffer.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input array in place and does not return a new array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median" title="Link to this definition">¶</a></dt>
<dd><p>Apply a median filter to a surface (inplace).</p>
<p>The median filter is a non-linear image filtering technique commonly used for
removing noise from an image or signal. It works by replacing each pixel value
with the median of the pixel values in a neighborhood defined by the kernel size.
This technique is widely used for noise reduction in digital image processing,
especially for preserving edges while removing noise.</p>
<p>The strength of the effect is controlled by the <cite>kernel_size</cite> parameter, with
larger kernel sizes producing stronger filtering effects. However, larger kernel
sizes may also slow down the process significantly.</p>
<p><strong>Note:</strong> This filter is not suitable for real-time rendering in games or animations
due to its computational cost.</p>
<p><strong>Example Usage:</strong></p>
<p>For a 24-bit image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For a 32-bit image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface object (24-bit or 32-bit) containing the image to be processed.
It can have or lack an alpha channel for transparency.</p>
<p><strong>kernel_size_</strong> (unsigned short int, optional, default=2)
The size of the kernel or neighborhood of pixels used for the median calculation.
Increasing the kernel size improves the filter effect but decreases performance.</p>
<p><strong>fast_</strong> (bool, optional, default=True)
A flag to enable fast calculation. If <cite>True</cite>, the filter uses a smaller texture
size to improve performance, which may reduce the quality based on the <cite>reduce_factor_</cite> argument.</p>
<p><strong>reduce_factor_</strong> (unsigned short int, optional, default=1)
A factor to reduce the size of the surface before processing. A value of 1 divides
the surface by 2, and a value of 2 reduces the surface by 4. Values larger than 2
may degrade the image quality. Has no effect if <cite>fast_</cite> is <cite>False</cite>.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the surface directly (in-place) and does not return a value.</p>
<p><strong>Raises:</strong></p>
<p><strong>ValueError</strong>
If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite> or if the <cite>kernel_size_</cite> or
<cite>reduce_factor_</cite> are out of valid ranges.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.painting">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">painting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.painting" title="Link to this definition">¶</a></dt>
<dd><p>Apply a painting effect (in-place) to a Pygame surface.</p>
<p>This function transforms an image to resemble a hand-painted artistic style.
It achieves this by using a fast median filter algorithm (<cite>median_fast</cite>), which
smooths pixel values while maintaining edge details, giving the image a brushstroke-like appearance.</p>
<p><strong>Note:</strong>
- This method <strong>modifies the input surface in place</strong>.
- It <strong>is not optimized for real-time rendering</strong> and is intended for offline processing of images.</p>
<p><strong>Example Usage:</strong></p>
<p>For a 24-bit or 32-bit image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">painting</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit), with or without per-pixel transparency (alpha channel).</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input surface directly.</p>
<p><strong>Raises:</strong></p>
<p>ValueError
If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite>.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixels" title="Link to this definition">¶</a></dt>
<dd><p>Apply a pixelation effect to an image (INPLACE).</p>
<p>Pixelation is a visual effect where an image is displayed at a low resolution,
making individual pixels (small, single-colored square elements) clearly visible.
This technique is often used in digital graphics to create artistic styles,
censor parts of an image, or simulate retro, low-resolution video game graphics.</p>
<p>This function modifies the input surface in-place, reducing fine details and
emphasizing blocky pixel structures.</p>
<p><strong>Example Usage:</strong></p>
<p>For both 24-bit and 32-bit images:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Rescale image</span>
<span class="n">pixels</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c1"># Apply pixelation effect</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit image) with or without per-pixel transparency (alpha channel).</p>
<p><strong>Returns:</strong></p>
<p>None
The input surface is modified directly (in-place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median_grayscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median_grayscale" title="Link to this definition">¶</a></dt>
<dd><p>Apply a median filter to a grayscale version of the image (INPLACE).</p>
<p>The <strong>median filter</strong> is a non-linear digital filtering technique commonly
used to remove noise from images while preserving edges. It is widely used
in digital image processing as a pre-processing step for tasks such as edge
detection and segmentation.</p>
<p>This function converts the input surface to grayscale and applies a median
filter effect. The strength of the filtering effect is controlled by the
<cite>kernel_size_</cite> parameter.</p>
<p>⚠ <strong>Note</strong>:
- This method <strong>modifies the surface in place</strong>.
- It is <strong>not suitable for real-time rendering</strong>.
- Compatible with <strong>24-bit and 32-bit surfaces</strong>, with or without an alpha channel.</p>
<p><strong>Example Usage:</strong></p>
<p>Apply median filter to a 24-bit image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply median filter to a 32-bit image (with alpha channel):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit, with or without alpha).</p>
<p><strong>kernel_size_</strong> (int, optional, default=2)
The size of the kernel (neighborhood of pixels considered for filtering).
Must be greater than 0. Increasing the kernel size enhances the filtering
effect but significantly impacts performance.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input surface directly (in-place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.posterize_surface">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">posterize_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.posterize_surface" title="Link to this definition">¶</a></dt>
<dd><p>Reduce the number of colors in an image (INPLACE).</p>
<p>This function decreases the number of unique colors in the given surface,
effectively creating a posterization effect. Reducing colors can be useful
for artistic effects, image compression, or preprocessing for stylized
graphics.</p>
<p>⚠ <strong>Note</strong>:
- <strong>Modifies the surface in place</strong>.
- <strong>Works with 24-bit and 32-bit surfaces</strong>, with or without an alpha channel.
- If the surface has a <strong>32-bit per-pixel alpha channel</strong>, the alpha layer will
be disregarded, meaning the effect is applied only to RGB values.</p>
<p><strong>Example Usage:</strong></p>
<p>Reduce the number of colors in a Pygame surface to 8:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">color_reduction</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit, with or without alpha).</p>
<p><strong>color_</strong> (int, optional, default=8)
The number of colors to reduce the image to.
Must be greater than 0. Lower values produce a more dramatic effect.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input surface directly (in-place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel" title="Link to this definition">¶</a></dt>
<dd><p>Apply Sobel Edge Detection (Inplace)</p>
<p>The Sobel operator, also known as the Sobel-Feldman operator, is commonly used in image processing
for edge detection. It highlights edges in an image by emphasizing areas with high intensity
gradients.</p>
<p>This function applies the Sobel edge detection to a Pygame surface, transforming the surface to emphasize
its edges based on the gradient of pixel intensities.</p>
<p>The input surface must be in grayscale (24 - 32 bit) for best results. If the surface is not in grayscale,
only the red channel will be used for the edge detection.</p>
<p><strong>Example usage:</strong></p>
<p>Apply Sobel edge detection with a threshold of 64:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame.Surface object (24 - 32 bit depth), which may or may not have an alpha channel.
The surface should be greyscaled, although non-greyscale images will use the red channel
for edge detection.</p>
<p><strong>threshold_</strong> (int, optional, default=64)
An integer representing the threshold for detecting edges.
The threshold determines the sensitivity of edge detection, with higher values requiring
stronger gradients to be considered an edge.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input surface in place, updating it with the Sobel edge detection result.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">greyscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_1d" title="Link to this definition">¶</a></dt>
<dd><p>Apply 1D Sobel Edge Detection (Inplace)</p>
<p>This function applies the 1D Sobel operator to a given image (or surface), emphasizing
the edges in the horizontal or vertical direction based on the gradient of pixel intensities.
It modifies the input buffer(s) in place.</p>
<p><strong>Example usage:</strong></p>
<p>For 24-bit image:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">grey</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>For 32-bit image (with alpha):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>w</strong> (int)
Width of the Pygame surface that the source array (<cite>bgr_array</cite>) is referencing.</p>
<p><strong>h</strong> (int)
Height of the Pygame surface that the source array (<cite>bgr_array</cite>) is referencing.</p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D C-buffer of type uint8 containing pixel data in BGR format. If the image is not
greyscale, the algorithm processes all three RGB channels. If greyscale is enabled, only
the blue channel is used for edge detection.</p>
<p><strong>tmp_array</strong> (numpy.ndarray, optional)
A 1D C-buffer of type uint8 containing pixel data in BGR format. It is a copy of the
source <cite>bgr_array</cite>. Both <cite>bgr_array</cite> and <cite>tmp_array</cite> must have the same size and
data format. This is used as a temporary buffer during processing.</p>
<p><strong>threshold</strong> (int, optional, default=64)
The threshold for edge detection. Pixels with gradient values above this threshold will
be considered edges.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input array is assumed to be in 32-bit BGRA format. If <cite>False</cite>, the input
array is assumed to be in 24-bit BGR format.</p>
<p><strong>greyscale</strong> (bool, optional, default=False)
If <cite>True</cite>, the algorithm processes only the blue channel for edge detection, which can
simplify the computation for greyscale images. If <cite>False</cite>, all three RGB channels are
used in the Sobel operator.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input buffers (<cite>bgr_array</cite> and <cite>tmp_array</cite>) in place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_fast" title="Link to this definition">¶</a></dt>
<dd><p>Fast sobel (inplace)</p>
<p>The Sobel operator, sometimes called the Sobel–Feldman operator or Sobel filter,
is used in image processing and computer vision, particularly within edge detection
algorithms where it creates an image emphasising edges.</p>
<p>This function transforms the game display or a Pygame surface into a Sobel equivalent model.
It is faster than the standard Sobel operator (<cite>sobel_inplace_c</cite>) as it down-scales the
array containing all the pixels and applies the Sobel algorithm to a smaller sample. After
processing, the array is re-scaled to its original dimensions. While this method is theoretically
faster, down-scaling and up-scaling an array results in a decrease in overall image quality
(e.g., jagged lines, no anti-aliasing).</p>
<p><strong>Compatible with 24-bit and 32-bit surfaces</strong>, with or without an alpha layer.
The surface must be greyscale, but non-greyscale images will also work; however, only
the red channel will be used for Sobel edge detection.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel_fast</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit) with or without an alpha layer.</p>
<p><strong>threshold_</strong> (int, optional, default=64)
An integer representing the threshold for edge detection. Pixels with gradient values
above this threshold are considered edges.</p>
<p><strong>factor_</strong> (unsigned short int, optional, default=1)
An integer that controls the down-scaling factor of the image. A value of 1 means no down-scaling,
and larger values reduce the size of the image before processing.</p>
<p><strong>Returns:</strong></p>
<p>None
This function modifies the input surface directly (in-place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert" title="Link to this definition">¶</a></dt>
<dd><p>Invert pixels (inplace)</p>
<p>Inverting an image means inverting the pixel values. Images are represented using RGB
or Red-Green-Blue values, where each channel can take an integer value between 0 and 255
(both inclusive). For example, red is represented as (255, 0, 0), white as (255, 255, 255),
black as (0, 0, 0), and so on. Inverting an image means reversing the colors. For instance,
the inverted color for red will be (0, 255, 255), where 255 becomes 0 and 0 becomes 255.
Effectively, inverting an image is equivalent to subtracting the original RGB values from 255.</p>
<p><strong>Compatible with 24-bit and 32-bit surfaces</strong>, with or without an alpha channel.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">invert</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit) with or without an alpha channel.</p>
<p><strong>Returns:</strong></p>
<p>None
This function modifies the input surface directly (in-place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert_copy" title="Link to this definition">¶</a></dt>
<dd><p>Invert pixels and return a copy</p>
<p>Inverting an image means inverting the pixel values. Images are represented using RGB
or Red-Green-Blue values, where each channel can take an integer value between 0 and 255
(both inclusive). For example, red is represented as (255, 0, 0), white as (255, 255, 255),
black as (0, 0, 0), and so on. Inverting an image means reversing the colors. For instance,
the inverted color for red will be (0, 255, 255), where 255 becomes 0 and 0 becomes 255.
Effectively, inverting an image is equivalent to subtracting the original RGB values from 255.</p>
<p><strong>Compatible with 24-bit and 32-bit surfaces</strong>, with or without an alpha channel.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inv</span> <span class="o">=</span> <span class="n">invert_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame-compatible surface (24-bit or 32-bit) with or without an alpha channel.</p>
<p><strong>Returns:</strong></p>
<p>(pygame.Surface)
A new surface with inverted pixels, leaving the original surface unchanged.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert3d" title="Link to this definition">¶</a></dt>
<dd><p>Invert 3D array pixels (inplace)</p>
<p>Inverting an image means inverting the pixel values. Images are represented using RGB
or Red-Green-Blue values, where each channel can take an integer value between 0 and 255
(both inclusive). For example, red is represented as (255, 0, 0), white as (255, 255, 255),
black as (0, 0, 0), and so on. Inverting an image means reversing the colors. For instance,
the inverted color for red will be (0, 255, 255), where 255 becomes 0 and 0 becomes 255.
Effectively, inverting an image is equivalent to subtracting the original RGB values from 255.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D array with shape (w, h, n), where <cite>w</cite> and <cite>h</cite> represent the width and height of the image,
and <cite>n</cite> is the number of channels (e.g., 3 for RGB, 4 for RGBA). The array contains pixel data in
RGB(A) or similar formats, such as BGR, BGRA.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input array in place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d" title="Link to this definition">¶</a></dt>
<dd><p>Invert directly a C-buffer pixel values</p>
<p>Inverting an image means inverting the pixel values. Images are represented using RGB
or Red-Green-Blue values, where each channel can take an integer value between 0 and 255
(both inclusive). For example, red is represented as (255, 0, 0), white as (255, 255, 255),
black as (0, 0, 0), and so on. Inverting an image means reversing the colors. For instance,
the inverted color for red will be (0, 255, 255), where 255 becomes 0 and 0 becomes 255.
Effectively, inverting an image is equivalent to subtracting the original RGB values from 255.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 1D array (C-buffer) with uint8 data type containing pixel data in RGB(A) format. The method
works with other formats such as BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the array is assumed to be in RGBA format (32-bit). If <cite>False</cite>, the array is assumed
to be in RGB format (24-bit).</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input array in place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Invert directly a C-buffer pixel values (return a copy)</p>
<p>Inverting an image means inverting the pixel values. Images are represented using RGB
or Red-Green-Blue values, where each channel can take an integer value between 0 and 255
(both inclusive). For example, red is represented as (255, 0, 0), white as (255, 255, 255),
black as (0, 0, 0), and so on. Inverting an image means reversing the colors. For instance,
the inverted color for red will be (0, 255, 255), where 255 becomes 0 and 0 becomes 255.
Effectively, inverting an image is equivalent to subtracting the original RGB values from 255.</p>
<p>This function returns a copy of the input array with the pixel values inverted.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 1D array (C-buffer) with uint8 data type containing pixel data in RGB(A) format. The method
works with other formats such as BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the array is assumed to be in RGBA format (32-bit). If <cite>False</cite>, the array is assumed
to be in RGB format (24-bit).</p>
<p><strong>Returns:</strong></p>
<p>numpy.ndarray
A 1D array with uint8 data type, representing a copy of the input buffer with inverted pixel values.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl_effect" title="Link to this definition">¶</a></dt>
<dd><p>Apply Hue Rotation to an Image (HSL Color Space)</p>
<p>This function directly modifies the hue of a Pygame surface using the HSL (Hue, Saturation,
Lightness) color model. Hue rotation shifts the colors of the surface in a way that corresponds
to a rotation on the color wheel, allowing you to alter the overall color tone.</p>
<p>The surface must be compatible with 24-bit or 32-bit color depth, with or without an alpha layer.
If the <cite>shift</cite> value is 0.0, the surface remains unchanged.</p>
<p>The hue shift value must be within the range [0.0, 1.0], where 0.0 represents no rotation, and 1.0
represents a 360-degree rotation.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hsl_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift to the surface.</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit or 32-bit color formats (with or without alpha).</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0], where 0.0 corresponds to no hue shift,
and 1.0 corresponds to a full 360-degree rotation of the hue.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input <cite>surface_</cite> in place, applying the hue shift effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl3d" title="Link to this definition">¶</a></dt>
<dd><p>Apply Hue Rotation to a 3D Array (HSL Color Space)</p>
<p>This function applies hue rotation to a 3D numpy array representing an image in the HSL (Hue, Saturation,
Lightness) color space. The hue shift is applied directly to the array, modifying the color tone of the image.</p>
<p>The array must be in the shape (w, h, n), where <cite>w</cite> is the width, <cite>h</cite> is the height, and <cite>n</cite> is the number
of color channels (3 for RGB or 4 for RGBA, etc.). The data type should be uint8.</p>
<p>The <cite>shift</cite> value must be within the range [0.0, 1.0], where 0.0 represents no hue rotation, and 1.0 represents
a full 360-degree hue rotation.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D numpy array with shape (w, h, n) containing RGB or RGBA pixel data.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0], representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree hue shift.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input <cite>rgb_array</cite> in place, applying the hue shift.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d" title="Link to this definition">¶</a></dt>
<dd><p>Apply Hue Rotation to a C-buffer (HSL Color Space)</p>
<p>This function performs hue rotation on a C-buffer (1D array) containing pixel data in RGB(A) format
using the HSL (Hue, Saturation, Lightness) color model. It modifies the array in place.</p>
<p>The function supports pixel formats like RGB, BGR, RGBA, and BGRA, adjusting the hue of each pixel
according to the specified <cite>shift</cite>. The <cite>shift</cite> value should be in the range [0.0, 1.0], which
corresponds to a rotation of 0.0 to 360.0 degrees on the hue color wheel.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D numpy array (C-buffer) of type uint8 containing pixel data in RGB(A) format.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0] representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input array is assumed to be in 32-bit RGBA format.
If <cite>False</cite>, the array is assumed to be in 24-bit RGB format.</p>
<p><strong>Returns:</strong></p>
<p>None
The function modifies the input <cite>bgr_array</cite> in place by applying the hue shift.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Rotate hue (HSL) directly to a C-buffer (return a copy)</p>
<p>This function performs a hue rotation in the HSL (Hue, Saturation, Lightness) color space on a C-buffer
(1D array) containing pixel data in RGB(A) format, returning a modified copy of the array.</p>
<p>The method works with pixel formats like RGB, BGR, RGBA, and BGRA. The hue shift (<cite>shift</cite>) value should
be in the range [0.0, 1.0], corresponding to a rotation of 0.0 to 360.0 degrees.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D numpy array (C-buffer) of type uint8 containing pixel data in RGB(A) format.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0], representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input array is assumed to be in 32-bit RGBA format.
If <cite>False</cite>, the array is assumed to be in 24-bit RGB format.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A 1D numpy array of type uint8 containing the pixel data with the rotated hue.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv_effect" title="Link to this definition">¶</a></dt>
<dd><p>Apply Hue Rotation to a Surface (HSV Color Space)</p>
<p>This function applies a hue rotation to a Pygame surface using the HSV (Hue, Saturation, Value) color model.
It modifies the surface in place, rotating the hue of the colors on the surface based on the specified shift.</p>
<p>The surface must be compatible with 24-bit or 32-bit color formats, with or without an alpha channel.
The hue shift is specified as a float value in the range [0.0, 1.0], where 0.0 corresponds to no hue change,
and 1.0 represents a full 360-degree hue rotation.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees (0.2 * 360)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit or 32-bit color formats (with or without alpha).</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0], specifying the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input surface in place by applying the hue shift.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv3d" title="Link to this definition">¶</a></dt>
<dd><p>Rotate hue 3d array</p>
<p>Rotate the hue (HSV conversion method), directly from a 3d array</p>
<p>Compatible 24 - 32 bit with or without alpha layer</p>
<p>HSV (Hue, Saturation, Value) is a color model similar to HSL (Hue, Saturation, Lightness)
but with some differences in how it represents and manipulates colors.
It’s often used in graphics software and computer vision applications for its
simplicity in specifying and adjusting color attributes.</p>
<p>New Shift value. Must be between [0.0 … 1.0] corresponding to 0.0 - 360.0 degrees
(e.g 0.5 = 180 degrees)</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsv3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D numpy array with shape (w, h, n) containing RGB or RGBA pixel data.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0] representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>rgb_array</cite> in place by applying the hue shift.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d" title="Link to this definition">¶</a></dt>
<dd><p>Rotate hue 1d array</p>
<p>Rotate the hue directly from a C-buffer (1d array uint8 data types RGB(A) format)
Changes apply inplace</p>
<p>This method works with other buffer formats such as BGR, BGRA.</p>
<p>HSV (Hue, Saturation, Value) is a color model similar to HSL (Hue, Saturation, Lightness)
but with some differences in how it represents and manipulates colors.
It’s often used in graphics software and computer vision applications for its
simplicity in specifying and adjusting color attributes.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compatible with 32-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Compatible with 24-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D numpy array (C-buffer) of type uint8 containing pixel data in BGR(A) format.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0] representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input array is assumed to be in 32-bit BGRA format.
If <cite>False</cite>, the array is assumed to be in 24-bit BGR format.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>bgr_array</cite> in place by applying the hue shift.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Rotate the hue 1d array (return a copy)</p>
<p>HSV 1d array (C buffer) uint8 data types RGB(A) format</p>
<p>This method works with other buffer formats such as BGR, BGRA.</p>
<p>HSV (Hue, Saturation, Value) is a color model similar to HSL (Hue, Saturation, Lightness)
but with some differences in how it represents and manipulates colors.
It’s often used in graphics software and computer vision applications for its
simplicity in specifying and adjusting color attributes.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>

<span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray)
A 1D numpy array (C-buffer) of type uint8 containing pixel data in RGB(A) format.
The array can also represent other formats such as BGR, BGRA.</p>
<p><strong>shift</strong> (float)
A float value in the range [0.0, 1.0] representing the hue rotation.
A value of 0.0 means no rotation, while 1.0 corresponds to a full 360-degree rotation.</p>
<p><strong>format_32</strong> (bool, optional, default=False)
If <cite>True</cite>, the input array is assumed to be in 32-bit BGRA format.
If <cite>False</cite>, the array is assumed to be in 24-bit BGR format.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new 1D numpy array of type uint8 containing the pixels with the rotated hue.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave" title="Link to this definition">¶</a></dt>
<dd><p>Apply Wave Effect to a Surface (Inplace)</p>
<p>This function applies a wave effect to a Pygame surface, modifying it in place.
The effect is applied to the surface based on an angle (in radians) and the
number of sub-surfaces. It is compatible with 24-bit surfaces.</p>
<p>The wave effect creates a dynamic, wave-like distortion, often used for water
or other fluid-like visual effects in games.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">+</span> <span class="n">frame_number</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Animate with a changing angle</span>
<span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave with a fixed angle</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit color depth.</p>
<p><strong>rad</strong> (float)
The angle in radians for the wave effect. This value controls the wave’s
motion over time.</p>
<p><strong>size</strong> (int, optional, default=5)
The number of sub-surfaces used to create the wave effect. A higher number
results in a more complex wave.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input surface in place, applying the wave effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave32" title="Link to this definition">¶</a></dt>
<dd><p>Apply Wave Effect to a 32-bit Surface (Inplace)</p>
<p>This function applies a wave effect to a 32-bit Pygame surface, modifying it in place.
The effect is applied to both the RGB and alpha channels, meaning the wave will
also displace the alpha layer (transparency) of the surface. It is fully compatible
with 32-bit SDL surfaces, including those with an alpha channel.</p>
<p>The wave effect creates a dynamic distortion that simulates the motion of waves,
often used for effects like water or fluid movement in games.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave32</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave effect with a rotating angle</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 32-bit color depth and alpha channel (RGBA).</p>
<p><strong>rad</strong> (float)
The angle in radians for the wave effect, controlling its rotation over time.</p>
<p><strong>size</strong> (int, optional, default=5)
The number of sub-surfaces used to create the wave effect. A higher value results
in a more detailed wave.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input surface in place, applying the wave effect to both
the color and alpha channels.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave_static">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave_static</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave_static" title="Link to this definition">¶</a></dt>
<dd><p>Wave effect for static background (inplace)</p>
<p>This function is different from the <cite>wave</cite> method as a copy of the static
background or game display is passed to the function as an argument <cite>array_</cite> to
improve overall performance.</p>
<p>Compatible with 24-bit surfaces.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">wave_static</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background_cp</span><span class="p">),</span> <span class="n">FRAME</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit color depth.</p>
<p><strong>array_</strong> (numpy.ndarray)
A 3D numpy array with shape (w, h, 3), type <cite>uint8</cite>, representing a copy of the
game display or image to be modified.</p>
<p><strong>rad</strong> (float)
The angle in radians for the wave effect, controlling its rotation over time.</p>
<p><strong>size</strong> (int, optional, default=5)
The number of sub-surfaces used to create the wave effect. A higher value results
in a more detailed wave.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>array_</cite> in place, applying the wave effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array_cp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl" title="Link to this definition">¶</a></dt>
<dd><p>Swirl an image (inplace)</p>
<p>The swirl effect is a visual distortion that creates a spiraling appearance in an image or graphic.
This effect can draw attention to specific areas of a design and add a sense of movement or dynamism.
It can be used creatively in various contexts, from social media graphics to advertising and digital art.</p>
<p><strong>Works with:</strong> 24-bit and 32-bit image formats, but not compatible with 32-bit due to the alpha layer.</p>
<p>If the image is in 32-bit with an alpha channel, the alpha layer will remain unchanged during the transformation,
causing the alpha layer to bleed over the effect. To avoid this, convert the image to 24-bit.
For 32-bit images with an alpha layer, use the <cite>swirl32</cite> method (designed for 32-bit).</p>
<p>This algorithm uses a table of cosines and sines to achieve the effect.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># in the game loop</span>
<span class="n">swirl</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">angle</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit and 32-bit formats. However, not compatible with 32-bit due to the alpha channel.</p>
<p><strong>rgb_array_cp</strong> (numpy.ndarray)
A 3D numpy array with shape (w, h, 3), containing RGB pixel data. A copy of the image to swirl. Both <cite>surface_</cite> and <cite>rgb_array_cp</cite> must have the same shape and type.</p>
<p><strong>degrees</strong> (float)
The angle in degrees for the swirl effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by applying the swirl effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl32" title="Link to this definition">¶</a></dt>
<dd><p>Swirl an image (inplace)</p>
<p><strong>Compatible with:</strong> 24-bit and 32-bit formats (with or without alpha layer).</p>
<p>The swirl effect is a visual distortion that creates a spiraling appearance in an image or graphic.
This effect can draw attention to specific areas of a design and add a sense of movement or dynamism.
It can be used creatively in various contexts, from social media graphics to advertising and digital art.</p>
<p>This algorithm uses a table of cosines and sines for angle approximation.</p>
<p>Unlike the <cite>swirl</cite> method, <cite>swirl32</cite> takes into account the alpha layer during the transformation,
meaning it works with 32-bit images that have per-pixel transparency, preserving the alpha channel.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirl32</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit and 32-bit formats, including alpha channels.</p>
<p><strong>degrees</strong> (float)
The angle in degrees for the swirl effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by applying the swirl effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirlf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirlf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirlf" title="Link to this definition">¶</a></dt>
<dd><p>Swirl an image (inplace) with floating point accuracy</p>
<p><strong>Compatible with:</strong> 24-bit format only.</p>
<p>This algorithm does not use cosine and sine tables; instead, it calculates the angles with floating-point accuracy.</p>
<p>The swirl effect is a visual distortion that creates a spiraling appearance in an image or graphic.
This effect can draw attention to specific areas of a design and add a sense of movement or dynamism.
It can be used creatively in various contexts, from social media graphics to advertising and digital art.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirlf</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit formats.</p>
<p><strong>degrees</strong> (float)
The angle in degrees for the swirl effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by applying the swirl effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma_config">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hue_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma_config" title="Link to this definition">¶</a></dt>
<dd><p>Create a basic plasma effect on the top of a Pygame surface (inplace)</p>
<p><strong>Compatible with:</strong> 24 - 32-bit surfaces, with or without an alpha layer.</p>
<p>This function creates a plasma effect that can be applied to a Pygame surface. It modifies the surface in place.
The effect simulates plasma-like visual distortions using mathematical factors such as hue, saturation, and value.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma_config</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit or 32-bit formats.</p>
<p><strong>frame</strong> (int)
A variable that changes over time, controlling the plasma effect’s progression.</p>
<p><strong>hue_</strong> (float, optional)
A factor controlling the hue, default value is 1.0/6.0.</p>
<p><strong>sat_</strong> (float, optional)
A factor controlling the saturation, default value is 1.0/6.0.</p>
<p><strong>value_</strong> (float, optional)
A factor controlling the value, default value is 1.0/8.0.</p>
<p><strong>a_</strong> (float, optional)
A control parameter for the plasma equation, default value is 1.0/255.0.</p>
<p><strong>b_</strong> (float, optional)
A control parameter for the plasma equation, default value is 1.0/12.0.</p>
<p><strong>c_</strong> (float, optional)
A control parameter for the plasma equation, default value is 1.0/12.0.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by applying the plasma effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">palette_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma" title="Link to this definition">¶</a></dt>
<dd><p>Apply plasma effect in place to a surface</p>
<p>This function generates a dynamic plasma effect on a Pygame surface. The effect evolves
over time, producing a fluid, glowing visual pattern. The plasma effect is applied directly
to the surface, modifying its pixels in place.</p>
<p>The function works with both 24-bit and 32-bit surfaces (with or without an alpha channel).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">,</span> <span class="n">palette</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface, compatible with 24-bit or 32-bit formats. The plasma effect is applied
directly to this surface, modifying its pixels in place.</p>
<p><strong>frame</strong> (float)
The current frame number, which drives the evolution of the plasma effect. This value
determines the shifting patterns and animation in the plasma effect.</p>
<p><strong>palette_</strong> (numpy.ndarray)
A 1D array containing a palette of colors (as unsigned integers) used to generate the
plasma effect. The colors are applied cyclically to create the visual effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by applying the plasma effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness" title="Link to this definition">¶</a></dt>
<dd><p>Adjust brightness in place</p>
<p>This function controls the brightness level of a Pygame display or SDL surface. The <cite>shift_</cite>
parameter is a float value in the range [-1.0, 1.0], where +1.0 represents the maximum brightness,
and 0.0 applies no changes to the surface. Negative values darken the surface.</p>
<p>The function works with both 24-bit and 32-bit surfaces (with or without an alpha channel).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats (with or without an alpha channel).</p>
<p><strong>shift_</strong> (float)
A float value in the range [-1.0, 1.0], where +1.0 increases brightness, 0.0 keeps the surface unchanged,
and negative values decrease brightness.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>surface_</cite> in place by adjusting its brightness.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness3d" title="Link to this definition">¶</a></dt>
<dd><p>Adjust brightness of a 3D image array in place</p>
<p>This function adjusts the brightness of an image by modifying its 3D array in place. The array
should be of shape (w, h, n) where <cite>n</cite> is typically 3 (RGB) or 4 (RGBA). The <cite>shift</cite> parameter
controls the brightness level and must be a float in the range [-1.0, 1.0]. Positive values
increase brightness, negative values decrease it, and 0.0 results in no change.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D numpy array of shape (w, h, n), where <cite>n</cite> is the number of color channels (3 for RGB or 4 for RGBA).
The array should contain uint8 data (0–255 values for each color channel).</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, 1.0] that controls the brightness level. Positive values increase brightness,
negative values decrease it, and 0.0 leaves the array unchanged.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>rgb_array</cite> in place by adjusting its brightness.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d" title="Link to this definition">¶</a></dt>
<dd><p>Control brightness of an image from a C buffer (in place)</p>
<p>This function adjusts the brightness of an image based on a 1D array buffer. The buffer should
represent the pixel data of the image in either the BGR(A) or RGB(A) format. The brightness is
adjusted by a <cite>shift</cite> value, which must be a float in the range [-1.0, 1.0]. The <cite>format_32</cite> parameter
indicates whether the buffer is 32-bit (<cite>True</cite> for BGRA) or 24-bit (<cite>False</cite> for BGR).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray or bytearray)
A 1D numpy array or bytearray containing pixel data in BGR(A) or RGB(A) format. The array should
contain uint8 data (0–255 values for each color channel).</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, 1.0] that controls the brightness level. Positive values increase brightness,
negative values decrease it, and 0.0 leaves the array unchanged.</p>
<p><strong>format_32</strong> (bool)
A boolean indicating whether the buffer is 32-bit (<cite>True</cite> for BGRA) or 24-bit (<cite>False</cite> for BGR).</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the input <cite>bgr_array</cite> in place by adjusting its brightness.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d_copy" title="Link to this definition">¶</a></dt>
<dd><p>Control brightness of an image (return a copy)</p>
<p>This function adjusts the brightness of an image given its C-buffer. The <cite>bgr_array</cite> should be a 1D
array containing pixel data in either the BGR or BGRA format. The function returns a new array with
the brightness adjusted based on the <cite>shift</cite> value, which must be a float in the range [-1.0, 1.0].
The <cite>format_32</cite> parameter specifies whether the image is 32-bit (BGRA) or 24-bit (BGR).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray or bytearray)
A 1D numpy array or bytearray containing pixel data in BGR(A) or RGB(A) format. The array should
contain uint8 data (0–255 values for each color channel).</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, 1.0] that controls the brightness level. Positive values increase brightness,
negative values decrease it, and 0.0 leaves the array unchanged.</p>
<p><strong>format_32</strong> (bool)
A boolean indicating whether the buffer is 32-bit (<cite>True</cite> for BGRA) or 24-bit (<cite>False</cite> for BGR).</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new numpy array containing the pixel data with adjusted brightness. The original array is not modified.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_copy" title="Link to this definition">¶</a></dt>
<dd><p>Brightness (return a copy)</p>
<p>This function applies a brightness transformation to a new SDL surface. The brightness level of the
surface is modified based on the <cite>shift</cite> parameter, which is a float in the range [-1.0, 1.0]. A value of
+1.0 corresponds to the maximum brightness, while a value of 0.0 will leave the surface unchanged.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">brightness_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with either 24-bit or 32-bit formats, with or without an alpha channel.</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, 1.0] that adjusts the brightness of the surface. Positive values increase brightness,
negative values decrease it, and 0.0 leaves the surface unchanged.</p>
<p><strong>Returns:</strong></p>
<p><strong>pygame.Surface</strong>
A new Pygame surface with adjusted brightness, in 24-bit format without an alpha channel.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_exclude">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_exclude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_exclude" title="Link to this definition">¶</a></dt>
<dd><p>Brightness adjustment with color exclusion (inplace)</p>
<p>This function modifies the brightness of an image, excluding a specific color from the transformation process.
The <cite>shift_</cite> parameter controls the brightness level, with +1.0 being the maximum brightness. The color exclusion
allows you to avoid affecting specific colors during the transformation.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats.</p>
<p><strong>shift_</strong> (float)
A float value in the range [-1.0, +1.0] controlling the brightness adjustment.
+1.0 corresponds to the maximum brightness, and 0.0 will leave the surface unchanged.</p>
<p><strong>color_</strong> (tuple, optional)
A tuple of RGB values (e.g., (10, 22, 0)) to exclude from the brightness transformation.
Default is (0, 0, 0) for black.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>surface_</cite> in place, adjusting its brightness while excluding the specified color.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_bpf" title="Link to this definition">¶</a></dt>
<dd><p>Brightness adjustment with bpf exclusion (inplace)
This function adjusts the brightness of an image using a bright pass filter (bpf).
Pixels with an RGB sum below the specified <cite>bpf_threshold</cite> are excluded from the transformation.
This helps to avoid modifying darker pixels while still adjusting the brightness of others.</p>
<p>The <cite>shift_</cite> parameter controls the brightness level, with +1.0 being the maximum brightness.
The function works with both 24-bit and 32-bit images.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats.</p>
<p><strong>shift_</strong> (float)
A float value in the range [-1.0, +1.0] controlling the brightness adjustment.
+1.0 corresponds to the maximum brightness, and 0.0 will leave the surface unchanged.</p>
<p><strong>bpf_threshold</strong> (int, optional)
An integer value in the range [0, 255] that determines the threshold for the brightness filter.
Pixels with an RGB sum below this threshold will not be modified. Default value is 64.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>surface_</cite> in place, adjusting its brightness based on the given parameters.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation" title="Link to this definition">¶</a></dt>
<dd><p>Saturation adjustment (inplace)</p>
<p>This function adjusts the saturation level of a Pygame surface or texture.
A positive <cite>shift_</cite> increases the saturation, while a negative value decreases it.
The saturation shift is applied in place to the surface, meaning the original surface is modified directly.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats.</p>
<p><strong>shift_</strong> (float)
A float value in the range [-1.0, +1.0] controlling the saturation level.
A value of 1.0 corresponds to maximum saturation, 0.0 will leave the surface unchanged, and -1.0 will result in no color saturation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>surface_</cite> in place, adjusting its saturation.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation3d" title="Link to this definition">¶</a></dt>
<dd><p>Saturate 3D array directly (inplace)</p>
<p>This function adjusts the saturation level of an image by modifying its 3D array data.
The array should be in the <cite>uint8</cite> format with a shape of <cite>(w, h, 3)</cite> and should contain RGB pixel data.
Other pixel formats may also be compatible. The resulting image will be in 24-bit format without an alpha layer.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray)
A 3D numpy array (or memory view) with shape <cite>(w, h, 3)</cite> and type <cite>uint8</cite>, containing RGB or another pixel format.
It should reference an SDL surface or image data.</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, +1.0] controlling the saturation level.
A value of 1.0 corresponds to maximum saturation, 0.0 leaves the image unchanged, and -1.0 decreases saturation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>rgb_array</cite> in place, adjusting the saturation of the referenced image data.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d" title="Link to this definition">¶</a></dt>
<dd><p>Saturate 1D array directly (inplace)</p>
<p>This function adjusts the saturation level of an image by modifying its 1D data buffer.
The buffer should be in <cite>uint8</cite> format with a shape of <cite>(w,)</cite>, and it can contain RGB(A),
BGR(A), or other pixel formats. For 32-bit images, the alpha channel must be at the end
of the pixel (e.g., RGB(A) or BGR(A)).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.3</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>buffer</strong> (numpy.ndarray or memoryviewslice)
A 1D array (or memory view) with shape <cite>(w,)</cite> and type <cite>uint8</cite>, containing pixel data
in RGB(A), BGR(A), or other formats. This should reference an SDL surface or image buffer.</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, +1.0] controlling the saturation level.
A value of 1.0 corresponds to maximum saturation, 0.0 leaves the image unchanged, and -1.0 decreases saturation.</p>
<p><strong>format_32</strong> (bool, optional)
A flag indicating the pixel format:
- <cite>True</cite> for ‘RGBA’ (32-bit format with an alpha channel).
- <cite>False</cite> for ‘RGB’ (24-bit format without alpha).</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>buffer</cite> in place, adjusting the saturation of the referenced image data.
The final image retains the same pixel format as the input image.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Saturate an image using a C-buffer (return copy)</p>
<p>This function adjusts the saturation level of an image by modifying its 1D data buffer,
and returns a new array with the adjusted saturation. The <cite>buffer</cite> should be in <cite>uint8</cite> format
with a shape of <cite>(w,)</cite>, and can contain RGB(A), BGR(A), or other pixel formats. For 32-bit images,
the alpha channel must be placed at the end of the pixel format (e.g., RGB(A) or BGR(A)).</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>buffer</strong> (numpy.ndarray or memoryviewslice)
A 1D array (or memory view) with shape <cite>(w,)</cite> and type <cite>uint8</cite>, containing pixel data
in RGB(A), BGR(A), or other formats. This should reference an SDL surface or image buffer.</p>
<p><strong>shift</strong> (float)
A float value in the range [-1.0, +1.0] controlling the saturation level.
A value of 1.0 corresponds to maximum saturation, 0.0 leaves the image unchanged, and -1.0 decreases saturation.</p>
<p><strong>format_32</strong> (bool, optional)
A flag indicating the pixel format:
- <cite>True</cite> for ‘RGBA’ (32-bit format with an alpha channel).
- <cite>False</cite> for ‘RGB’ (24-bit format without alpha).</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A new 1D array with shape <cite>(w,)</cite> and type <cite>uint8</cite>, containing the same pixel format as the input array,
but with the adjusted saturation level.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatconvection">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatconvection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatconvection" title="Link to this definition">¶</a></dt>
<dd><p>Heat flow convection</p>
<p>This function simulates heat flow convection (or convective heat transfer) by applying
a Gaussian transformation to an image, creating a vertical flow effect. The transformation
is influenced by the parameters, such as amplitude, center, sigma, and mu, which modify the
intensity and direction of the effect.</p>
<p>The convection effect can be used to simulate phenomena like air turbulence or heat flow.
A periodic variable for <cite>amplitude</cite> (e.g., using a cosine function) can create dynamic, changing effects.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-24 bit image format</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/fire.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">3.14</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">heatconvection</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">mu</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># Restore the original image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats. The transformation is applied directly to this surface.</p>
<p><strong>amplitude</strong> (float)
The maximum amplitude (vertical pixel displacement) of the Gaussian transformation. If amplitude is zero,
no transformation will be applied. A periodic function can be used to create a dynamic amplitude.</p>
<p><strong>center</strong> (float, optional)
The center of the Gaussian transformation. The default is 0.0, which centers the effect.</p>
<p><strong>sigma</strong> (float, optional)
The sigma value of the Gaussian equation. A small value creates a narrow effect, while a large value widens the effect.
The default is 2.0.</p>
<p><strong>mu</strong> (float, optional)
The mu value of the Gaussian equation. When mu is periodic (e.g., using a cosine function), it allows the effect
to move horizontally. The default is 0.0.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the <cite>surface_</cite> in place, applying the heat convection effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_glitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_glitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_glitch" title="Link to this definition">¶</a></dt>
<dd><p>Horizontal glitch (inplace)</p>
<p>This function applies a horizontal glitch effect to a Pygame surface, deforming the image
horizontally based on a signal defined by the given parameters. The effect is achieved
by modifying the image’s pixels in a glitchy, random manner, influenced by the deformation,
frequency, and amplitude parameters.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_glitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats. The transformation is applied directly to this surface.</p>
<p><strong>deformation</strong> (float)
The angle in radians that controls the variation of the horizontal deformation. This value influences the overall
glitch pattern.</p>
<p><strong>frequency</strong> (float)
A factor that amplifies the angle variation. It determines the rate at which the glitch effect changes over time.</p>
<p><strong>amplitude</strong> (float)
The amplitude of the cos function used to modulate the glitch effect. A higher amplitude leads to a more intense deformation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the <cite>surface_</cite> in place, applying the horizontal glitch effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_sglitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_sglitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_sglitch" title="Link to this definition">¶</a></dt>
<dd><p>Glitch for static image background (inplace)</p>
<p>This function applies a horizontal glitch effect to a Pygame surface, modifying the image by
deforming it based on a signal defined by the deformation, frequency, and amplitude parameters.
It creates a glitch effect specifically for static image backgrounds.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_sglitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">bgr_array</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats. The transformation is applied directly to this surface.</p>
<p><strong>array_</strong> (numpy.ndarray)
A numpy array containing a pixel copy that is used for the glitch effect. This array serves as a reference for the transformation.</p>
<p><strong>deformation</strong> (float)
The angle in radians that controls the variation of the horizontal deformation. This value determines the degree of the glitch effect.</p>
<p><strong>frequency</strong> (float)
A factor that amplifies the angle variation, influencing the rate at which the glitch effect changes over time.</p>
<p><strong>amplitude</strong> (float)
The amplitude of the cos function that modulates the glitch effect. Higher amplitude results in more intense deformation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
The function modifies the <cite>surface_</cite> in place, applying the horizontal glitch effect using the provided parameters.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bpf" title="Link to this definition">¶</a></dt>
<dd><p>BPF, bright pass filter (inplace)</p>
<p>This function applies a bright pass filter to a Pygame surface, conserving only the brightest pixels.
The pixels that fall below the specified brightness threshold are excluded from the surface, effectively
brightening the image.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># For 32-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats. The transformation is applied directly to this surface.</p>
<p><strong>threshold</strong> (int)
The bright pass threshold, with a default value of 128. Pixels with brightness below this threshold will be excluded from the transformation.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>surface_</cite> in place by applying the bright pass filter.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom" title="Link to this definition">¶</a></dt>
<dd><p>Create a bloom effect (inplace)</p>
<p>This function applies a bloom effect to a Pygame surface or image. The bloom effect brightens the
image and adds a glowing effect around bright areas. The effect can be selectively filtered using
a mask, and performance can be improved with the fast option at the cost of reduced effect appearance.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the demo_bloom_mask.py script in the Demo folder</span>
<span class="n">bloom</span><span class="p">(</span><span class="n">SCREEN</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">BPF</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>surface_</strong> (pygame.Surface)
A Pygame surface compatible with 24-bit or 32-bit formats. This surface will be transformed in place by applying the bloom effect.</p>
<p><strong>threshold_</strong> (int)
An integer threshold value in the range [0…255]. This value is used to detect bright pixels within the texture or image to apply the bloom effect.</p>
<p><strong>fast_</strong> (bool)
A boolean value that, when set to <cite>True</cite>, approximates the bloom effect for performance improvement (10x - 80x), but reduces the visual intensity of the effect. Default is <cite>False</cite>.</p>
<p><strong>mask_</strong> (numpy.ndarray or memoryviewslice)
A 2D array of type uint8 representing the mask alpha, with shape <cite>(w, h)</cite>. Values in the range [0..255] control the transparency, and thus, the selective application of the bloom effect. An array filled with 255 renders the full bloom effect, while an array filled with 0 disables the effect. Intermediate values create partial bloom effects.</p>
<p><strong>Returns:</strong></p>
<p><strong>None</strong>
This function modifies the <cite>surface_</cite> in place by applying the bloom effect.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint" title="Link to this definition">¶</a></dt>
<dd><p>Create a fisheye lens model holding pixel coordinates of a surface</p>
<p>This function generates a fisheye lens model that holds the pixel coordinates for each pixel
on a given surface. The model can be used to apply a fisheye effect to a surface by mapping
its coordinates into a fisheye lens projection.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>w</strong> (int)
The width of the surface to project into the fisheye model. The value must match the surface’s width.</p>
<p><strong>h</strong> (int)
The height of the surface to project into the fisheye model. The value must match the surface’s height.</p>
<p><strong>centre_x</strong> (int)
The x-coordinate of the centre of the fisheye effect.</p>
<p><strong>centre_y</strong> (int)
The y-coordinate of the centre of the fisheye effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>numpy.ndarray</strong>
A 2D array of type <cite>np.uint32_t</cite> with shape <cite>(w, h, 2)</cite>, representing the fisheye model and holding the coordinates of all pixels projected through the fisheye lens model.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint_param">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmp_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param1_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint_param" title="Link to this definition">¶</a></dt>
<dd><p>Create a fisheye model to hold the pixel coordinates with additional parameters</p>
<p>This function generates a fisheye model that holds the pixel coordinates of a surface,
with the added ability to control the fisheye model’s aspect and focal length.</p>
<p><strong>Example usage:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">fisheye_footprint_param</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<p><strong>tmp_array_</strong> (numpy.ndarray)
A 3D array with shape <cite>(w, h, 2)</cite> of unsigned integers. The shape of this array will determine
the fisheye model.</p>
<p><strong>centre_x</strong> (float)
The x-coordinate of the fisheye effect’s center. Corresponds to half the length of the fisheye model.</p>
<p><strong>centre_y</strong> (float)
The y-coordinate of the fisheye effect’s center. Corresponds to half the width of the fisheye model.</p>
<p><strong>param1_</strong> (float)
A parameter that controls the fisheye model’s aspect. Values greater than 1.0 cause the effect to converge to the center,
while values less than 1.0 cause the effect to diverge from the center.</p>
<p><strong>focal_length</strong> (float)
Controls the type of fisheye lens. Values greater than 1.0 create a diverging lens effect, while values less than 0
create a converging lens effect.</p>
<p><strong>Returns:</strong></p>
<p><strong>void</strong>
This function performs an inplace transformation on the provided <cite>tmp_array_</cite>, updating it with the fisheye model’s coordinates.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisheye_model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye" title="Link to this definition">¶</a></dt>
<dd><p>Display surface or gameplay through a lens effect (inplace).</p>
<p>Compatible with 24-bit surfaces only.</p>
<p>A fisheye lens is an ultra wide-angle lens that produces strong visual
distortion intended to create a wide panoramic or hemispherical image.</p>
<p>This function applies a fisheye lens effect in real-time. To achieve this,
the algorithm utilizes a pre-calculated lens model transformation that is
stored in a numpy ndarray, passed as the <cite>fisheye_model</cite> argument. The
<cite>fisheye_model</cite> array has a shape of (w, h, 2) and contains pixel coordinates
of the surface after lens transformation. All calculations are performed upstream.</p>
<p>Use the function <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code> to create the pre-calculated array.
This method needs to be called only once.</p>
<p>The fisheye lens transformation is applied inplace.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A surface object that is compatible with 24-bit color depth.
- <cite>fisheye_model</cite> (numpy.ndarray): A numpy array with shape (w, h, 2) containing uint32 values that represent the transformed pixel coordinates (<cite>x’</cite>, <cite>y’</cite>). These values are pre-calculated using the <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code> function.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The transformation is applied inplace, and no value is returned.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tv_scan">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tv_scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tv_scan" title="Link to this definition">¶</a></dt>
<dd><p>Apply a TV scanline effect on a pygame surface (inplace).</p>
<p>The space between each scanline can be adjusted with the <cite>space</cite> value.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tv_scan</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A surface object compatible with 24-bit or 32-bit color formats.
- <cite>space</cite> (int, optional): The space between each scanline. You can set a constant value or use a variable for a dynamic effect. Default is 5.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The effect is applied inplace, and no value is returned.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple" title="Link to this definition">¶</a></dt>
<dd><p>Apply a ripple effect without background deformation.</p>
<p>This function simulates a ripple effect over a surface, using previous and current states
of the ripple, along with a background image. The effect is applied without distorting the
background image, which remains static.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ripple</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.008</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>rows_</cite> (int): The screen width or surface width.
- <cite>cols_</cite> (int): The screen height or surface height.
- <cite>previous_</cite> (numpy.ndarray): A float array with shape (w, h) used for the transformation. It holds the previous state of the ripple effect.
- <cite>current_</cite> (numpy.ndarray): A float array with shape (w, h) used for the transformation. It holds the current state of the ripple effect.
- <cite>array_</cite> (numpy.ndarray): A uint8 array with shape (w, h, 3) containing the static background image in RGB format. This array remains unchanged.
- <cite>dispersion_</cite> (float, optional): The ripple dampening factor, which controls the ripple effect’s intensity. Higher values reduce the ripple effect radius. The default value is 0.008.</p>
<p><strong>Returns</strong>:
- <cite>tuple</cite>: A tuple containing two arrays <cite>(current_, previous_)</cite>, which represent the updated states of the ripple. See the Parameters section for the sizes of each array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple_seabed">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple_seabed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple_seabed" title="Link to this definition">¶</a></dt>
<dd><p>Apply a ripple effect with background deformation.</p>
<p>This function simulates a ripple effect over a surface, where the background image
is deformed as part of the effect. The function uses the previous and current states
of the ripple along with a texture and background image.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span> <span class="o">=</span> <span class="n">ripple_seabed</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span>
   <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.009</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>cols_</cite> (int): The screen width or surface width.
- <cite>rows_</cite> (int): The screen height or surface height.
- <cite>previous_</cite> (numpy.ndarray): A float array with shape (w, h) used for the transformation. It holds the previous state of the ripple effect.
- <cite>current_</cite> (numpy.ndarray): A float array with shape (w, h) used for the transformation. It holds the current state of the ripple effect.
- <cite>texture_array_</cite> (numpy.ndarray): A uint8 array with shape (w, h, 3) containing the static background image in RGB format. This array is unchanged during the ripple transformation.
- <cite>background_array_</cite> (numpy.ndarray): A uint8 array with shape (w, h, 3) containing the background image in RGB format. This array is transformed by the ripple effect.
- <cite>dispersion_</cite> (float, optional): The ripple dampening factor, which controls the ripple effect’s intensity. Higher values reduce the ripple effect radius. The default value is 0.008.</p>
<p><strong>Returns</strong>:
- <cite>tuple</cite>: A tuple containing three arrays <cite>(current_, previous_, bck_array)</cite>. The arrays represent the updated states of the ripple effect and background deformation. See the Parameters section for the sizes of each array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatmap">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatmap" title="Link to this definition">¶</a></dt>
<dd><p>Transform an image into a heatmap equivalent (in-place).</p>
<p>This function modifies the given image surface to apply a heatmap effect.
The transformation is applied directly to the surface, so no new object
is returned. It also allows the user to choose whether the heatmap
should be in RGB or BGR color model.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, convert to an alpha surface, and apply heatmap</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A pygame.Surface object, typically in 24-bit or 32-bit image format (compatible with pygame). The image to which the heatmap effect will be applied.
- <cite>rgb_</cite> (bool, optional): If True, the image will be transformed into an RGB-based heatmap. If False, the transformation will use the BGR-based heatmap model. Default is True (RGB).</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: This function operates in-place, meaning the input surface is modified directly without returning a new object.</p>
<p><strong>Raises</strong>:
- <cite>TypeError</cite>: If <cite>surface_</cite> is not a valid pygame.Surface object.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.predator_vision">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">predator_vision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.predator_vision" title="Link to this definition">¶</a></dt>
<dd><p>Simulate Predator Vision Mode.</p>
<p>This function simulates the predator’s vision using a series of image processing
filters. It applies Sobel edge detection, bright pass filter (BPF), bloom effects,
and a colormap inversion to the given surface. Optionally, it allows for faster
processing and blending effects.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">predator_vision</span><span class="p">(</span>
   <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sobel_threshold</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
   <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inv_colormap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A pygame.Surface object, compatible with 24-bit or 32-bit formats. This is the image to which the predator vision effect will be applied.
- <cite>sobel_threshold</cite> (int, optional): The threshold for Sobel edge detection, used to detect edges in the image. The default value is 12.
- <cite>bpf_threshold</cite> (int, optional): The threshold for the Bright Pass Filter (BPF), used to detect and highlight bright pixels. The default value is 50.
- <cite>bloom_threshold</cite> (int, optional): The intensity of the bloom effect, which adds a glow around bright pixels. The default value is 50.
- <cite>inv_colormap</cite> (bool, optional): If True, the colormap will be inverted, changing the color scheme to resemble a predator’s vision more closely. The default value is False.
- <cite>fast</cite> (bool, optional): If True, a faster processing mode is used. This will reduce the quality in exchange for faster processing time. The default value is False.
- <cite>blend</cite> (int, optional): The blending mode to apply after all effects have been processed. This can be a value from <cite>pygame.BLEND_*</cite> modes. The default is <cite>pygame.BLEND_RGB_ADD</cite>.</p>
<p><strong>Returns</strong>:
- <cite>pygame.Surface</cite>: A new pygame.Surface object with the predator vision effect applied. The surface is in 24-bit format.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blood">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blood" title="Link to this definition">¶</a></dt>
<dd><p>Apply a blood effect (in-place).</p>
<p>This function applies a blood effect to a given surface using a mask array that defines
the contour of the blood effect. The surface and mask must have the same dimensions.
The <cite>percentage</cite> parameter determines the intensity of the blood effect, with 1.0 representing
full intensity.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/Aliens.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">RLEACCEL</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/redvignette.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">BLOOD_MASK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels_alpha</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Then call the method in your main loop (percentage must vary over time)</span>
<span class="n">blood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">BLOOD_MASK</span><span class="p">,</span> <span class="n">percentage</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): The surface (e.g., game display) to which the blood effect will be applied. It must be in a compatible 24-bit or 32-bit format.
- <cite>mask_</cite> (numpy.ndarray or cython.view.memoryview): A normalized array or memoryview (shape: (w, h), type: float) representing the blood mask. The values must be in the range [0.0, 1.0], where 1.0 represents full intensity of the effect.
- <cite>percentage_</cite> (float): A value in the range [0.0, 1.0] that determines the intensity of the blood effect. A value of 1.0 applies the full effect, while 0.0 applies no effect.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The function modifies the given surface in place (i.e., it has no return value).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring_array">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring_array" title="Link to this definition">¶</a></dt>
<dd><p>Return a mirrored numpy array.</p>
<p>This method returns a numpy.ndarray with mirrored pixels, flipping the image along the
horizontal axis. The output array has the same shape and type as the input, with the
pixel values mirrored.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rgb_array</span> <span class="o">=</span> <span class="n">mirroring_array</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">make_surface</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>rgb_array</cite> (numpy.ndarray): An array with shape (w, h, 3) of type uint8, containing RGB or any other pixel format (such as BGR).</p>
<p><strong>Returns</strong>:
- <cite>numpy.ndarray</cite>: A numpy ndarray with shape (w, h, 3) of type uint8, identical to the input array but with mirrored pixels.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring" title="Link to this definition">¶</a></dt>
<dd><p>Apply a mirroring effect (in-place).</p>
<p>This method creates a mirrored image of the given surface by reflecting it
horizontally. The effect is applied directly to the surface (in-place).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, apply the mirroring effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">mirroring</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A pygame surface compatible with 24-bit or 32-bit formats that will undergo the mirroring effect.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The function modifies the given surface in place, meaning it does not return a new surface but rather alters the input surface.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen" title="Link to this definition">¶</a></dt>
<dd><p>Sharpen an image (in-place) using a 3x3 kernel.</p>
<p>This function applies a sharpening filter to the image on the given surface.
The filter uses a 3x3 kernel to enhance the edges and details by increasing contrast
around edges, making the image appear sharper.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image and apply the sharpen effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sharpen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): A Pygame surface compatible with 24-bit or 32-bit image formats
that will be modified in-place to apply the sharpen effect.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>None</cite>: The function modifies the given surface in place, meaning no new surface is returned.
The original surface will be sharpened.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d" title="Link to this definition">¶</a></dt>
<dd><p>Sharpen array (in-place) using a 3x3 kernel.</p>
<p>This function applies a sharpening filter directly to a 1D array using a 3x3 kernel.
It is compatible with BGR or BGR(A) array types, and can also work with other pixel formats
such as RGB or RGB(A). The sharpening filter enhances the edges by increasing contrast around
them, making the image appear sharper. If the array contains alpha transparency, set <cite>format_32=True</cite>.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>w</cite> (int): The width of the array.
- <cite>h</cite> (int): The height of the array.
- <cite>bgr_array</cite> (numpy.ndarray): A 1D array (shape: (w, )) of type uint8, containing the BGR or RGB pixel values.
- <cite>format_32</cite> (bool, optional): If <cite>True</cite>, the array contains alpha transparency (BGRA format). If <cite>False</cite>, the array is BGR format (default is <cite>False</cite>).</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The function modifies the given array in place (i.e., no new array is returned).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Sharpen array (return a new array).</p>
<p>This function returns a new array with a sharpening filter applied, using a 3x3 kernel.
It is compatible with BGR or BGR(A) array types, and can also work with other pixel formats
such as RGB or RGB(A). The sharpening filter enhances edges by increasing contrast around
them, making the image appear sharper. If the array contains alpha transparency, set <cite>format_32=True</cite>.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>w</cite> (int): The width of the array.
- <cite>h</cite> (int): The height of the array.
- <cite>bgr_array</cite> (numpy.ndarray): A 1D array (shape: (w, )) of type uint8, containing the BGR or RGB pixel values.
- <cite>format_32</cite> (bool, optional): If <cite>True</cite>, the array contains alpha transparency (BGRA format). If <cite>False</cite>, the array is BGR format (default is <cite>False</cite>).</p>
<p><strong>Returns</strong>:
- <cite>numpy.ndarray</cite>: A 1D numpy array (shape: (w, )) of type uint8, with sharpened pixels similar to the input array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen32" title="Link to this definition">¶</a></dt>
<dd><p>Sharpen image using a 3x3 kernel (in-place).</p>
<p>This function applies a sharpening filter directly to the image on the given surface.
The filter uses a 3x3 kernel to enhance edges and details by increasing contrast around
edges, making the image appear sharper. It is compatible with both 24-bit and 32-bit images.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit images</span>
<span class="n">sharpen32</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A Pygame surface compatible with 24-bit or 32-bit formats to be sharpened.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The function modifies the given surface in place (i.e., no new surface is returned).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dirt_lens">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dirt_lens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lens_model_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">light_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dirt_lens" title="Link to this definition">¶</a></dt>
<dd><p>Dirt lens effect (in-place).</p>
<p>This function applies a dirt lens texture on top of the game display to simulate a camera artifact or
realistic camera effect, particularly when light from the scene is oriented directly toward the camera.
The function blends the lens texture with the display, creating a dirt effect on the lens.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dirt_lens</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lens_model</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">,</span> <span class="n">light_</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): The surface (display or game screen) that will be modified by the dirt lens effect. It must be in a 24-bit or 32-bit format.
- <cite>lens_model_</cite> (pygame.Surface): The lens model texture (e.g., dirt lens) to be applied to the surface. You can choose from various lens textures provided in the Assets directory. These textures must be resized to fit the display dimensions.
- <cite>flag_</cite> (int, optional): The blending flag to apply to the lens texture. Default is <cite>pygame.BLEND_RGB_ADD</cite>, which adds the lens texture on top of the surface. You can use other Pygame blending flags like <cite>BLEND_RGB_MAX</cite>, etc.
- <cite>light_</cite> (float, optional): A float value between -1.0 and 0.2 that adjusts the brightness of the lens texture. Values less than 0 will reduce the lens effect, while values greater than 0 will brighten the display and increase the dirt lens effect. Default is 0.0.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: This function modifies the input surface in-place and does not return a new object.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering" title="Link to this definition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (copy).</p>
<p>This function applies the Floyd-Steinberg dithering algorithm to a Pygame surface to create the illusion
of color depth in images with a limited color palette. Dithering approximates colors that are not available
in the palette by diffusing colored pixels from within the available palette. The result is a dithered image
with a characteristic graininess or speckled appearance.</p>
<p>The input image is converted from a Pygame surface to a 3D array (w, h, 3) with a float data type. As the image
is converted to a different data type (from <cite>uint8</cite> to <cite>float32</cite>), the transformation is not applied in place,
and a copy of the original image (without the alpha channel) is returned.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A Pygame surface object in 24-bit or 32-bit format. The surface to be dithered.</p>
<p><strong>Returns</strong>:
- <cite>pygame.Surface</cite>: A new Pygame surface in 24-bit format (without the alpha channel) representing the dithered version of the input image.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (inplace).</p>
<p>This function applies the Floyd-Steinberg dithering algorithm to a Pygame surface to create the illusion
of color depth in images with a limited color palette. Dithering approximates colors that are not available
in the palette by diffusing colored pixels from within the available palette. The result is a dithered image
with a characteristic graininess or speckled appearance. Unlike the non-inplace version, this function modifies
the image surface in place.</p>
<p>The input image is converted from a Pygame surface to a 3D array (w, h, 3) with a float data type. The image is
modified directly, and no new object is returned.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A Pygame surface object in 24-bit or 32-bit format. The surface to be dithered.</p>
<p><strong>Returns</strong>:
- <cite>None</cite>: The input surface is modified in place (i.e., no new surface is returned).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d" title="Link to this definition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (inplace) on a 1D array.</p>
<p>This function applies the Floyd-Steinberg dithering algorithm to a 1D array, simulating the illusion of
color depth in images with a limited color palette. Dithering approximates colors that are not available
in the palette by diffusing colored pixels from within the available palette. The result is a dithered image
with a characteristic graininess or speckled appearance. This function modifies the input array in place.</p>
<p>The dithering process can handle both 24-bit and 32-bit images, with the <cite>format_32</cite> flag indicating whether
the input is a 32-bit image (with transparency) or a 24-bit image.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): The width of the image array.</p></li>
<li><p><cite>h</cite> (int): The height of the image array.</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray): A 1D array with shape <cite>(w, h, 3)</cite> for 24-bit images (BGR) or <cite>(w, h, 4)</cite> for
32-bit images (BGRA).</p></li>
<li><p><cite>format_32</cite> (bool, optional): A flag indicating the image format. Set to <cite>True</cite> for 32-bit (BGRA) images,
or <cite>False</cite> for 24-bit (BGR) images. The default is <cite>False</cite>.</p></li>
</ul>
<p><strong>Returns</strong>:
- <cite>None</cite>: This function modifies the input array in place (i.e., no new array is returned).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (copy) on a 1D array.</p>
<p>This function applies the Floyd-Steinberg dithering algorithm to a 1D array, simulating the illusion of
color depth in images with a limited color palette. Dithering approximates colors that are not available
in the palette by diffusing colored pixels from within the available palette. The result is a dithered image
with a characteristic graininess or speckled appearance. Unlike <cite>dithering1d</cite>, this function returns a new array
with the dithering effect applied, rather than modifying the array in place.</p>
<p>The dithering process can handle both 24-bit and 32-bit images. The <cite>format_32</cite> flag indicates whether the input
is a 32-bit image (with transparency) or a 24-bit image.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>

<span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): The width of the image array.</p></li>
<li><p><cite>h</cite> (int): The height of the image array.</p></li>
<li><p><cite>rgb_array</cite> (numpy.ndarray): A 1D array with shape <cite>(w, h, 3)</cite> for 24-bit images (RGB) or <cite>(w, h, 4)</cite> for
32-bit images (RGBA).</p></li>
<li><p><cite>format_32</cite> (bool, optional): A flag indicating the image format. Set to <cite>True</cite> for 32-bit (RGBA) images,
or <cite>False</cite> for 24-bit (RGB) images. The default is <cite>False</cite>.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>numpy.ndarray</cite>: A new 1D array with the dithering effect applied. The array shape is <cite>(w, h, 3)</cite> for 24-bit
images or <cite>(w, h, 4)</cite> for 32-bit images.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson" title="Link to this definition">¶</a></dt>
<dd><p>Dithering Atkinson (copy)</p>
<p>Atkinson dithering is a variant of Floyd–Steinberg dithering, developed by Bill Atkinson at Apple Computer
and used in the original Macintosh computer. This dithering technique is used to create the illusion of “color
depth” in images with a limited color palette, also known as color quantization. Colors that are not available in
the palette are approximated by diffusing colored pixels from within the available palette. The human eye perceives
this diffusion as a mixture of the colors, often resulting in a characteristic grainy or speckled appearance.</p>
<p>This function applies Atkinson dithering to an image represented by a Pygame surface. The image is converted to
a 3D array format with the shape <cite>(w, h, 3)</cite> and type <cite>float32</cite> (single precision). Since the image is converted
to a different data type (from <cite>uint8</cite> to <cite>float32</cite>), the transformation cannot be applied in place.</p>
<p>The function returns a new image with the dithering effect applied.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering_atkinson</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>  <span class="c1"># for 24 or 32-bit image format</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): A Pygame surface in 24-bit or 32-bit format that will undergo Atkinson dithering.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new Pygame surface in 24-bit format with the dithering effect applied (without the alpha channel).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson1d" title="Link to this definition">¶</a></dt>
<dd><p>Atkinson Dithering for 1D Array (inplace)</p>
<p>Atkinson dithering is a variant of Floyd–Steinberg dithering, developed by Bill Atkinson at Apple Computer,
and used in the original Macintosh computer. This dithering technique is employed to create the illusion of
“color depth” in images with a limited color palette, a process also known as color quantization. In a dithered
image, colors not available in the palette are approximated by diffusing colored pixels from within the available
palette. The human eye perceives this diffusion as a mixture of colors, often leading to a characteristic grainy
or speckled appearance.</p>
<p>This function applies Atkinson dithering to an image represented by a 1D array in memory. It operates directly
on the array (in-place), modifying the pixel values to achieve the dithering effect.</p>
<p>The function is compatible with both 24-bit and 32-bit images. If the dithering process is not applied to the image,
check the <cite>format_32</cite> flag. The flag should be set to <cite>True</cite> for images containing per-pixel transparency or
equivalent array shapes (w, h, 4). For 24-bit images, set <cite>format_32</cite> to <cite>False</cite> (array shape (w, h, 3)).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): The width of the array.</p></li>
<li><p><cite>h</cite> (int): The height of the array.</p></li>
<li><p><cite>c_buffer</cite> (C-Buffer or memoryviewslice or 1d numpy.ndarray): The 1D array or memory view containing BGR pixels or any other pixel format (datatype uint8).</p></li>
<li><p><cite>format_32</cite> (bool, optional):
- <cite>True</cite> if the array represents a 32-bit image (BGRA format with transparency).
- <cite>False</cite> for a 24-bit image (BGR format). The default is <cite>False</cite>.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>None</cite>: This function modifies the array in place. It does not return a new array.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixelation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocksize_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixelation" title="Link to this definition">¶</a></dt>
<dd><p>Pixelate a Pygame Surface</p>
<p>Pixelation in computer graphics refers to the effect caused by displaying a bitmap or a section of a bitmap at
such a large size that individual pixels become visible. When applied to an image, pixelation reduces the resolution
of the image by increasing the size of individual pixels, creating a blocky, pixelated appearance.</p>
<p>This function pixelates a Pygame surface by dividing the image into square blocks, with each block representing the
average color of the pixels inside it. The block size is specified by the <cite>blocksize_</cite> parameter (default is 64).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">pix_image</span> <span class="o">=</span> <span class="n">pixelation</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): The Pygame surface to be pixelated.</p></li>
<li><p><cite>blocksize_</cite> (unsigned int, optional): The block size used for the pixelation process, default is 64.
This value determines the size of each pixelated block (e.g., 64x64 pixel blocks).</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new surface with the pixelation effect applied.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend" title="Link to this definition">¶</a></dt>
<dd><p>Alpha Blending</p>
<p>Blend two images together using alpha blending, where one image is overlaid on top of another with a specified
transparency level. The function allows you to blend the <cite>source</cite> image onto the <cite>destination</cite> image based on a
percentage value, where 0% means no blending and 100% means full blending of the source image over the destination.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">transition</span> <span class="o">=</span> <span class="n">blend</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">image1</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">image2</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface): The source image (compatible with 24 or 32-bit).</p></li>
<li><p><cite>destination</cite> (pygame.Surface): The destination image (compatible with 24 or 32-bit).</p></li>
<li><p><cite>percentage</cite> (float): The percentage value between 0.0 and 100.0 that determines the level of blending.
0.0 means the source image is completely transparent, and 100.0 means the source image completely replaces the
destination image.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new surface (24-bit) that represents the blended result of the <cite>source</cite> and <cite>destination</cite> images.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend1d" title="Link to this definition">¶</a></dt>
<dd><p>Alpha Blending (1D Array)</p>
<p>Blend two 1D image buffers together using alpha blending. This method allows you to blend two images by
providing the image buffers as the source and destination. The <cite>percentage</cite> argument allows you to control
how much of each image contributes to the final result. For example, if <cite>percentage</cite> is set to 25%,
the source image will contribute 25% while the destination image contributes 75%.</p>
<p>The <cite>modes</cite> argument specifies the pixel format of the source and destination buffers, which can either
be ‘RGB(X)’ or ‘BGR(X)’, where ‘X’ refers to the alpha channel if present. The <cite>format_32</cite> argument
should be set to <cite>True</cite> if the source and destination buffers contain alpha transparency (RGBA format).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit images with alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit images without alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): Width of the source array.</p></li>
<li><p><cite>h</cite> (int): Height of the source array.</p></li>
<li><p><cite>source</cite> (numpy.ndarray): 1D array of type uint8 representing the source image in RGB(A) or BGR(A) format.</p></li>
<li><p><cite>destination</cite> (numpy.ndarray): 1D array of type uint8 representing the destination image in the same format as <cite>source</cite>.</p></li>
<li><p><cite>percentage</cite> (float): Blending percentage value between 0 and 100. A value of 0 means only the destination image is visible, while 100 means only the source image is visible.</p></li>
<li><p><cite>modes</cite> (str): A string representing the pixel format of the source and destination arrays. Use ‘RGB(X)’ for RGB or RGBA format and ‘BGR(X)’ for BGR or BGRA format.</p></li>
<li><p><cite>format_32</cite> (bool): If <cite>True</cite>, the source and destination arrays contain alpha transparency (RGBA or BGRA format). Default is <cite>False</cite>.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new surface with the blended effect applied, which can be either 24-bit or 32-bit depending on the source and destination array formats.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Alpha Blending (Inplace)</p>
<p>This function blends the <cite>source</cite> image into the <cite>destination</cite> image, modifying the destination image directly.
The <cite>source</cite> and <cite>destination</cite> textures must be of the same size. The <cite>percentage</cite> argument controls how much of
each image contributes to the final result. For example, if the <cite>percentage</cite> is set to 25%, the source image will
contribute 25% while the destination image will contribute 75%.</p>
<p>The function is compatible with both 24-bit and 32-bit surfaces.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">blend_inplace</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>destination</cite> (pygame.Surface): The surface that will be modified, compatible with 24-bit or 32-bit surfaces.</p></li>
<li><p><cite>source</cite> (pygame.Surface): The surface to blend into the destination, compatible with 24-bit or 32-bit surfaces.</p></li>
<li><p><cite>percentage</cite> (float): A value between 0.0 and 100.0 indicating the blending percentage. A value of 0.0 means
no effect from the source, and 100.0 means the source completely replaces the destination.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: The operation is performed inplace, meaning the destination surface is modified directly.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.cartoon">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">cartoon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.cartoon" title="Link to this definition">¶</a></dt>
<dd><p>Apply a cartoon effect to an image.</p>
<p>This function applies a cartoon-like effect to a given surface. It utilizes a Sobel filter for edge detection
and combines it with median filtering and color reduction to create a simplified and stylized cartoon effect.
The function is compatible with both 24-bit and 32-bit images.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cartoon_image</span> <span class="o">=</span> <span class="n">cartoon</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): The surface to which the cartoon effect will be applied. It can be either 24-bit or 32-bit.</p></li>
<li><p><cite>sobel_threshold</cite> (unsigned int, optional): The Sobel filter threshold for edge detection. Default is 128.</p></li>
<li><p><cite>median_kernel</cite> (unsigned int, optional): The size of the kernel used for median filtering. Default is 2.</p></li>
<li><p><cite>color</cite> (unsigned int, optional): The maximum color reduction level (i.e., the number of colors in the image after reduction). Default is 8.</p></li>
<li><p><cite>flag</cite> (unsigned int, optional): The blend flag for blending the final cartoon image. Default is <cite>BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: The input surface with the cartoon effect applied.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.convert_27">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">convert_27</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.convert_27" title="Link to this definition">¶</a></dt>
<dd><p>Convert an image to a reduced color palette of 27 colors (inplace).</p>
<p>This function reduces the color depth of an image by applying an algorithm that converts it
to only 27 distinct colors. The operation is performed in place, meaning that the original
surface is modified directly.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">convert_27</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): The surface (image) that will be converted to a reduced
color palette. It is compatible with both 24-bit and 32-bit image formats.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: The function modifies the surface in place and does not return a new surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilateral">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilateral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilateral" title="Link to this definition">¶</a></dt>
<dd><p>Apply bilateral filtering to an image and return a filtered copy.</p>
<p>Bilateral filtering is a non-linear, edge-preserving, and noise-reducing
smoothing filter. It replaces the intensity of each pixel with a weighted
average of intensities from nearby pixels, with weights based on both
spatial proximity and intensity similarity. This allows the filter to blur
smooth regions while preserving sharp edges.</p>
<p>The filter relies on two key parameters:</p>
<ul class="simple">
<li><p><strong>sigma_s</strong>: Spatial extent of the kernel. It defines the size of the
neighborhood around each pixel that influences the filter’s operation.</p></li>
<li><p><strong>sigma_i</strong>: Intensity range kernel. This controls how sensitive the
filter is to intensity differences. A smaller value of <cite>sigma_i</cite> preserves
edges more effectively, while a larger value allows for more uniform blurring.</p></li>
</ul>
<p>As <cite>sigma_i</cite> increases, the filter approaches a Gaussian blur (which is
applied uniformly across the image). A smaller value of <cite>sigma_i</cite> retains
more local detail by reducing the contribution of pixels with different intensities.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>image</cite> (pygame.Surface): The surface (image) to which the bilateral
filter will be applied. The image must be in 24-32 bit RGB format,
and the alpha channel will be ignored. The image is converted into
a 3D array for processing.</p></li>
<li><p><cite>sigma_s</cite> (float): The spatial extent of the kernel. This parameter
controls the size of the neighborhood used to compute the weighted average.</p></li>
<li><p><cite>sigma_i</cite> (float): Intensity sensitivity. Defines the maximum intensity
difference that contributes to the blur. Smaller values will preserve edges.</p></li>
<li><p><cite>kernel_size</cite> (int, optional): The size of the kernel (default is 3).
This controls how far the filter reaches from each pixel.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new Pygame surface with the bilateral filter applied.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss" title="Link to this definition">¶</a></dt>
<dd><p>Apply an emboss filter to an image or surface, producing an embossed effect.</p>
<p>The embossing filter creates a visual effect that makes the image appear raised,
similar to a paper or metal embossing of the original image, which can be used
to highlight edges or create artistic effects.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): A Pygame surface compatible with 24-bit or 32-bit image formats.</p></li>
<li><p><cite>flag_</cite> (int, optional): A special Pygame blend flag (default is 0). This flag can be one of
the blend modes such as <cite>BLEND_RGB_ADD</cite>, <cite>BLEND_RGB_MULT</cite>, etc. It modifies the image blending
behavior and will affect the final output.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A surface containing the embossed image. If <cite>flag_</cite> is set to 0, the output
is a 24-bit format; otherwise, a 32-bit format is returned.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Emboss a surface (inplace)</p>
<p>This function applies an embossing filter to an image in-place, meaning the image itself is modified
rather than creating a new image. The embossing effect produces a raised, textured effect, similar to
paper or metal embossing. It can highlight edges and create artistic effects in the image.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): A Pygame surface that will be embossed. The surface will be modified
in place once the process is complete.</p></li>
<li><p><cite>copy</cite> (numpy.ndarray, optional): A numpy array with shape <cite>(w, h, 3)</cite> of type <cite>uint8</cite> containing
the RGB pixels. It must be the same size as the input surface. This array is used as a copy of the
source array to slightly improve performance.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: The surface is modified in place and no new surface is returned.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss1d" title="Link to this definition">¶</a></dt>
<dd><p>Emboss directly a C-buffer type (inplace)</p>
<p>This function applies an embossing filter to an image in-place, directly modifying the provided
C-buffer array (<cite>bgr_array</cite>). The embossing effect produces a raised texture, similar to paper or
metal embossing, making edges more prominent and creating artistic effects.</p>
<p>If the <cite>tmp_array</cite> is provided, it is used to improve performance, but it must have the same shape and size
as the source array (<cite>bgr_array</cite>).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): The width of the surface (image).</p></li>
<li><p><cite>h</cite> (int): The height of the surface (image).</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray or memoryviewslice): A 1D array of type <cite>uint8</cite> containing BGR pixel data
or any other pixel format. This array represents the source data that will be modified in place.</p></li>
<li><p><cite>tmp_array</cite> (numpy.ndarray or memoryviewslice, optional): A 1D array of type <cite>uint8</cite> containing BGR
pixel data or any other pixel format. This array should be a copy of the source array to improve performance.</p></li>
<li><p><cite>format_32</cite> (bool, default is False): Set to <cite>True</cite> if the source array contains alpha transparency
(32-bit format).</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: The function modifies the <cite>bgr_array</cite> in place and does not return a new array.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_gray">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_gray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_gray" title="Link to this definition">¶</a></dt>
<dd><p>Apply a gray-scale embossing filter to an image or surface and return a modified copy.</p>
<p>This function applies an embossing effect to the given image or surface in grayscale. The embossing effect
creates a raised texture that mimics paper or metal embossing. The result is a stylized effect where edges
and contours are emphasized, but in a monochromatic grayscale palette.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss_gray</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): The input surface (image) to which the gray-scale emboss effect will be applied.
This surface must be compatible with 24-bit or 32-bit formats.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new Pygame surface with the gray-scale embossed image. The resulting image is always in 24-bit format.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilinear">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilinear" title="Link to this definition">¶</a></dt>
<dd><p>Resize an image using the bilinear filter algorithm (returns a copy).</p>
<p>This function applies the bilinear filter to resize an image. Bilinear filtering smooths the image
and is commonly used in image resizing tasks. The function supports 32-bit input images, but the
result is always returned in 24-bit format (without the alpha channel).</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Resize image to 600x600</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Resize with specific scaling factors</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): The input surface (image) to be resized. It must be compatible with 24-bit or 32-bit formats.</p></li>
<li><p><cite>size_</cite> (tuple): A tuple <cite>(width, height)</cite> specifying the new dimensions for the resized surface.</p></li>
<li><p><cite>fx</cite> (float, optional): A scaling factor for the x-axis (width). If provided, it will override the width specified in <cite>size_</cite>. Default is None.</p></li>
<li><p><cite>fy</cite> (float, optional): A scaling factor for the y-axis (height). If provided, it will override the height specified in <cite>size_</cite>. Default is None.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A new Pygame surface of type 24-bit (without the alpha channel), resized based on the input parameters.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling24" title="Link to this definition">¶</a></dt>
<dd><p>24-bit Tunnel modeling
This method will produce 24-bit rendering data to simulate a tunnel effect.</p>
<p>The algorithm uses a 256x256 texture but reshapes it to 512x512 pixels for better rendering.
It generates a tunnel effect by manipulating distances, angles, shades, and rendering data.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling24</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int): The width of the display or the width of the tunnel effect.</p></li>
<li><p><cite>screen_height</cite> (int): The height of the display or the height of the tunnel effect.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface): The tunnel texture effect, compatible with 24-bit or 32-bit formats.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: A tuple containing four buffers:
- <cite>distances</cite>: Buffer containing distance data.
- <cite>angles</cite>: Buffer containing angle data.
- <cite>shades</cite>: Buffer containing shading data.
- <cite>scr_data</cite>: Buffer containing the screen rendering data.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render24" title="Link to this definition">¶</a></dt>
<dd><p>Tunnel effect rendering</p>
<p>This function renders the tunnel effect based on pre-calculated data, creating a 24-bit output surface.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render24</span><span class="p">(</span><span class="n">FRAME</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>t</cite> (int): Timer or frame count. Controls the speed of the tunnel effect.</p></li>
<li><p><cite>screen_width</cite> (int): The width of the display or tunnel effect.</p></li>
<li><p><cite>screen_height</cite> (int): The height of the display or tunnel effect.</p></li>
<li><p><cite>screen_w2</cite> (int): The screen width divided by 2.</p></li>
<li><p><cite>screen_h2</cite> (int): The screen height divided by 2.</p></li>
<li><p><cite>distances</cite> (numpy.ndarray): A 1D C-buffer containing the distances. This buffer is obtained from the <cite>tunnel_modeling24</cite> function.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray): A 1D C-buffer containing the angles. This buffer is obtained from the <cite>tunnel_modeling24</cite> function.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray): A 1D C-buffer containing the shades. This buffer is obtained from the <cite>tunnel_modeling24</cite> function.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray): A 1D C-buffer containing the background pixels. This buffer is obtained from the <cite>tunnel_modeling24</cite> function.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray): A 1D C-buffer, typically empty. It should have the same size as the output image (width * height * 4 for RGBA). This buffer is used to build the final texture effect.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A 24-bit surface with the rendered tunnel effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling32" title="Link to this definition">¶</a></dt>
<dd><p>Generate 32-bit Tunnel Modeling Effect.</p>
<p>This function simulates a tunnel effect and generates 32-bit rendering data based
on the provided surface texture. It uses a 256x256 texture, which is reshaped to
a 512x512 resolution for better rendering quality. The algorithm computes various
parameters such as distances, angles, shades, and rendering data, which can be
used to visualize the tunnel effect.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling32</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int): The width of the display or the tunnel effect.</p></li>
<li><p><cite>screen_height</cite> (int): The height of the display or the tunnel effect.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface): The texture surface used for the tunnel effect. The surface should be compatible with either 24 or 32-bit formats.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: A tuple containing four buffers:
- <cite>distances</cite>: A buffer representing the calculated distances for the effect.
- <cite>angles</cite>: A buffer representing the calculated angles for the effect.
- <cite>shades</cite>: A buffer representing the calculated shades (brightness) for the effect.
- <cite>scr_data</cite>: A buffer containing the texture data of the surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render32" title="Link to this definition">¶</a></dt>
<dd><p>Tunnel effect rendering.</p>
<p>This function renders the tunnel effect using 32-bit rendering data. It takes
the parameters calculated by the <cite>tunnel_modeling32</cite> function and applies them
to generate the final tunnel effect. The output is a 32-bit surface that can
be used in Pygame rendering.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render32</span><span class="p">(</span><span class="n">FRAME</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>t</cite> (int): The timer or frame count. This controls the speed of the effect.</p></li>
<li><p><cite>screen_width</cite> (int): The width of the display or the tunnel effect.</p></li>
<li><p><cite>screen_height</cite> (int): The height of the display or the tunnel effect.</p></li>
<li><p><cite>screen_w2</cite> (int): This is half the width of the screen (<cite>screen_width // 2</cite>).</p></li>
<li><p><cite>screen_h2</cite> (int): This is half the height of the screen (<cite>screen_height // 2</cite>).</p></li>
<li><p><cite>distances</cite> (numpy.ndarray): A C-buffer of distances, which is generated from the <cite>tunnel_modeling32</cite> function.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray): A C-buffer of angles, which is generated from the <cite>tunnel_modeling32</cite> function.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray): A C-buffer of shades (brightness), which is generated from the <cite>tunnel_modeling32</cite> function.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray): A C-buffer of background pixel data, which is generated from the <cite>tunnel_modeling32</cite> function.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray): An empty C-buffer, typically an empty buffer with a length of <cite>width * height * 4</cite> (RGBA). This buffer will be used to build the final tunnel effect image.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: A surface containing the 32-bit image of the rendered tunnel effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast" title="Link to this definition">¶</a></dt>
<dd><p>Applies a fast bloom effect to an input surface.</p>
<p>The bloom effect brightens pixels in the image above a specified threshold
and then applies a blur to create a glowing effect. This function performs a
series of downscaling operations and blurs, which are then combined to produce
the final bloom effect. The algorithm can be optimized for speed, trading
off some visual quality.</p>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">shader_bloom_fast</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface containing RGB pixel data (32-bit or 24-bit color format).</p></li>
<li><p><cite>threshold</cite> (int):
The brightness threshold for the bloom effect. Pixels with values above
this threshold will contribute to the bloom effect. A smaller value will
cause a stronger bloom.</p></li>
<li><p><cite>fast</cite> (bint, optional):
If True, the algorithm will prioritize speed over visual quality by only
applying the blur to the lowest downscaled surface (S16). Default is False.</p></li>
<li><p><cite>factor</cite> (int, optional):
A value between 0 and 4 that controls the level of downscaling for the
textures used in the bloom. Higher values result in more aggressive downscaling.
Default is 2, which corresponds to a division by 4.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>:
A Pygame surface with the bloom effect applied, in 24-bit color format.</p></li>
</ul>
<p><strong>Raises</strong>:</p>
<ul class="simple">
<li><p><cite>ValueError</cite>:
If the surface is too small to process (e.g., after downscaling).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast1">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast1" title="Link to this definition">¶</a></dt>
<dd><p>Bloom effect applied in-place (simplified version for better performance).</p>
<p>The <cite>shader_bloom_fast1</cite> function applies a bloom effect that is optimized for moving objects
in the display. Unlike other bloom methods, this version does not cause the light halo to be
offset from moving objects, as it avoids the downsampling technique. This makes it better suited
for dynamic scenes where objects are in motion.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface with compatible 32-bit or 24-bit color format (RGB).</p></li>
<li><p><cite>smooth_</cite> (int, optional):
The smooth factor for spreading the halo of light. The default value is 3.
Higher values spread the bloom over the entire scene but diminish the effect, while smaller values
create a more pixelated halo but intensify the effect on objects. If smooth is below 3, the halo
becomes pixelated.</p></li>
<li><p><cite>threshold_</cite> (int, optional):
The threshold for the bloom intensity. A threshold of 0 corresponds to the maximum bloom.
The default value is 0, meaning no threshold is applied.</p></li>
<li><p><cite>flag_</cite> (int, optional):
A Pygame blend flag for special blending effects with the light in the display.
The default is <cite>pygame.BLEND_RGB_ADD</cite>. Other options include <cite>BLEND_RGB_MAX</cite>, <cite>BLEND_RGB_SUB</cite>,
and other Pygame blend attributes.</p></li>
<li><p><cite>saturation_</cite> (bool, optional):
If True, the bloom effect will include a saturation effect to the halo. The default is False.</p></li>
<li><p><cite>mask_</cite> (numpy.ndarray or memoryviewslice, optional):
A numpy array or memoryview representing the mask alpha. It should have the shape (w, h) and type
<cite>float32</cite>, with values in the range (0..255). A mask filled with 255 will render and bloom the entire
image, while a mask filled with 0 will disable the bloom effect. Values between 0 and 255 create a
selective bloom effect. The mask is optional.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>:
This effect is applied in-place, modifying the input surface directly.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shader_bloom_fast1</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels" title="Link to this definition">¶</a></dt>
<dd><p>RGB split effect (returns a copy).</p>
<p>This function applies an RGB split effect to an image by shifting the channels based on the provided
offset. The result is an image with the red, green, and blue channels offset from their original positions.
The offset value controls the direction and magnitude of the shift.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface compatible with 24-bit or 32-bit color format (RGB). The input image on which the
RGB split effect will be applied.</p></li>
<li><p><cite>offset_</cite> (char):
An integer value that specifies the offset to apply between the RGB channels. The offset must be in the
range [-128, 127]. If the offset is positive, the channels are displayed in the BGR order. If the offset
is negative, the channels are displayed in the RGB order.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, optional):
A numpy array with the shape (w, h, 3) and type <cite>uint8</cite>. If provided, this array will speed up the process
by directly applying the transformation to it. This parameter is optional.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>:
A new surface (copy) with the RGB split effect applied, where the RGB channels are offset according to the
specified value.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">split_channels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels_inplace" title="Link to this definition">¶</a></dt>
<dd><p>RGB split effect (inplace).</p>
<p>This function applies an RGB split effect to an image directly, modifying the original image without
creating a new copy. The function shifts the red, green, and blue channels based on the provided offset
value, either rearranging the channels or applying the specified offset.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface compatible with 24-bit or 32-bit color format (RGB). The input image on which the
RGB split effect will be applied, and the changes will be applied directly to this surface.</p></li>
<li><p><cite>offset_</cite> (char):
An integer value that specifies the offset to apply between the RGB channels. The offset must be in the
range [-128, 127]. If the offset is positive, the channels are displayed in the BGR order. If the offset
is negative, the channels are displayed in the RGB order.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, optional):
A numpy array with the shape (w, h, 3) and type <cite>uint8</cite>. If provided, this array will be used to speed up
the process by directly applying the transformation to it. This parameter is optional.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>:
The changes are applied directly to the input surface, so no new surface is returned.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">split_channels_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wavelength2rgb">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wavelength2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wavelength2rgb" title="Link to this definition">¶</a></dt>
<dd><p>Convert a wavelength to RGB color.</p>
<p>This function maps a given wavelength (in nanometers) to an RGB color. The wavelength is interpreted
within the visible spectrum (380–750 nm), and the corresponding color is returned in the RGB color model.
The function optionally allows for gamma correction, which adjusts the color brightness.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int):
The wavelength of light in nanometers (nm), typically within the visible spectrum range of 380–750 nm.
The function uses this value to determine the corresponding color.</p></li>
<li><p><cite>gamma</cite> (float, optional):
A gamma correction factor applied to the color. The default value is <cite>1.0</cite>, meaning no correction is applied.
Values greater than <cite>1.0</cite> increase the brightness of the color, while values less than <cite>1.0</cite> darken it.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>:
A tuple of three integers representing the RGB components of the color, with each value in the range of 0 to 255.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns RGB values for orange (255, 137, 0)</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>

<span class="c1"># Returns RGB values for red with gamma correction</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">620</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.custom_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">custom_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.custom_map" title="Link to this definition">¶</a></dt>
<dd><p>Map a wavelength to a customized RGB color based on a user-defined wavelength domain.</p>
<p>Unlike the <cite>wavelength2rgb</cite> function that returns RGB values corresponding to a wavelength
within the standard visible spectrum (380–750 nm), this function allows the user to define
a customized wavelength domain and returns the corresponding RGB color for a wavelength in that domain.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int):
The wavelength of light in nanometers (nm). This value is mapped to the customized wavelength domain defined in <cite>color_array</cite>.</p></li>
<li><p><cite>color_array</cite> (numpy.ndarray):
A 1D array of integers representing the wavelength boundaries of different colors. The array should contain pairs of values for each color (e.g., [min, max] ranges for colors such as yellow, orange, red, etc.). These ranges define the domain in which the colors will be applied.</p></li>
<li><p><cite>gamma</cite> (float, optional):
A gamma correction factor applied to the resulting RGB color. The default value is <cite>1.0</cite>, which means no gamma correction. Values greater than <cite>1.0</cite> will brighten the color, while values less than <cite>1.0</cite> will darken it.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>:
A tuple containing the RGB values (0-255) for the color corresponding to the given wavelength within the customized domain.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a custom wavelength domain with different color gradients</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Violet not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Blue not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Green not used</span>
     <span class="mi">570</span><span class="p">,</span> <span class="mi">619</span><span class="p">,</span>   <span class="c1"># Yellow gradient from 2 to 619 nm</span>
     <span class="mi">620</span><span class="p">,</span> <span class="mi">650</span><span class="p">,</span>   <span class="c1"># Orange gradient from 620 to 650 nm</span>
     <span class="mi">651</span><span class="p">,</span> <span class="mi">660</span>    <span class="c1"># Red gradient from 651 to 660 nm</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Get RGB color for a wavelength of 600 nm</span>
<span class="n">rgb_color</span> <span class="o">=</span> <span class="n">custom_map</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

<span class="c1"># Generate a heatmap of colors for wavelengths from 380 nm to 799 nm</span>
<span class="n">heatmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">custom_map</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">20</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">380</span><span class="p">,</span> <span class="mi">800</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blue_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blue_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blue_map" title="Link to this definition">¶</a></dt>
<dd><p>Map a specific wavelength to a blue-toned RGB color.</p>
<p>This function takes a wavelength (in nanometers) and returns the corresponding RGB values
with a focus on generating a blue color. It uses a simple mapping based on the provided
wavelength and applies a gamma correction for more refined color adjustments.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int):
The wavelength of light in nanometers (nm). This value is mapped to the blue-toned RGB value.</p></li>
<li><p><cite>gamma</cite> (float, optional):
A gamma correction factor applied to the resulting RGB color. The default value is <cite>1.0</cite>, which means no gamma correction. Values greater than <cite>1.0</cite> will brighten the color, while values less than <cite>1.0</cite> will darken it.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>:
A tuple containing the RGB values (0-255) for the blue-toned color corresponding to the given wavelength.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the blue RGB color correspondi</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bluescale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bluescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bluescale" title="Link to this definition">¶</a></dt>
<dd><p>Apply a blue color filter to an image, transforming it into a blue-toned version.</p>
<p>This function uses the wavelength range from 450 to 495 nm, which corresponds to
blue light in the visible spectrum, to convert the image into various shades of blue.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
The Pygame surface (image) that will be transformed into blue shades.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>:
This function modifies the provided surface in place, so there is no return value.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transform an image into shades of blue</span>
<span class="n">bluescale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.red_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">red_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.red_map" title="Link to this definition">¶</a></dt>
<dd><p>Return the RGB components corresponding to a specific wavelength in the red spectrum.</p>
<p>This function maps a given wavelength (in nm) to the appropriate RGB values for
the red portion of the visible spectrum. It can be used to generate red-based
colors based on a given wavelength.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int):
The wavelength in nanometers (nm) for which the corresponding RGB values are calculated.</p></li>
<li><p><cite>gamma</cite> (float, optional):
A gamma correction value to adjust the brightness of the colors. The default is <cite>1.0</cite> (no correction).</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite> (int, int, int):
A tuple of RGB components as integers in the range (0 … 255), corresponding to the specified wavelength.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the RGB color for a wavelength of 610 nm (Red color)</span>
<span class="n">rgb</span> <span class="o">=</span> <span class="n">red_map</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.redscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">redscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.redscale" title="Link to this definition">¶</a></dt>
<dd><p>Apply a redscale effect to an image.</p>
<p>This algorithm maps the input image into shades of red by adjusting the
color channels according to wavelengths typically associated with the
red portion of the visible light spectrum, ranging from 620 to 750 nm.
The redscale effect retains the intensity variations of the red color while
reducing or removing the influence of other color channels.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface representing the image to be transformed into redscale.
The surface must contain valid RGB pixel data.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>:
This function modifies the input surface directly and does not return a new surface.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply redscale effect to an image</span>
<span class="n">redscale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dampening" title="Link to this definition">¶</a></dt>
<dd><p>Apply a dampening effect to a surface.</p>
<p>This effect simulates a gradual scaling or shrinking of the surface based on a
damped oscillation function. The length of the effect is determined by the product
of duration and frequency. The position of the surface is adjusted according to
its new size to maintain its centered position on the display.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface that is compatible with 24-32 bit color depth.</p></li>
<li><p><cite>frame</cite> (int):
The current frame number in the animation sequence. This should be incremented
with each frame update.</p></li>
<li><p><cite>display_width</cite> (int):
The width of the game display window.</p></li>
<li><p><cite>display_height</cite> (int):
The height of the game display window.</p></li>
<li><p><cite>amplitude</cite> (float, optional):
The amplitude of the dampening effect, which determines the maximum amount
of scaling. Default is 50.0.</p></li>
<li><p><cite>duration</cite> (int, optional):
The duration of the effect, which controls how long the effect lasts
in terms of frames. Default is 30.</p></li>
<li><p><cite>freq</cite> (float, optional):
The frequency of the dampening effect, which affects how fast the scaling
oscillates. A smaller value will make the effect last longer, while a larger
value shortens the effect. Default is 20.0.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><p>tuple:
A tuple containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>A new Pygame Surface with the dampening effect applied.</p></li>
<li><p>The x-coordinate of the new position of the surface (top-left corner).</p></li>
<li><p>The y-coordinate of the new position of the surface (top-left corner).</p></li>
</ul>
<p>The surface is centered in the display area.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply dampening effect to a surface</span>
<span class="n">surf</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">dampening</span><span class="p">(</span><span class="n">BCK</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.lateral_dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">lateral_dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.lateral_dampening" title="Link to this definition">¶</a></dt>
<dd><p>Apply lateral dampening effect to produce horizontal displacement.</p>
<p>This method calculates the lateral displacement (x-coordinate) based on a dampened
oscillation function. The displacement value oscillates between positive and negative
values, gradually decaying according to the amplitude, frequency, and duration parameters.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>frame</cite> (int):
The current frame number in the animation sequence. This value must be incremented
with each frame to produce smooth animation.</p></li>
<li><p><cite>amplitude</cite> (float, optional):
The amplitude of the lateral dampening effect. This value controls the maximum
displacement of the surface. A higher value results in larger horizontal movement.
Default is 50.0.</p></li>
<li><p><cite>duration</cite> (int, optional):
The total duration of the effect, in terms of frames. This defines how long the
oscillations will last. The default value is 30 frames.</p></li>
<li><p><cite>freq</cite> (float, optional):
The frequency of the dampening oscillation. This controls how fast the oscillations
occur. A lower value makes the effect take longer to complete (slower oscillation),
while a higher value speeds up the oscillation. Default is 20.0.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p>float:
The lateral displacement value (x) that can be used to shift the object horizontally
on the screen (e.g., when blitting an image). The value will oscillate within a
range determined by the amplitude.</p></li>
</ul>
<p><strong>Example usage</strong>:
.. code-block:: python</p>
<blockquote>
<div><p># Apply lateral dampening effect to a surface
tm = lateral_dampening(frame, amplitude=50.0, duration=35, freq=5.0)
SCREEN.blit(BCK, (tm, 0), special_flags=0)</p>
</div></blockquote>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The displacement follows a damped oscillation model, where the value decays
over time based on the frequency and duration parameters.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending" title="Link to this definition">¶</a></dt>
<dd><p>Perform alpha blending of two 32-bit images.</p>
<p>This function blends two 32-bit images together, taking into account their
alpha channels (transparency). The <cite>source</cite> image is drawn on top of the
<cite>destination</cite> image. The blending uses the alpha channel to determine how
transparent each pixel is in the source image.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface):
The source image to be blended with the destination image. It must be a
32-bit image with an alpha channel.</p></li>
<li><p><cite>destination</cite> (pygame.Surface):
The destination image onto which the source image will be blended. It
must also be a 32-bit image with an alpha channel.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p>pygame.Surface:
A new 32-bit Pygame surface with the two images blended together, based
on their alpha values.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together using alpha blending</span>
<span class="n">new_image</span> <span class="o">=</span> <span class="n">alpha_blending</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>This function returns a new surface and does not modify the original <cite>source</cite> or <cite>destination</cite> images.</p></li>
<li><p>Both images must have an alpha channel to ensure proper blending of transparency.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Perform alpha blending on two images in-place.</p>
<p>This function blends two images with the same dimensions together, modifying
the first image (<cite>image1</cite>). The blending is performed based on the alpha channel,
where the second image (<cite>image2</cite>) is blended into the first image.</p>
<p>Both images must be 32-bit with an alpha channel and should have the same dimensions.
The blending process uses the alpha values of both images to calculate the transparency
of the pixels.</p>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>image1</cite> (pygame.Surface):
The first image to be blended with the second image. It must be a 32-bit
image with an alpha channel. This image is modified in place.</p></li>
<li><p><cite>image2</cite> (pygame.Surface):
The second image to be blended into the first image. It must also be a 32-bit
image with an alpha channel.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p>None:
This function modifies the first image (<cite>image1</cite>) in place and does not return a new surface.</p></li>
</ul>
<p><strong>Example usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together in-place</span>
<span class="n">alpha_blending_inplace</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>This function performs blending in place, modifying the <cite>image1</cite> surface.</p></li>
<li><p>Both <cite>image1</cite> and <cite>image2</cite> must have the same dimensions and include an alpha channel.</p></li>
<li><p>If either of the images does not have an alpha channel or have mismatched dimensions,
an exception will be raised.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.render_light_effect24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">render_light_effect24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">110</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.render_light_effect24" title="Link to this definition">¶</a></dt>
<dd><p>Generates a realistic lighting effect on a Pygame surface or texture.</p>
<p>This function simulates a light effect that can be blended onto a surface
using additive blending (<cite>BLEND_RGBA_ADD</cite> in Pygame). The effect is generated
based on a mask texture and can include optional enhancements such as bloom,
heat waves, and saturation adjustments.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">render_light_effect24</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">background_rgb</span><span class="p">,</span>
    <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
    <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
    <span class="n">heat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">frequency</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>x</cite> (int):
The X-coordinate of the light source. It must be within the screen width.</p></li>
<li><p><cite>y</cite> (int):
The Y-coordinate of the light source. It must be within the screen height.</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, shape (w, h, 3), dtype uint8):
A 3D NumPy array representing the RGB values of the background surface.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, shape (w, h), dtype uint8):
A 2D NumPy array containing the alpha (transparency) values of the light mask.
Using a radial gradient mask with maximum intensity at the center is recommended.</p></li>
<li><p><cite>intensity</cite> (float, optional, default=1.0):
Light intensity in the range [0.0, 20.0]. Higher values produce a stronger effect.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, optional, default=[128.0, 128.0, 128.0]):
A 3-element NumPy array representing the RGB color of the light in float format
(values in the range [0.0, 255.0]).</p></li>
<li><p><cite>smooth</cite> (bool, optional, default=False):
If <cite>True</cite>, applies a blur effect to smooth the lighting.</p></li>
<li><p><cite>saturation</cite> (bool, optional, default=False):
If <cite>True</cite>, applies a saturation effect to enhance color vibrancy.</p></li>
<li><p><cite>sat_value</cite> (float, optional, default=0.2):
Adjusts the saturation level. The valid range is [-1.0, 1.0].</p></li>
<li><p><cite>bloom</cite> (bool, optional, default=False):
If <cite>True</cite>, enables a bloom effect, which enhances the brightness of intense areas.</p></li>
<li><p><cite>threshold</cite> (int, optional, default=110):
The brightness threshold used in the bloom effect. Pixels above this value
contribute to the bloom.</p></li>
<li><p><cite>heat</cite> (bool, optional, default=False):
If <cite>True</cite>, applies a heat wave effect that distorts the lighting dynamically.</p></li>
<li><p><cite>frequency</cite> (float, optional, default=1):
Determines the frequency of the heat wave effect. Must be an increasing value.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul>
<li><p><cite>tuple</cite>:
A tuple containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>A 24-bit Pygame surface representing the generated light effect.</p></li>
<li><p>The surface width (<cite>sw</cite>).</p></li>
<li><p>The surface height (<cite>sh</cite>).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The output surface does not contain per-pixel alpha information.</p></li>
<li><p>Use <cite>BLEND_RGBA_ADD</cite> when blitting the surface to achieve an additive lighting effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom_effect_array24_c2">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom_effect_array24_c2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom_effect_array24_c2" title="Link to this definition">¶</a></dt>
<dd><p>Create a bloom effect on a Pygame surface (compatible 24-bit surface).</p>
<p><strong>Definition</strong>:</p>
<p>Bloom is a computer graphics effect used in video games, demos, and high dynamic range rendering
to reproduce an imaging artifact of real-world cameras. The effect simulates the bright areas of an image
glowing and spreading to adjacent areas, enhancing the lighting and visual quality of the scene.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/alpha.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="c1"># In the main loop</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bloom_effect_array24_c2</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A Pygame surface in 24-bit format on which the bloom effect will be applied.</p></li>
<li><p><cite>threshold_</cite> (unsigned char):
Threshold value used by the bright pass algorithm. Default is 128, and it determines which pixels are considered
“bright enough” to contribute to the bloom effect.</p></li>
<li><p><cite>smooth_</cite> (int, optional, default=1):
The number of Gaussian blur (5x5) iterations to apply to downscaled images. Increasing this value will
create a stronger smoothing effect.</p></li>
<li><p><cite>mask_</cite> (pygame.Surface, optional, default=None):
A Pygame surface representing the mask alpha. The alpha values in this mask determine how much of the
surface should be affected by the bloom effect. Alpha values of 255 will fully render and bloom the image,
while zero will hide the corresponding pixels.</p></li>
<li><p><cite>fast_</cite> (bool, optional, default=False):
If <cite>True</cite>, speeds up the bloom process by using a 16x surface and an optimized bright pass filter,
which involves downscaling the texture size by a factor of 4 before processing.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>:
A new Pygame surface with the applied bloom effect (24-bit surface).</p></li>
</ul>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The function applies a bloom effect by first performing a bright pass on the image, then applying
Gaussian blur and blending the result with the original surface.</p></li>
<li><p>The <cite>mask_</cite> parameter can be used to control which parts of the image will bloom based on the alpha values.</p></li>
<li><p>The <cite>fast_</cite> parameter allows for a quicker, albeit lower-quality, version of the bloom effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.area24_cc">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">area24_cc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.area24_cc" title="Link to this definition">¶</a></dt>
<dd><p>Generates a realistic lighting effect on a Pygame surface or texture.</p>
<p>This function simulates a light effect that can be blended onto a surface using additive blending (<cite>BLEND_RGBA_ADD</cite> in Pygame). It supports optional enhancements such as bloom, smoothing, and saturation adjustments.</p>
<p><strong>Lighting Modes</strong>:
–
- <strong>Smooth</strong>: Applies a Gaussian blur with a 5x5 kernel to soften the lighting effect.
- <strong>Saturation</strong>: Adjusts color intensity using HSL color conversion. A value range of [-1.0, 1.0] is supported, with higher values increasing vibrancy and values below zero desaturating the output.
- <strong>Bloom</strong>: Enhances brightness by applying a bloom effect, making bright areas appear more intense.</p>
<p><strong>Lighting Parameters</strong>:
-
- <strong>Intensity</strong>: Defines the brightness of the light. If set to zero, the function returns an empty <cite>pygame.Surface</cite> with the <cite>RLEACCEL</cite> flag.
- <strong>Color</strong>: Specifies the light’s RGB coloration. Defaults to (128, 128, 128).</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">area24_cc</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">background_rgb</span><span class="p">,</span> <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>x</cite> (int):
X-coordinate of the light source (must be within screen width).</p></li>
<li><p><cite>y</cite> (int):
Y-coordinate of the light source (must be within screen height).</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, shape (w, h, 3), dtype uint8):
A 3D NumPy array representing the RGB values of the background surface.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, shape (w, h), dtype uint8):
A 2D NumPy array containing the alpha values of the light mask. Using a radial gradient mask with maximum intensity at the center is recommended.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, optional, default=[128.0, 128.0, 128.0]):
A 3-element NumPy array representing the RGB color of the light in float format (values in the range [0.0, 255.0]).</p></li>
<li><p><cite>intensity</cite> (float, optional, default=1.0):
Light intensity in the range [0.0, 20.0]. Higher values produce a stronger effect.</p></li>
<li><p><cite>smooth</cite> (bool, optional, default=False):
If <cite>True</cite>, applies a blur effect to soften the lighting.</p></li>
<li><p><cite>saturation</cite> (bool, optional, default=False):
If <cite>True</cite>, increases color intensity using HSL conversion.</p></li>
<li><p><cite>sat_value</cite> (float, optional, default=0.2):
Adjusts the saturation level. The valid range is [-1.0, 1.0]. Higher values increase vibrancy, while negative values desaturate the effect.</p></li>
<li><p><cite>bloom</cite> (bool, optional, default=False):
If <cite>True</cite>, enables a bloom effect, enhancing brightness.</p></li>
<li><p><cite>bloom_threshold</cite> (unsigned char, optional, default=64):
The brightness threshold for the bloom effect, in the range [0, 255]. Lower values create a stronger bloom effect.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>tuple:</dt><dd><p>A tuple containing:
- A 24-bit Pygame surface representing the generated light effect.
- The surface width (<cite>sw</cite>).
- The surface height (<cite>sh</cite>).</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The output surface does not contain per-pixel alpha information.</p></li>
<li><p>Use <cite>BLEND_RGBA_ADD</cite> when blitting the surface to achieve an additive lighting effect.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic" title="Link to this definition">¶</a></dt>
<dd><p>Chromatic aberration (returns a new surface).</p>
<p>This function applies a chromatic aberration effect to a given surface. The amplitude of the effect is proportional to the distance from the center of the effect, creating a distortion of the RGB color channels. The chromatic aberration effect simulates the color shift that occurs due to optical imperfections in lenses.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">chromatic</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A 24-bit or 32-bit compatible Pygame surface to which the chromatic aberration effect will be applied.</p></li>
<li><p><cite>delta_x</cite> (unsigned int):
The X-coordinate of the chromatic center effect. This value must be within the range [0, surface width].</p></li>
<li><p><cite>delta_y</cite> (unsigned int):
The Y-coordinate of the chromatic center effect. This value must be within the range [0, surface height].</p></li>
<li><p><cite>zoom</cite> (float, optional, default=0.9999):
The zoom factor for the effect. A value of 0.9999 means no zoom (full image), while a value less than 1.0 will zoom in. It must be in the range [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, optional, default=0.02):
The offset applied to the RGB channels. This value determines the intensity of the chromatic aberration effect and must be in the range [0.0, 0.2].</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>A new Pygame surface with the chromatic aberration effect applied.</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The function returns a new surface with the chromatic aberration effect applied.</p></li>
<li><p>The <cite>delta_x</cite> and <cite>delta_y</cite> parameters define the point at which the chromatic effect is centered, and the distortion becomes more pronounced as the distance from this point increases.</p></li>
<li><p>The <cite>zoom</cite> and <cite>fx</cite> parameters control the extent and intensity of the effect, respectively.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Chromatic aberration (inplace).</p>
<p>This function applies a chromatic aberration effect to a given surface in place. The amplitude of the effect is proportional to the distance from the center of the effect. Unlike the <cite>chromatic</cite> function, this function modifies the original surface rather than returning a new surface. It simulates the optical effect of color distortion typically observed due to lens imperfections.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">chromatic_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
A 24-bit or 32-bit compatible Pygame surface to which the chromatic aberration effect will be applied in place.</p></li>
<li><p><cite>delta_x</cite> (unsigned int):
The X-coordinate of the chromatic center effect. This value must be within the range [0, surface width].</p></li>
<li><p><cite>delta_y</cite> (unsigned int):
The Y-coordinate of the chromatic center effect. This value must be within the range [0, surface height].</p></li>
<li><p><cite>zoom</cite> (float, optional, default=0.9999):
The zoom factor for the effect. A value of 0.9999 means no zoom (full image), while a value less than 1.0 will zoom in. It must be in the range [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, optional, default=0.02):
The offset applied to the RGB channels. This value determines the intensity of the chromatic aberration effect and must be in the range [0.0, 0.2].</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>The same Pygame surface with the chromatic aberration effect applied in place.</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The function modifies the original surface rather than returning a new one.</p></li>
<li><p>The <cite>delta_x</cite> and <cite>delta_y</cite> parameters define the point at which the chromatic effect is centered. The effect becomes more pronounced the farther away the pixel is from this center point.</p></li>
<li><p>The <cite>zoom</cite> and <cite>fx</cite> parameters control the extent and intensity of the chromatic aberration effect.</p></li>
<li><p>This function is useful when you want to apply the chromatic aberration effect directly to a surface without needing to create a new surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom" title="Link to this definition">¶</a></dt>
<dd><p>Zoom within an image (return a copy).</p>
<p>This function zooms in or zooms out on an image toward a given center point (delta_x, delta_y) using a specified zoom factor (zx). The function supports 24-bit and 32-bit image formats, and the output image will have the same format as the input. The zoom effect is more performant on 24-bit images.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
The Pygame surface to apply the zoom effect on. This can be a 24-bit or 32-bit compatible surface.</p></li>
<li><p><cite>delta_x</cite> (unsigned int):
The X-coordinate of the zoom center. This value must be within the range [0, surface width].</p></li>
<li><p><cite>delta_y</cite> (unsigned int):
The Y-coordinate of the zoom center. This value must be within the range [0, surface height].</p></li>
<li><p><cite>zx</cite> (float, optional, default=0.9999):
The zoom factor. This value must be in the range (0.0, 1.0). A value of 1.0 will result in no zoom (full image), while values closer to 0.0 zoom in. The zoom intensity is attenuated around 1.0, with the maximum zoom effect occurring as zx approaches 0.0.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>A new Pygame surface with the zoom effect applied. The output image will have the same format (24-bit or 32-bit) as the input image.</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The zoom effect centers around the point specified by <cite>delta_x</cite> and <cite>delta_y</cite>. The pixels closer to this center will appear less zoomed, while those farther away will experience more pronounced zooming.</p></li>
<li><p>This function returns a new surface with the zoom effect applied, leaving the original surface unchanged.</p></li>
<li><p>Performance is generally better with 24-bit images due to fewer data channels to process.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Zoom within an image (inplace).</p>
<p>This function zooms in or zooms out on an image toward a given center point (delta_x, delta_y) using a specified zoom factor (zx), modifying the image in place. The function supports 24-bit and 32-bit image formats, and the input image format remains unchanged during the process.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">zoom_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
The Pygame surface to apply the zoom effect on. This can be a 24-bit or 32-bit compatible surface.</p></li>
<li><p><cite>delta_x</cite> (unsigned int):
The X-coordinate of the zoom center. This value must be within the range [0, surface width].</p></li>
<li><p><cite>delta_y</cite> (unsigned int):
The Y-coordinate of the zoom center. This value must be within the range [0, surface height].</p></li>
<li><p><cite>zx</cite> (float, optional, default=0.9999):
The zoom factor. This value must be in the range (0.0, 1.0). A value of 1.0 will result in no zoom (full image), while values closer to 0.0 zoom in. The zoom effect is attenuated around 1.0, with the maximum zoom effect occurring as zx approaches 0.0.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>None:</dt><dd><p>This function modifies the <cite>surface_</cite> in place. It does not return a new surface.</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The zoom effect centers around the point specified by <cite>delta_x</cite> and <cite>delta_y</cite>. The pixels closer to this center will appear less zoomed, while those farther away will experience more pronounced zooming.</p></li>
<li><p>This function modifies the input surface directly, without creating a new one.</p></li>
<li><p>Performance is generally better with 24-bit images due to fewer data channels to process.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.Luma_GreyScale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">Luma_GreyScale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.Luma_GreyScale" title="Link to this definition">¶</a></dt>
<dd><p>Convert image into greyscale using YIQ (luma information).</p>
<p>This function converts the provided image into a greyscale image by utilizing the YIQ color model, which focuses on the luma (brightness) information. The function modifies the input image in place.</p>
<p><strong>Example Usage</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Luma_GreyScale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface):
The Pygame surface to convert into greyscale. This surface can be in any color format supported by Pygame.</p></li>
</ul>
<p><strong>Returns</strong>:</p>
<dl class="simple">
<dt>None:</dt><dd><p>The function modifies the input <cite>surface_</cite> in place, converting it to greyscale. It does not return a new surface.</p>
</dd>
</dl>
<p><strong>Notes</strong>:</p>
<ul class="simple">
<li><p>The conversion uses the YIQ color model, specifically the luma (Y) component, which represents the brightness of the image.</p></li>
<li><p>The input surface is modified directly, and no new surface is returned.</p></li>
</ul>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader</a><ul>
<li><a class="reference internal" href="#high-performance-image-processing-library">1. High-Performance Image Processing Library</a></li>
<li><a class="reference internal" href="#key-features">2. Key Features</a></li>
<li><a class="reference internal" href="#library-functional-overview">3. Library Functional Overview</a></li>
<li><a class="reference internal" href="#target-applications">4. Target Applications</a></li>
<li><a class="reference internal" href="#summary">5. Summary</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Cython list methods</a><ul>
<li><a class="reference internal" href="#Shader.bgr"><code class="docutils literal notranslate"><span class="pre">bgr()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_copy"><code class="docutils literal notranslate"><span class="pre">bgr_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_3d"><code class="docutils literal notranslate"><span class="pre">bgr_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d"><code class="docutils literal notranslate"><span class="pre">bgr_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d_cp"><code class="docutils literal notranslate"><span class="pre">bgr_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg"><code class="docutils literal notranslate"><span class="pre">brg()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_copy"><code class="docutils literal notranslate"><span class="pre">brg_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_3d"><code class="docutils literal notranslate"><span class="pre">brg_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d"><code class="docutils literal notranslate"><span class="pre">brg_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d_cp"><code class="docutils literal notranslate"><span class="pre">brg_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey"><code class="docutils literal notranslate"><span class="pre">grey()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_copy"><code class="docutils literal notranslate"><span class="pre">grey_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_2d"><code class="docutils literal notranslate"><span class="pre">grey_2d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_3d"><code class="docutils literal notranslate"><span class="pre">grey_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d"><code class="docutils literal notranslate"><span class="pre">grey_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d_cp"><code class="docutils literal notranslate"><span class="pre">grey_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia"><code class="docutils literal notranslate"><span class="pre">sepia()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_copy"><code class="docutils literal notranslate"><span class="pre">sepia_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_3d"><code class="docutils literal notranslate"><span class="pre">sepia_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_1d"><code class="docutils literal notranslate"><span class="pre">sepia_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median"><code class="docutils literal notranslate"><span class="pre">median()</span></code></a></li>
<li><a class="reference internal" href="#Shader.painting"><code class="docutils literal notranslate"><span class="pre">painting()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixels"><code class="docutils literal notranslate"><span class="pre">pixels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median_grayscale"><code class="docutils literal notranslate"><span class="pre">median_grayscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.posterize_surface"><code class="docutils literal notranslate"><span class="pre">posterize_surface()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel"><code class="docutils literal notranslate"><span class="pre">sobel()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_1d"><code class="docutils literal notranslate"><span class="pre">sobel_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_fast"><code class="docutils literal notranslate"><span class="pre">sobel_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert"><code class="docutils literal notranslate"><span class="pre">invert()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert_copy"><code class="docutils literal notranslate"><span class="pre">invert_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert3d"><code class="docutils literal notranslate"><span class="pre">invert3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d"><code class="docutils literal notranslate"><span class="pre">invert1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d_cp"><code class="docutils literal notranslate"><span class="pre">invert1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl_effect"><code class="docutils literal notranslate"><span class="pre">hsl_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl3d"><code class="docutils literal notranslate"><span class="pre">hsl3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d"><code class="docutils literal notranslate"><span class="pre">hsl1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d_cp"><code class="docutils literal notranslate"><span class="pre">hsl1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv_effect"><code class="docutils literal notranslate"><span class="pre">hsv_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv3d"><code class="docutils literal notranslate"><span class="pre">hsv3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d"><code class="docutils literal notranslate"><span class="pre">hsv1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d_cp"><code class="docutils literal notranslate"><span class="pre">hsv1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave"><code class="docutils literal notranslate"><span class="pre">wave()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave32"><code class="docutils literal notranslate"><span class="pre">wave32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave_static"><code class="docutils literal notranslate"><span class="pre">wave_static()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl"><code class="docutils literal notranslate"><span class="pre">swirl()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl32"><code class="docutils literal notranslate"><span class="pre">swirl32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirlf"><code class="docutils literal notranslate"><span class="pre">swirlf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma_config"><code class="docutils literal notranslate"><span class="pre">plasma_config()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma"><code class="docutils literal notranslate"><span class="pre">plasma()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness"><code class="docutils literal notranslate"><span class="pre">brightness()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness3d"><code class="docutils literal notranslate"><span class="pre">brightness3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d"><code class="docutils literal notranslate"><span class="pre">brightness1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d_copy"><code class="docutils literal notranslate"><span class="pre">brightness1d_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_copy"><code class="docutils literal notranslate"><span class="pre">brightness_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_exclude"><code class="docutils literal notranslate"><span class="pre">brightness_exclude()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_bpf"><code class="docutils literal notranslate"><span class="pre">brightness_bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation"><code class="docutils literal notranslate"><span class="pre">saturation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation3d"><code class="docutils literal notranslate"><span class="pre">saturation3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d"><code class="docutils literal notranslate"><span class="pre">saturation1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d_cp"><code class="docutils literal notranslate"><span class="pre">saturation1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatconvection"><code class="docutils literal notranslate"><span class="pre">heatconvection()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_glitch"><code class="docutils literal notranslate"><span class="pre">horizontal_glitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_sglitch"><code class="docutils literal notranslate"><span class="pre">horizontal_sglitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bpf"><code class="docutils literal notranslate"><span class="pre">bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom"><code class="docutils literal notranslate"><span class="pre">bloom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint_param"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint_param()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye"><code class="docutils literal notranslate"><span class="pre">fisheye()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tv_scan"><code class="docutils literal notranslate"><span class="pre">tv_scan()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple"><code class="docutils literal notranslate"><span class="pre">ripple()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple_seabed"><code class="docutils literal notranslate"><span class="pre">ripple_seabed()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatmap"><code class="docutils literal notranslate"><span class="pre">heatmap()</span></code></a></li>
<li><a class="reference internal" href="#Shader.predator_vision"><code class="docutils literal notranslate"><span class="pre">predator_vision()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blood"><code class="docutils literal notranslate"><span class="pre">blood()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring_array"><code class="docutils literal notranslate"><span class="pre">mirroring_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring"><code class="docutils literal notranslate"><span class="pre">mirroring()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen"><code class="docutils literal notranslate"><span class="pre">sharpen()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d"><code class="docutils literal notranslate"><span class="pre">sharpen_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d_cp"><code class="docutils literal notranslate"><span class="pre">sharpen_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen32"><code class="docutils literal notranslate"><span class="pre">sharpen32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dirt_lens"><code class="docutils literal notranslate"><span class="pre">dirt_lens()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering"><code class="docutils literal notranslate"><span class="pre">dithering()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_inplace"><code class="docutils literal notranslate"><span class="pre">dithering_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d"><code class="docutils literal notranslate"><span class="pre">dithering1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d_cp"><code class="docutils literal notranslate"><span class="pre">dithering1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson1d"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixelation"><code class="docutils literal notranslate"><span class="pre">pixelation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend"><code class="docutils literal notranslate"><span class="pre">blend()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend1d"><code class="docutils literal notranslate"><span class="pre">blend1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend_inplace"><code class="docutils literal notranslate"><span class="pre">blend_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.cartoon"><code class="docutils literal notranslate"><span class="pre">cartoon()</span></code></a></li>
<li><a class="reference internal" href="#Shader.convert_27"><code class="docutils literal notranslate"><span class="pre">convert_27()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilateral"><code class="docutils literal notranslate"><span class="pre">bilateral()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss"><code class="docutils literal notranslate"><span class="pre">emboss()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_inplace"><code class="docutils literal notranslate"><span class="pre">emboss_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss1d"><code class="docutils literal notranslate"><span class="pre">emboss1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_gray"><code class="docutils literal notranslate"><span class="pre">emboss_gray()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilinear"><code class="docutils literal notranslate"><span class="pre">bilinear()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling24"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render24"><code class="docutils literal notranslate"><span class="pre">tunnel_render24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling32"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render32"><code class="docutils literal notranslate"><span class="pre">tunnel_render32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast1"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast1()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels"><code class="docutils literal notranslate"><span class="pre">split_channels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels_inplace"><code class="docutils literal notranslate"><span class="pre">split_channels_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wavelength2rgb"><code class="docutils literal notranslate"><span class="pre">wavelength2rgb()</span></code></a></li>
<li><a class="reference internal" href="#Shader.custom_map"><code class="docutils literal notranslate"><span class="pre">custom_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blue_map"><code class="docutils literal notranslate"><span class="pre">blue_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bluescale"><code class="docutils literal notranslate"><span class="pre">bluescale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.red_map"><code class="docutils literal notranslate"><span class="pre">red_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.redscale"><code class="docutils literal notranslate"><span class="pre">redscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dampening"><code class="docutils literal notranslate"><span class="pre">dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.lateral_dampening"><code class="docutils literal notranslate"><span class="pre">lateral_dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending"><code class="docutils literal notranslate"><span class="pre">alpha_blending()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending_inplace"><code class="docutils literal notranslate"><span class="pre">alpha_blending_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.render_light_effect24"><code class="docutils literal notranslate"><span class="pre">render_light_effect24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom_effect_array24_c2"><code class="docutils literal notranslate"><span class="pre">bloom_effect_array24_c2()</span></code></a></li>
<li><a class="reference internal" href="#Shader.area24_cc"><code class="docutils literal notranslate"><span class="pre">area24_cc()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic"><code class="docutils literal notranslate"><span class="pre">chromatic()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic_inplace"><code class="docutils literal notranslate"><span class="pre">chromatic_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom"><code class="docutils literal notranslate"><span class="pre">zoom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom_inplace"><code class="docutils literal notranslate"><span class="pre">zoom_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.Luma_GreyScale"><code class="docutils literal notranslate"><span class="pre">Luma_GreyScale()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="index.html"
                          title="previous chapter">Welcome to PygameShader’s documentation!</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="Shader_gpu.html"
                          title="next chapter">Shader_gpu</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Welcome to PygameShader’s documentation!"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PygameShader 1.0.11 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>