
<!DOCTYPE html>

<html lang="fr" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>GaussianBlur5x5 &#8212; Documentation PygameShader 1.0.11</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=1b8a1eab"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=e6b791cb"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="BurstSurface" href="BurstSurface.html" />
    <link rel="prev" title="Misc" href="Misc.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index g√©n√©ral"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="BurstSurface.html" title="BurstSurface"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="Misc.html" title="Misc"
             accesskey="P">pr√©c√©dent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">GaussianBlur5x5</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="gaussianblur5x5">
<h1>GaussianBlur5x5<a class="headerlink" href="#gaussianblur5x5" title="Lien vers cette rubrique">¬∂</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">FlouGaussien5x5.pyx</span></code></p>
<hr class="docutils" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="summary-of-the-library">
<h2>1. R√©sum√© de la biblioth√®que<a class="headerlink" href="#summary-of-the-library" title="Lien vers cette rubrique">¬∂</a></h2>
<p>Cette biblioth√®que Python fournit des fonctions de <strong>traitement d‚Äôimages</strong> rapides et efficaces, se concentrant sur <strong>le flou</strong>, <strong>le filtrage gaussien</strong>, et <strong>la d√©tection de bords</strong>. Elle est impl√©ment√©e en <strong>Cython</strong> pour des performances √©lev√©es, ce qui la rend id√©ale pour les applications en <strong>vision par ordinateur</strong>, <strong>graphisme</strong>, et <strong>pr√©traitement d‚Äôimages</strong>.</p>
</section>
<section id="purpose">
<h2>2. Objectif<a class="headerlink" href="#purpose" title="Lien vers cette rubrique">¬∂</a></h2>
<p>La biblioth√®que est con√ßue pour effectuer des flous rapides et la d√©tection de bords, ce qui est essentiel pour :</p>
<ul class="simple">
<li><p><strong>R√©duction du bruit</strong> (lissage des images).</p></li>
<li><p><strong>D√©tection de bords</strong> (pour la reconnaissance d‚Äôobjets et l‚Äôextraction de caract√©ristiques).</p></li>
<li><p><strong>Effets graphiques</strong> (flou de mouvement, effets de lueur).</p></li>
<li><p><strong>Pr√©traitement pour les t√¢ches de vision par ordinateur</strong> (segmentation d‚Äôimages, filtrage).</p></li>
</ul>
</section>
<section id="main-features">
<h2>3. Fonctionnalit√©s principales<a class="headerlink" href="#main-features" title="Lien vers cette rubrique">¬∂</a></h2>
<p><strong>Fonctions de flou</strong></p>
<p>Ces fonctions appliquent diff√©rents types de flou pour lisser les images :</p>
<ul class="simple">
<li><p><strong>`flou(surface_, npass)`</strong> :</p></li>
</ul>
<p>Applique un flou √† une surface d‚Äôimage, o√π <cite>npass</cite> contr√¥le l‚Äôintensit√©.</p>
<ul class="simple">
<li><p><strong>`flou3d(rgb_array, npass)`</strong> :</p></li>
</ul>
<p>Applique un flou √† un tableau d‚Äôimage 3D (RGB).</p>
<ul class="simple">
<li><p><strong>`flou1d(bgr_array, width, height, npass, format_32)`</strong> :</p></li>
</ul>
<p>Flou 1D optimis√© pour l‚Äôefficacit√©.</p>
<ul class="simple">
<li><p><strong>`flou1d_cp(bgr_array, width, height, npass, format_32)`</strong> :</p></li>
</ul>
<p>Retourne un nouveau tableau flout√© au lieu de modifier l‚Äôoriginal.</p>
<ul class="simple">
<li><p><strong>`flou4bloom_c(surface_, npass, tmp_array)`</strong> :</p></li>
</ul>
<p>Probablement utilis√© pour des effets de lueur, en renfor√ßant les zones lumineuses.</p>
<p>Plusieurs versions internes <strong>optimis√©es en Cython</strong> (<cite>blur3d_c</cite>, <cite>blur1d_c</cite>, etc.) fonctionnent sans le <strong>Global Interpreter Lock (GIL)</strong> pour le support du multithreading.</p>
<p><strong>Filtrage Gaussien</strong></p>
<ul class="simple">
<li><p><strong>`filtre_gaussien24(surface_)`</strong> :</p></li>
</ul>
<p>Applique un flou gaussien √† une image 24 bits.</p>
<ul class="simple">
<li><p><strong>`filtre_gaussien32(surface_)`</strong> :</p></li>
</ul>
<p>Applique un flou gaussien √† une image 32 bits.</p>
<p>üìå <strong>Pourquoi le flou gaussien ?</strong></p>
<p>Il aide √† lisser les images avant la d√©tection des bords, r√©duisant les faux bords caus√©s par le bruit.</p>
<p><strong>D√©tection des bords (Algorithme de Canny)</strong></p>
<p>L‚Äù<strong>algorithme de Canny</strong> est largement utilis√© en vision par ordinateur pour d√©tecter les contours des objets.</p>
<ul class="simple">
<li><p><strong>`canny3d(rgb_array, seuil, bas, haut)`</strong> :</p></li>
</ul>
<p>D√©tecte les bords dans une image RGB.</p>
<ul class="simple">
<li><p><strong>`canny1d(bgr_array, largeur, hauteur, format_32, seuil)`</strong> :</p></li>
</ul>
<p>D√©tecte les bords dans une repr√©sentation lin√©aire 1D de l‚Äôimage pour plus d‚Äôefficacit√©.</p>
<p>Il existe √©galement des versions <strong>optimis√©es en Cython</strong> (<cite>canny3d_c</cite>, <cite>canny1d_c</cite>) qui am√©liorent les performances en utilisant le multi-threading.</p>
<p><strong>Fonctionnalit√©s d‚Äôoptimisation</strong></p>
<ul class="simple">
<li><p><strong>Bas√© sur Cython</strong> (<cite>cdef</cite>, <cite>cpdef</cite>, <cite>nogil</cite>) ‚Üí Performances au niveau C direct.</p></li>
<li><p><strong>Op√©rations sur place</strong> (<cite>flou1d</cite>, <cite>flou3d</cite>) ‚Üí √âconomise de la m√©moire.</p></li>
<li><p><strong>Multi-threading</strong> (<cite>nogil</cite>) ‚Üí Ex√©cution plus rapide sur des processeurs multic≈ìurs.</p></li>
<li><p><strong>Gestion optimis√©e de la m√©moire</strong> (<cite>[::1]</cite> vues m√©moire) ‚Üí R√©duit la surcharge Python.</p></li>
</ul>
</section>
<section id="use-cases">
<h2>4. Cas d‚Äôutilisation<a class="headerlink" href="#use-cases" title="Lien vers cette rubrique">¬∂</a></h2>
<ul class="simple">
<li><p><strong>Vision par ordinateur</strong> ‚Üí Reconnaissance d‚Äôobjets, extraction de caract√©ristiques.</p></li>
<li><p><strong>Graphismes et jeux</strong> ‚Üí Flou de mouvement, effets de lueur.</p></li>
<li><p><strong>Pipelines de traitement d‚Äôimages</strong> ‚Üí Pr√©traitement avant les mod√®les d‚Äôapprentissage automatique.</p></li>
<li><p><strong>Imagerie m√©dicale</strong> ‚Üí Am√©lioration et d√©tection de caract√©ristiques dans les scans.</p></li>
</ul>
</section>
<section id="conclusion">
<h2>5. Conclusion<a class="headerlink" href="#conclusion" title="Lien vers cette rubrique">¬∂</a></h2>
<p>Cette biblioth√®que est hautement optimis√©e pour un flou rapide, un filtrage gaussien et la d√©tection de bords, ce qui en fait un excellent choix pour la <strong>vision par ordinateur</strong>, les <strong>graphismes</strong> et les <strong>applications d‚Äôapprentissage automatique</strong> o√π la vitesse est cruciale.</p>
</section>
<section id="cython-list-methods">
<h2>6. M√©thodes de liste Cython<a class="headerlink" href="#cython-list-methods" title="Lien vers cette rubrique">¬∂</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.blur">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">blur</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.blur" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Param√®tres</strong> : - <cite>surface_</cite> (<em>pygame.Surface</em>): Un objet surface Pygame (24 bits ou 32 bits). - <cite>npass</cite> (<em>int</em>, optionnel): Le nombre de passes de flou √† appliquer (la valeur par d√©faut est 1). Doit √™tre un entier positif.</p>
<p><strong>Retourne</strong> : Rien</p>
<p><strong>Description</strong> : Applique un effet de flou gaussien sur place √† une surface Pygame.</p>
<p>Cette fonction effectue une <strong>convolution √† deux passes</strong> en utilisant un <strong>noyau gaussien 5x5</strong> pour flouter la surface d‚Äôentr√©e. La premi√®re passe applique le flou horizontalement, et la deuxi√®me passe applique le flou verticalement. Pour les pixels en dehors des limites de l‚Äôimage, la fonction attribue la valeur du bord le plus proche pour r√©duire les artefacts visuels.</p>
<div class="math notranslate nohighlight">
\[\text{Horizontal pass: }
\begin{bmatrix}
\frac{1}{16} &amp; \frac{4}{16} &amp; \frac{6}{16} &amp; \frac{4}{16} &amp; \frac{1}{16}
\end{bmatrix}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\text{Vertical pass: }
\begin{bmatrix}
\frac{1}{16} \\ \frac{4}{16} \\ \frac{6}{16} \\ \frac{4}{16} \\ \frac{1}{16}
\end{bmatrix}\end{split}\]</div>
<p><strong>Caract√©ristiques</strong></p>
<ul class="simple">
<li><p>Prend en charge les surfaces Pygame <strong>24 bits (RGB)</strong> et <strong>32 bits (RGBA)</strong>.</p></li>
<li><p>Utilise un <strong>noyau gaussien 5x5</strong> pour lisser l‚Äôimage.</p></li>
<li><p>Permet <strong>plusieurs passes</strong> (<cite>npass &gt; 1</cite>) pour une intensit√© de flou am√©lior√©e.</p></li>
<li><p>Ignore le <strong>canal alpha</strong> pendant le traitement afin d‚Äô√©viter d‚Äôalt√©rer la transparence.</p></li>
</ul>
<p><strong>Param√®tres</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Un objet surface Pygame auquel l‚Äôeffet de flou sera appliqu√©. Il doit √™tre soit en <strong>RGB 24 bits</strong>, soit en <strong>RGBA 32 bits</strong>. La fonction modifie la surface sur place.</p></li>
<li><p><strong>npass</strong> (<em>int</em>, optionnel) : Le nombre de passes de flou √† appliquer. La valeur par d√©faut est <strong>1</strong>. Doit √™tre un <strong>entier positif</strong> (<cite>npass &gt; 0</cite>). Plus de passes entra√Ænent un effet de flou plus fort, mais peuvent augmenter le temps de traitement.</p></li>
</ul>
<p><strong>Retourne</strong></p>
<ul class="simple">
<li><p><strong>Rien</strong> ‚Äì La fonction modifie <cite>surface_</cite> sur place, sans valeur de retour.</p></li>
</ul>
<p><strong>L√®ve</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n‚Äôest pas un objet <cite>pygame.Surface</cite> valide.</p></li>
<li><p><strong>ValueError</strong> : Si le format de la surface est incompatible (par exemple, format non 24 bits ou non 32 bits) ou ne peut pas √™tre trait√©.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>npass</cite> n‚Äôest pas un entier positif (<cite>npass &lt;= 0</cite>).</p></li>
</ul>
<p><strong>D√©tails de l‚Äôimpl√©mentation</strong></p>
<ul class="simple">
<li><p>La fonction acc√®de directement au tampon des pixels de la surface en utilisant <cite>get_view(‚Äú3‚Äù)</cite>, ce qui lui permet de traiter <strong>uniquement les canaux RGB</strong>, en ignorant le canal alpha.</p></li>
<li><p>Elle appelle une fonction Cython optimis√©e, <cite>blur3d_c()</cite>, pour effectuer le flou sur place avec un minimum de frais g√©n√©raux.</p></li>
<li><p>Si <cite>npass &gt; 1</cite>, plusieurs passes de flou sont appliqu√©es pour un effet plus fort, mais cela augmente le temps de traitement.</p></li>
</ul>
<p><strong>Efficacit√© m√©moire</strong></p>
<ul class="simple">
<li><p>Cette fonction est <strong>efficace en m√©moire</strong>, car elle op√®re directement sur le tampon de la surface sans cr√©er de copies suppl√©mentaires des donn√©es de l‚Äôimage.</p></li>
<li><p>Si la surface poss√®de un <strong>canal alpha</strong>, il est <strong>ignor√©</strong> pendant le traitement, ce qui signifie que toute information de transparence restera inchang√©e.</p></li>
</ul>
<p><strong>Consid√©rations sur les performances</strong></p>
<ul class="simple">
<li><p>La fonction est optimis√©e en utilisant Cython pour minimiser les frais g√©n√©raux et am√©liorer les performances.</p></li>
<li><p>Elle prend en charge le <strong>multi-threading</strong> lorsqu‚Äôelle utilise la fonctionnalit√© <cite>nogil</cite> de Cython pour am√©liorer la vitesse d‚Äôex√©cution sur des syst√®mes multi-c≈ìurs.</p></li>
</ul>
<p><strong>Exemple d‚Äôutilisation</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">your_module</span><span class="w"> </span><span class="kn">import</span> <span class="n">blur</span>

<span class="c1"># Create a 24-bit Pygame surface</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

<span class="c1"># Apply a single blur pass (default)</span>
<span class="n">blur</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Apply three blur passes for a stronger blur effect</span>
<span class="n">blur</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">npass</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Voir aussi</strong></p>
<ul class="simple">
<li><p><cite>blur3d_c</cite>: Fonction Cython optimis√©e pour le flou d‚Äôimages 3D.</p></li>
<li><p><cite>gaussian_filter</cite>: Applique un flou gaussien avec plus de contr√¥le sur la taille du noyau.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.blur3d">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">blur3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.blur3d" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Param√®tres</strong> : - <cite>rgb_array</cite> (<em>numpy.ndarray</em> ou <em>memoryview slice</em>): Un tableau 3D de forme <cite>(w, h, n)</cite>, repr√©sentant une image au format RGB(A). - <cite>npass</cite> (<em>int</em>, optionnel) : Le nombre de passes de flou √† appliquer (<strong>la valeur par d√©faut est `1`</strong>). Plus de passes entra√Ænent un flou plus fort.</p>
<p><strong>Retourne</strong> : Rien</p>
<p><strong>Description</strong></p>
<p>Applique un flou gaussien sur place √† un <strong>tableau d‚Äôimage 3D ou un segment de m√©moire</strong>.</p>
<p>Cette fonction applique un <strong>flou gaussien</strong> sur une image repr√©sent√©e sous la forme d‚Äôun tableau 3D de forme <cite>(w, h, n)</cite>, o√π <cite>w</cite> et <cite>h</cite> sont la largeur et la hauteur, et <cite>n</cite> est le nombre de canaux de couleur (g√©n√©ralement <strong>3 pour RGB</strong> ou <strong>4 pour RGBA</strong>). Elle utilise un <strong>noyau gaussien 5x5</strong> pour le lissage, appliqu√© par <strong>convolution √† deux passes</strong> (horizontale + verticale). La fonction modifie le tableau d‚Äôentr√©e sur place, √©vitant toute allocation m√©moire inutile.</p>
<p><strong>Caract√©ristiques</strong></p>
<ul class="simple">
<li><p>Prend en charge les <strong>donn√©es d‚Äôimage RGB(A)</strong> avec n‚Äôimporte quel nombre de canaux (<cite>n = 3</cite> pour RGB, <cite>n = 4</cite> pour RGBA).</p></li>
<li><p>Effectue un <strong>flou gaussien</strong> en utilisant un <strong>noyau de convolution 5x5</strong>.</p></li>
<li><p>Utilise une <strong>convolution √† deux passes</strong> (horizontale et verticale) pour un flou efficace.</p></li>
<li><p>G√®re les <strong>pixels de bord</strong> en les d√©finissant aux valeurs de bord les plus proches.</p></li>
<li><p>Permet <strong>plusieurs passes de flou</strong> (<cite>npass &gt; 1</cite>) pour un lissage accru.</p></li>
</ul>
<p><strong>Param√®tres</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em> ou <em>memoryview slice</em>): Un <strong>tableau 3D</strong> de forme <cite>(w, h, n)</cite>, contenant des valeurs <strong>uint8</strong> repr√©sentant l‚Äôimage en <strong>format RGB(A)</strong>. La fonction modifie ce tableau sur place.</p></li>
<li><p><strong>npass</strong> (<em>int</em>, optionnel) : Le nombre de passes de flou √† appliquer. <strong>La valeur par d√©faut est `1`</strong>. Des valeurs plus √©lev√©es <strong>augmenteront la force du flou</strong> mais requerront plus de temps de traitement.</p></li>
</ul>
<p><strong>Retourne</strong></p>
<ul class="simple">
<li><p><strong>Aucun</strong> ‚Äì La fonction modifie <cite>rgb_array</cite> en place et ne renvoie rien.</p></li>
</ul>
<p><strong>D√©tails de l‚Äôimpl√©mentation</strong></p>
<ul class="simple">
<li><p>La fonction applique un <strong>flou gaussien 5x5</strong> en utilisant le noyau :</p></li>
</ul>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{256}
\begin{bmatrix}
1  &amp;  4  &amp;  6  &amp;  4  &amp;  1  \\
4  &amp; 16  &amp; 24  &amp; 16  &amp;  4  \\
6  &amp; 24  &amp; 36  &amp; 24  &amp;  6  \\
4  &amp; 16  &amp; 24  &amp; 16  &amp;  4  \\
1  &amp;  4  &amp;  6  &amp;  4  &amp;  1
\end{bmatrix}\end{split}\]</div>
</div></blockquote>
<ul class="simple">
<li><p>Utilise une <strong>convolution √† deux passes</strong> (horizontale et verticale) pour appliquer le flou de mani√®re efficace.</p></li>
<li><p>G√®re les <strong>pixels de bordure</strong> en assignant les <strong>valeurs de bordure les plus proches</strong> pour pr√©venir les artefacts.</p></li>
<li><p>Optimis√© pour le <strong>traitement d‚Äôimages</strong>, le <strong>rendu en temps r√©el</strong> et les <strong>effets graphiques</strong>.</p></li>
</ul>
<p><strong>Efficacit√© m√©moire</strong></p>
<ul class="simple">
<li><p>Fonctionne <strong>directement sur le tampon d‚Äôimage</strong>, √©vitant ainsi des allocations de m√©moire suppl√©mentaires.</p></li>
<li><p>Peut √™tre utilis√© sur de grandes images sans une surcharge m√©moire significative.</p></li>
<li><p>Optimis√© avec <strong>Cython</strong> pour des performances √©lev√©es.</p></li>
</ul>
<p><strong>Exemple d‚Äôutilisation</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">your_module</span><span class="w"> </span><span class="kn">import</span> <span class="n">blur3d</span>

<span class="c1"># Create a sample 3D RGB image array (100x100 with 3 channels)</span>
<span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Apply a single blur pass</span>
<span class="n">blur3d</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">)</span>

<span class="c1"># Apply multiple blur passes for stronger blur effect</span>
<span class="n">blur3d</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">,</span> <span class="n">npass</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Cas d‚Äôutilisation</strong></p>
<ul class="simple">
<li><p><strong>Vision par ordinateur</strong> ‚Üí Pr√©traitement pour la segmentation d‚Äôimages et la d√©tection d‚Äôobjets.</p></li>
<li><p><strong>Graphismes et jeux</strong> ‚Üí Flou de mouvement, effets de bloom et rendu en temps r√©el.</p></li>
<li><p><strong>Pipelines de traitement d‚Äôimages</strong> ‚Üí R√©duction du bruit et am√©lioration de la qualit√© visuelle.</p></li>
<li><p><strong>Imagerie m√©dicale</strong> ‚Üí Lissage des donn√©es d‚Äôimage avant l‚Äôextraction des caract√©ristiques.</p></li>
</ul>
<p><strong>Voir aussi</strong></p>
<ul class="simple">
<li><p><cite>flou</cite> ‚Üí Floute directement une surface Pygame.</p></li>
<li><p><cite>gauss_filter24</cite> ‚Üí Applique un filtrage gaussien sur une image de 24 bits.</p></li>
<li><p><cite>canny3d</cite> ‚Üí Effectue une d√©tection des bords sur une image RGB.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p><strong>Applique un flou gaussien en place sur un tableau 1D ou un tranche de memoryview repr√©sentant les donn√©es des pixels.</strong></p>
<p>Cette fonction applique un <strong>flou gaussien</strong> sur un tableau 1D (ou une tranche de memoryview) de forme <cite>(w,)</cite>, o√π <cite>w</cite> est le nombre de pixels. Le tableau peut repr√©senter des formats de pixels <strong>BGR</strong> (24 bits) ou <strong>BGRA</strong> (32 bits) ou tout autre format compatible avec le type de donn√©es <cite>uint8</cite>. L‚Äôop√©ration de flou est effectu√©e <strong>en place</strong> sur le tableau fourni.</p>
<p>La fonction effectue <strong>npass</strong> passes de convolution en utilisant un <strong>noyau gaussien 5x5</strong>. Cela peut √™tre utile pour les t√¢ches de traitement d‚Äôimages o√π vous devez appliquer un effet de flou, en particulier sur des donn√©es de pixels repr√©sent√©es sous forme de tableau 1D (comme lorsque les donn√©es de l‚Äôimage sont aplaties).</p>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (<em>1D numpy.ndarray</em> ou <em>tranche memoryview</em>) : Un tableau 1D ou une tranche de memoryview de forme <cite>(w,)</cite> contenant les donn√©es des pixels (par exemple, en <strong>BGR(A)</strong> ou tout autre format de pixel). Le tableau doit √™tre de type <strong>uint8</strong>.</p></li>
<li><p><strong>largeur</strong> (<em>int</em>) : La largeur (<cite>w</cite>) de l‚Äôimage originale. Utilis√© pour un traitement correct lors de l‚Äôop√©ration de flou.</p></li>
<li><p><strong>hauteur</strong> (<em>int</em>) : La hauteur (<cite>h</cite>) de l‚Äôimage originale. N√©cessaire pour un traitement correct de l‚Äôimage.</p></li>
<li><p><strong>npass</strong> (<em>int</em>, optionnel) : Le nombre de passes de flou √† appliquer. <strong>La valeur par d√©faut est 1 passe</strong>. Plus de passes donnent un flou plus fort.</p></li>
<li><p><strong>format_32</strong> (<em>bool</em>) : Un indicateur pour savoir si le format des pixels est <strong>BGR (24 bits)</strong> ou <strong>BGRA (32 bits)</strong>. <cite>False</cite> pour <strong>BGR (24 bits)</strong> (3 canaux) et <cite>True</cite> pour <strong>BGRA (32 bits)</strong> (4 canaux).</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p><strong>Aucun</strong> : La fonction effectue le flou en place sur <cite>bgr_array</cite> et ne renvoie pas de valeur.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>La fonction utilise la <strong>convolution gaussienne</strong> avec un noyau 5x5 utilis√© en deux passes.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{256} \begin{bmatrix}
1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \\
4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\
6 &amp; 24 &amp; 36 &amp; 24 &amp; 6 \\
4 &amp; 16 &amp; 24 &amp; 16 &amp; 4 \\
1 &amp; 4 &amp; 6 &amp; 4 &amp; 1
\end{bmatrix}\end{split}\]</div>
<ul class="simple">
<li><p>L‚Äôimage est trait√©e en deux passes (horizontale et verticale) pour plus d‚Äôefficacit√©.</p></li>
<li><p><strong>Gestion des bords</strong> : Les pixels en dehors des limites de l‚Äôimage sont remplac√©s par les valeurs des bords adjacents.</p></li>
<li><p>La fonction fonctionne <strong>en place</strong>, ce qui signifie que le tableau <cite>bgr_array</cite> original est directement modifi√©.</p></li>
<li><p>Cette fonction est compatible avec les formats de pixels <strong>BGR</strong> et <strong>BGRA</strong> (ou d‚Äôautres formats ayant la m√™me forme et le m√™me type de donn√©es).</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.blur1d_cp">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">blur1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npass</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.blur1d_cp" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Applique un effet de flou √† un tampon 1D (tranche de memoryview) et renvoie une copie.</p>
<p>Cette fonction prend un <strong>tampon 1D ou une tranche de memoryview</strong> contenant les donn√©es des pixels au format <strong>BGR(A)</strong> (ou tout autre format de pixel compatible) et applique un <strong>flou gaussien</strong>. Le r√©sultat flout√© est renvoy√© comme un nouveau tableau, laissant le tampon original inchang√©.</p>
<p>La fonction prend en charge les formats de pixels <strong>24 bits (BGR)</strong> et <strong>32 bits (BGRA)</strong>. Le param√®tre <cite>format_32</cite> doit √™tre d√©fini en cons√©quence :</p>
<ul class="simple">
<li><p><strong>`format_32=False`</strong> ‚Üí pour le format <strong>BGR (24 bits)</strong>.</p></li>
<li><p><strong>`format_32=True`</strong> ‚Üí pour le format <strong>BGRA (32 bits)</strong> (inclut un canal alpha).</p></li>
</ul>
<p><strong>Exemple d‚Äôutilisation :</strong></p>
<p><strong>Pour une image 24 bits (format BGR) :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">blur1d_cp</span><span class="p">(</span>
    <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
    <span class="n">npass</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Pour une image 32 bits (format BGRA) :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">blur1d_cp</span><span class="p">(</span>
    <span class="n">source</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
    <span class="n">npass</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (<em>C-buffer, numpy.ndarray, ou tranche de memoryview</em>): Un <strong>tableau 1D</strong> de forme <cite>(w,)</cite> contenant des donn√©es de pixels <strong>BGR(A)</strong> (ou tout format compatible).</p></li>
<li><p><strong>width</strong> (<em>int</em>): La largeur de l‚Äôimage originale en pixels.</p></li>
<li><p><strong>height</strong> (<em>int</em>): La hauteur de l‚Äôimage originale en pixels.</p></li>
<li><p><strong>npass</strong> (<em>int</em>, optionnel): Le nombre de passes de flou √† appliquer (<strong>par d√©faut, 1</strong>). Augmenter cette valeur intensifie l‚Äôeffet de flou.</p></li>
<li><p><strong>format_32</strong> (<em>bool</em>): - <cite>True</cite> ‚Üí format <strong>BGRA (32 bits)</strong> (inclut un canal alpha). - <cite>False</cite> ‚Üí format <strong>BGR (24 bits)</strong>.</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p><strong>numpy.ndarray</strong> ou <strong>tranche de memoryview</strong> (<cite>shape (w,)</cite>, <cite>dtype=uint8</cite>): Une <strong>copie flout√©e</strong> du tableau d‚Äôentr√©e, maintenant le format de pixel original.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>Cette fonction <strong>ne modifie pas le tampon d‚Äôentr√©e</strong>; elle renvoie un <strong>nouveau</strong> tableau flout√©.</p></li>
<li><p>L‚Äôop√©ration de flou utilise la <strong>convolution gaussienne</strong> en plusieurs passes.</p></li>
<li><p>Le <strong>format de pixel du tableau de sortie est identique</strong> √† celui du tampon d‚Äôentr√©e.</p></li>
<li><p>Fournir un indicateur <cite>format_32</cite> appropri√© garantit une gestion correcte de la transparence alpha.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.gauss_filter24">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">gauss_filter24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.gauss_filter24" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Appliquez un filtre gaussien 5x5 pour lisser une image ou une surface. Cette fonction effectue un flou gaussien √† l‚Äôaide d‚Äôun noyau de convolution 5x5, ce qui aide √† r√©duire le bruit et les d√©tails dans une image. Il est particuli√®rement utile pour le pr√©traitement des images avant la d√©tection des bords ou d‚Äôautres t√¢ches de vision par ordinateur.</p>
<p><strong>Noyau Gaussien 5x5 :</strong></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2
\end{bmatrix}\end{split}\]</div>
<ul class="simple">
<li><p>Les valeurs du noyau sont normalis√©es en interne pour garantir un lissage appropri√©.</p></li>
<li><p>Le processus de filtrage pr√©serve mieux les bords qu‚Äôun simple flou moyen.</p></li>
</ul>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>surface_ (pygame.Surface, image 24 bits ou 32 bits) :</strong></p></li>
<li><p>L‚Äôimage ou la surface d‚Äôentr√©e √† flouter.</p></li>
<li><p>Si une surface 32 bits (avec un canal alpha) est fournie, le canal alpha est ignor√© dans la sortie, ce qui donne une image 24 bits.</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface (image filtr√©e 24 bits) :</strong> - Une nouvelle surface flout√©e avec moins de bruit et des transitions de pixels liss√©es. - L‚Äôimage de sortie est toujours en 24 bits, m√™me si l‚Äôentr√©e √©tait en 32 bits.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>Le flou gaussien est largement utilis√© en vision par ordinateur et en graphisme pour r√©duire le bruit haute fr√©quence.</p></li>
<li><p>Cette m√©thode est optimis√©e pour la performance et pr√©serve l‚Äôint√©grit√© de l‚Äôimage.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.gauss_filter32">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">gauss_filter32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.gauss_filter32" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Appliquez un filtre de flou gaussien 5x5 √† une image ou une surface pygame. Cette fonction lisse une image en la convoluant avec un noyau gaussien 5x5, r√©duisant le bruit et les d√©tails fins tout en pr√©servant les structures essentielles. Noyau Gaussien 5x5 :</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2
\end{bmatrix}\end{split}\]</div>
<ul class="simple">
<li><p>Les valeurs du noyau sont normalis√©es en interne pour garantir un lissage appropri√©.</p></li>
<li><p>Cette m√©thode aide √† √©liminer le bruit haute fr√©quence tout en conservant les structures importantes de l‚Äôimage.</p></li>
</ul>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>surface_ (pygame.Surface, image 32 bits ou 24 bits) :</strong></p></li>
<li><p>L‚Äôimage ou la surface d‚Äôentr√©e √† flouter.</p></li>
<li><p>Les surfaces 24 bits (RGB) et 32 bits (RGBA) sont toutes deux prises en charge.</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p>pygame.Surface (image filtr√©e 32 bits) :</p></li>
<li><p>Une nouvelle surface flout√©e o√π les transitions de pixels sont liss√©es.</p></li>
<li><p>Si la surface d‚Äôorigine inclut une transparence par pixel (canal alpha), elle est pr√©serv√©e dans la sortie.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>Le flou gaussien est couramment utilis√© dans le pr√©traitement d‚Äôimages, la r√©duction du bruit, et les effets artistiques.</p></li>
<li><p>Le processus de filtrage est optimis√© pour la performance tout en maintenant une haute fid√©lit√© de l‚Äôimage.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.canny3d">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">canny3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.canny3d" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Appliquez la d√©tection de bords de Canny √† un tableau 3D ou un tranche de m√©moire. L‚Äôalgorithme de d√©tection de bords de Canny est un processus multi-√©tapes qui identifie les bords dans une image en d√©tectant les zones avec des changements d‚Äôintensit√© significatifs. Il a √©t√© d√©velopp√© par John F. Canny (1986) et reste largement utilis√© en vision par ordinateur.</p>
<p><strong>√âtapes de l‚Äôalgorithme de Canny :</strong></p>
<ol class="arabic simple">
<li><p>Calcul du gradient ‚Äì D√©tecte les changements d‚Äôintensit√©.</p></li>
<li><p>Suppression non maximale ‚Äì Supprime les pixels non-bords.</p></li>
<li><p>Double seuillage ‚Äì Filtre les bords faibles.</p></li>
<li><p>Suivi des bords par hyst√©r√©sis ‚Äì Conserve les bords forts.</p></li>
</ol>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (numpy.ndarray ou memoryviewslice, forme (w, h, n), dtype uint8) : Image d‚Äôentr√©e sous forme de tableau 3D avec RGB(A), BGRA ou d‚Äôautres formats de pixels.</p></li>
<li><p><strong>seuil</strong> (char non sign√©, par d√©faut = 50) : Seuil inf√©rieur pour supprimer les bords faibles dans la magnitude du gradient.</p></li>
<li><p><strong>low</strong> (char non sign√©, par d√©faut = 0) : Seuil inf√©rieur d‚Äôhyst√©r√©sis pour le suivi des bords. Les bords faibles en dessous de cette valeur sont √©limin√©s.</p></li>
<li><p><strong>high</strong> (char non sign√©, par d√©faut = 20) : Seuil sup√©rieur d‚Äôhyst√©r√©sis pour le suivi des bords. Les bords forts au-dessus de cette valeur sont conserv√©s.</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p>pygame.Surface ‚Äì Une nouvelle surface/image avec les bords d√©tect√©s.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>Des valeurs <cite>threshold</cite> plus √©lev√©es produisent moins de bords (moins de bruit).</p></li>
<li><p>L‚Äôhyst√©r√©sis (<cite>low</cite>, <cite>high</cite>) garantit que seuls les bords significatifs sont conserv√©s.</p></li>
<li><p>Cette fonction prend en charge plusieurs formats de pixels et fonctionne directement sur des tableaux 3D.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.canny1d">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">canny1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">70</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.canny1d" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Appliquez la d√©tection de bords de Canny √† un tampon 1D, un tableau NumPy, ou une tranche de m√©moire. Cette fonction traite un tampon d‚Äôimage plat (1D) repr√©sentant une image en niveaux de gris ou en couleur et applique l‚Äôalgorithme de d√©tection de bords de Canny pour mettre en √©vidence les bords.</p>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (numpy.ndarray ou memoryviewslice, forme (w,), dtype uint8) : Tampon 1D contenant des donn√©es de pixels en BGR(A), BGR ou d‚Äôautres formats.</p></li>
<li><p><strong>largeur</strong> (int) : Largeur de l‚Äôimage originale en pixels.</p></li>
<li><p><strong>hauteur</strong> (int) : Hauteur de l‚Äôimage originale en pixels.</p></li>
<li><p><strong>format_32</strong> (bool) : True pour les tampons 32 bits (BGRA, BGRA). False pour les tampons 24 bits (BGR, BGR).</p></li>
<li><p><strong>seuil</strong> (int, par d√©faut = 70) : Seuil de magnitude du gradient pour la d√©tection des bords. Des valeurs plus √©lev√©es suppriment les bords plus faibles et r√©duisent le bruit.</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p>pygame.Surface ‚Äì Une nouvelle image avec d√©tection de bords de Canny appliqu√©e.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>Cette fonction prend en charge divers formats de pixels (par exemple, RGB, BGR, RGBA, BGRA).</p></li>
<li><p>Le seuillage affecte la force des bords ‚Äî ajustez-le pour des r√©sultats optimaux.</p></li>
<li><p>Fonctionne directement sur un tampon 1D, ce qui le rend efficace en termes de m√©moire.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="GaussianBlur5x5.blur3d_cp">
<span class="sig-prename descclassname"><span class="pre">GaussianBlur5x5.</span></span><span class="sig-name descname"><span class="pre">blur3d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#GaussianBlur5x5.blur3d_cp" title="Lien vers cette d√©finition">¬∂</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Appliquez un effet de flou √† un tableau numpy 3D ou √† une tranche de m√©moire (renvoie une copie). Cette fonction effectue une op√©ration de flou sur un tableau 3D, comme une image, et renvoie une copie flout√©e. Elle prend en charge les formats RGB(A) ou d‚Äôautres formats de pixels, tout en maintenant le format d‚Äôorigine dans le tableau renvoy√©.</p>
<p><strong>Param√®tres :</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (numpy.ndarray ou memoryviewslice, forme (w, h, n), dtype uint8) : Tableau 3D contenant des donn√©es de pixels en RGB(A) ou tout format compatible (par exemple, BGRA). La forme doit √™tre (largeur, hauteur, canaux) o√π les canaux repr√©sentent typiquement les composants de couleur (3 pour RGB, 4 pour RGBA, etc.).</p></li>
</ul>
<p><strong>Renvoie :</strong></p>
<ul class="simple">
<li><p>numpy.ndarray : Un nouveau tableau (copie flout√©e) avec la m√™me forme et le m√™me format de pixel que <cite>rgb_array</cite>. Le tableau renvoy√© aura la m√™me largeur, hauteur et format de pixel que l‚Äôentr√©e, mais avec l‚Äôeffet de flou appliqu√©.</p></li>
</ul>
<p><strong>Notes :</strong></p>
<ul class="simple">
<li><p>La fonction ne modifie pas le tableau d‚Äôentr√©e sur place ; elle renvoie un nouveau tableau flout√©.</p></li>
<li><p>La sortie conservera les m√™mes canaux de couleur (par exemple, RGB ou RGBA).</p></li>
</ul>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table des mati√®res</a></h3>
    <ul>
<li><a class="reference internal" href="#">GaussianBlur5x5</a><ul>
<li><a class="reference internal" href="#summary-of-the-library">1. R√©sum√© de la biblioth√®que</a></li>
<li><a class="reference internal" href="#purpose">2. Objectif</a></li>
<li><a class="reference internal" href="#main-features">3. Fonctionnalit√©s principales</a></li>
<li><a class="reference internal" href="#use-cases">4. Cas d‚Äôutilisation</a></li>
<li><a class="reference internal" href="#conclusion">5. Conclusion</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. M√©thodes de liste Cython</a><ul>
<li><a class="reference internal" href="#GaussianBlur5x5.blur"><code class="docutils literal notranslate"><span class="pre">blur()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.blur3d"><code class="docutils literal notranslate"><span class="pre">blur3d()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.blur1d_cp"><code class="docutils literal notranslate"><span class="pre">blur1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.gauss_filter24"><code class="docutils literal notranslate"><span class="pre">gauss_filter24()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.gauss_filter32"><code class="docutils literal notranslate"><span class="pre">gauss_filter32()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.canny3d"><code class="docutils literal notranslate"><span class="pre">canny3d()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.canny1d"><code class="docutils literal notranslate"><span class="pre">canny1d()</span></code></a></li>
<li><a class="reference internal" href="#GaussianBlur5x5.blur3d_cp"><code class="docutils literal notranslate"><span class="pre">blur3d_cp()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet pr√©c√©dent</h4>
    <p class="topless"><a href="Misc.html"
                          title="Chapitre pr√©c√©dent">Misc</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="BurstSurface.html"
                          title="Chapitre suivant">BurstSurface</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/GaussianBlur5x5.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index g√©n√©ral"
             >index</a></li>
        <li class="right" >
          <a href="BurstSurface.html" title="BurstSurface"
             >suivant</a> |</li>
        <li class="right" >
          <a href="Misc.html" title="Misc"
             >pr√©c√©dent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">GaussianBlur5x5</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Cr√©√© en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>