
<!DOCTYPE html>

<html lang="fr" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader &#8212; Documentation PygameShader 1.0.11</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=1b8a1eab"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=e6b791cb"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="Shader_gpu" href="Shader_gpu.html" />
    <link rel="prev" title="Bienvenue dans la documentation de PygameShader !" href="index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="index.html" title="Bienvenue dans la documentation de PygameShader !"
             accesskey="P">précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader">
<h1>Shader<a class="headerlink" href="#shader" title="Lien vers cette rubrique">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader.pyx</span></code></p>
<hr class="docutils" />
<section id="high-performance-image-processing-library">
<h2>1. Bibliothèque de traitement d’image haute performance<a class="headerlink" href="#high-performance-image-processing-library" title="Lien vers cette rubrique">¶</a></h2>
<p>Cette bibliothèque est un module basé sur Cython conçu pour le traitement et la manipulation d’images haute performance. En exploitant la capacité de Cython à combiner la simplicité de Python avec les performances du C, elle est optimisée pour des tâches intensives en calcul, telles que le traitement d’image en temps réel, le développement de jeux, la vision par ordinateur et les effets artistiques.</p>
</section>
<section id="key-features">
<h2>2. Fonctionnalités principales<a class="headerlink" href="#key-features" title="Lien vers cette rubrique">¶</a></h2>
<ul class="simple">
<li><p><strong>Conversions d’espaces colorimétriques</strong> (RGB, niveaux de gris, HSL, HSV)</p></li>
<li><p><strong>Transformations d’image</strong> (miroir, pixellisation, redimensionnement)</p></li>
<li><p><strong>Effets visuels</strong> (distorsions, filtres, effets artistiques)</p></li>
<li><p><strong>Traitement d’image avancé</strong> (détection des contours, accentuation, fusion)</p></li>
<li><p><strong>Simulations physiques</strong> (effets d’ondulation, convection thermique)</p></li>
<li><p><strong>Optimisations des performances</strong> (multi-threading, opérations optimisées en mémoire)</p></li>
</ul>
</section>
<section id="library-functional-overview">
<h2>3. Aperçu fonctionnel de la bibliothèque<a class="headerlink" href="#library-functional-overview" title="Lien vers cette rubrique">¶</a></h2>
<p><strong>Manipulation des couleurs</strong></p>
<ul class="simple">
<li><p><strong>Conversions de couleurs</strong> : <cite>bgr</cite>, <cite>brg</cite>, <cite>grey</cite>, <cite>sepia</cite>, <cite>hsl_effect</cite>, <cite>hsv_effect</cite></p></li>
<li><p><strong>Luminosité &amp; Saturation</strong> : <cite>brightness</cite>, <cite>saturation</cite>, <cite>brightness_exclude</cite>, <cite>brightness_bpf</cite></p></li>
<li><p><strong>Inversion des couleurs</strong> : <cite>invert</cite></p></li>
</ul>
<p><strong>Effets visuels</strong></p>
<ul class="simple">
<li><p><strong>Filtres</strong> : <cite>median</cite>, <cite>sobel</cite>, <cite>bloom</cite>, <cite>posterize_surface</cite></p></li>
<li><p><strong>Distorsions</strong> : <cite>wave</cite>, <cite>swirl</cite>, <cite>fisheye</cite>, <cite>horizontal_glitch</cite>, <cite>horizontal_sglitch</cite></p></li>
<li><p><strong>Effets artistiques</strong> : <cite>painting</cite>, <cite>cartoon</cite>, <cite>dithering</cite>, <cite>dithering_atkinson</cite></p></li>
</ul>
<p><strong>Traitement d’image avancé</strong></p>
<ul class="simple">
<li><p><strong>Détection des contours &amp; Netteté</strong> : <cite>sobel</cite>, <cite>sobel_fast</cite>, <cite>sharpen</cite>, <cite>sharpen32</cite></p></li>
<li><p><strong>Fusion &amp; Composition</strong> : <cite>blend</cite>, <cite>alpha_blending</cite>, <cite>alpha_blending_inplace</cite></p></li>
<li><p><strong>Effets thermiques</strong> : <cite>heatmap</cite>, <cite>predator_vision</cite></p></li>
</ul>
<p><strong>Simulations physiques</strong></p>
<ul class="simple">
<li><p><strong>Effets d’ondulation</strong> : <cite>ripple</cite>, <cite>ripple_seabed</cite></p></li>
<li><p><strong>Convection thermique</strong> : <cite>heatconvection</cite></p></li>
<li><p><strong>Effets plasma</strong> : <cite>plasma</cite>, <cite>plasma_config</cite></p></li>
</ul>
<p><strong>Fonctions utilitaires</strong></p>
<ul class="simple">
<li><p><strong>Transformations d’image</strong> : <cite>mirroring</cite>, <cite>pixelation</cite>, <cite>bilinear</cite></p></li>
<li><p><strong>Mappage des couleurs</strong> : <cite>wavelength2rgb</cite>, <cite>custom_map</cite></p></li>
<li><p><strong>Fonctions optimisées</strong> : <cite>bgr_1d</cite>, <cite>grey_1d</cite>, <cite>invert1d</cite></p></li>
</ul>
<p><strong>Effets spéciaux</strong></p>
<ul class="simple">
<li><p><strong>Lignes de balayage TV rétro</strong> : <cite>tv_scan</cite></p></li>
<li><p><strong>Effets de sang</strong> : <cite>blood</cite></p></li>
<li><p><strong>Saleté &amp; distorsion de lentille</strong> : <cite>dirt_lens</cite></p></li>
</ul>
<p><strong>Performances &amp; optimisation</strong></p>
<ul class="simple">
<li><p><strong>Efficacité mémoire</strong> : Optimisé pour les tableaux de pixels <cite>1D</cite> et <cite>3D</cite></p></li>
<li><p><strong>Traitement parallèle</strong> : Utilise <cite>nogil</cite> pour une exécution multi-threadée**</p></li>
</ul>
</section>
<section id="target-applications">
<h2>4. Applications ciblées<a class="headerlink" href="#target-applications" title="Lien vers cette rubrique">¶</a></h2>
<p>Cette bibliothèque est idéale pour :
- <strong>Développement de jeux</strong> : Effets visuels en temps réel, distorsions, fusion
- <strong>Vision par ordinateur</strong> : Prétraitement des images pour l’apprentissage automatique et l’analyse
- <strong>Applications artistiques</strong> : Effets créatifs pour les images et les vidéos
- <strong>Visualisation scientifique</strong> : Simulation de phénomènes physiques (chaleur, ondulations)</p>
</section>
<section id="summary">
<h2>5. Résumé<a class="headerlink" href="#summary" title="Lien vers cette rubrique">¶</a></h2>
<p>Cette bibliothèque basée sur Cython est un outil puissant pour le traitement d’images, combinant des optimisations haute performance avec une large gamme d’effets visuels et de transformations. Elle est particulièrement adaptée aux applications en temps réel et haute performance, en faisant un outil essentiel pour les développeurs de jeux, les ingénieurs en vision par ordinateur et les professionnels de la création.</p>
</section>
<section id="cython-list-methods">
<h2>6. Méthodes de liste en Cython<a class="headerlink" href="#cython-list-methods" title="Lien vers cette rubrique">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr" title="Lien vers cette définition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convertit une image du format RGB(A) au format BGR(A) (en place). Convertit l’affichage du jeu, l’image ou la surface du format RGB(A) au format BGR(A). Le canal alpha sera ignoré dans le processus, mais il est conservé dans le cas d’une surface 32 bits.</p>
<p>Le format RGB est couramment utilisé dans les applications d’édition et d’affichage d’images, où l’ordre est rouge, vert et bleu. En revanche, le format BGR est souvent utilisé dans les applications de traitement d’images, où l’ordre est bleu, vert et rouge.</p>
<p><strong>Remarque</strong> : Cette fonction fonctionne en place, ce qui signifie qu’elle modifie la surface d’origine.</p>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (Surface Pygame) Surface Pygame (affichage ou image) avec un format compatible (24 bits ou 32 bits, avec ou sans transparence/canal alpha).</p>
<p><strong>Retour :</strong></p>
<p>void ; modifie la surface en place.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_copy" title="Lien vers cette définition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convertit une image du format RGB(A) au format BGR(A) et retourne une nouvelle surface (copie). Cette fonction convertit les données de pixels d’une image d’entrée du format RGB(A) au format BGR(A). Le canal alpha (s’il est présent) sera conservé, mais l’ordre des canaux de couleur est inversé de RGB à BGR. Cela est utile lors de l’utilisation de bibliothèques de traitement d’image qui attendent le format BGR (comme OpenCV), alors que le format RGB est couramment utilisé dans les applications d’affichage et d’édition d’images.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">bgr_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (Surface Pygame) Un objet Surface Pygame représentant l’image. La surface peut être au format 24 bits ou 32 bits (avec ou sans canal alpha). La fonction suppose que l’image est au format RGB(A) et la convertira en BGR(A).</p>
<p><strong>Retour :</strong></p>
<p>Un nouvel objet Surface Pygame avec le format de pixels converti en BGR(A).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_3d" title="Lien vers cette définition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convertit un tableau RGB(A) (forme : w, h, n) avec un type de données uint8 en format BGR(A) (en place). Cette fonction traite directement un tableau 3D (comme une image ou une surface) du format RGB(A) au format BGR(A). Elle suppose que le tableau d’entrée est au format RGB ou RGBA, et elle inverse les canaux rouge et bleu pour le convertir respectivement en BGR ou BGRA. L’opération est effectuée en place, modifiant ainsi le tableau d’origine.</p>
<p>RGB est l’ordre de couleurs couramment utilisé dans les applications d’affichage et d’édition d’images, où les canaux de couleur sont disposés en rouge, vert, bleu. En revanche, le format BGR est souvent utilisé dans les applications de traitement d’images, où les canaux de couleur sont disposés en bleu, vert, rouge.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_3d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau numpy 3D de forme (w, h, n), où <cite>w</cite> est la largeur, <cite>h</cite> est la hauteur et <cite>n</cite> est le nombre de canaux (3 pour RGB, 4 pour RGBA). Le tableau doit être de type uint8 (valeurs comprises entre 0 et 255) et contenir des données de pixels au format RGB(A).</p>
<p><strong>Retour :</strong></p>
<p>void Cette fonction modifie le tableau d’entrée en place et ne retourne aucune valeur.</p>
<p><strong>Exceptions :</strong></p>
<p><strong>ValueError</strong> Si la forme du tableau d’entrée n’est pas compatible avec RGB(A) (c’est-à-dire s’il n’a pas la forme (w, h, 3) ou (w, h, 4)).</p>
<p><strong>TypeError</strong> Si le tableau d’entrée n’a pas le type de données uint8 (octet non signé).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d" title="Lien vers cette définition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convertit un tableau 1D de type uint8 du format RGB(A) au format BGR(A) (en place). Cette fonction traite directement un tableau 1D, en convertissant les canaux de couleur du format RGB(A) au format BGR(A). La conversion est effectuée en place, modifiant ainsi le tableau original. Le drapeau <cite>format_32</cite> détermine si l’entrée est en format RGB (24 bits) ou en format RGBA (32 bits).</p>
<p>RGB est l’ordre de couleurs standard utilisé dans de nombreuses applications d’édition et d’affichage d’images, où les canaux de couleur sont disposés en rouge, vert et bleu. En revanche, le format BGR est souvent utilisé dans le traitement d’images, où les canaux de couleur sont disposés en bleu, vert et rouge.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_1d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray ou bytearray) Un tableau 1D (ou un tampon) de données de pixels au format RGB(A), avec un type de données uint8 (valeurs comprises entre 0 et 255). La longueur du tableau doit être un multiple de 3 (pour RGB) ou de 4 (pour RGBA). Le tableau contient les valeurs de couleur des pixels qui seront converties du format RGB(A) au format BGR(A).</p>
<p><strong>format_32</strong> (bool, optionnel) Un drapeau booléen indiquant le format du tableau d’entrée. - <cite>True</cite> indique que le tableau est en “RGB” (24 bits, 3 canaux). - <cite>False</cite> (par défaut) indique que le tableau est en “RGBA” (32 bits, 4 canaux).</p>
<p><strong>Retour :</strong></p>
<p>void La fonction modifie le tableau d’entrée en place et ne retourne aucune valeur.</p>
<p><strong>Exceptions :</strong></p>
<p><strong>TypeError</strong> Si le tableau d’entrée n’a pas le type de données <cite>uint8</cite>.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convertit un tableau 1D du format RGB(A) au format BGR(A) et retourne une nouvelle copie. Cette fonction prend un tableau 1D (ou une tranche de mémoire <cite>memoryview</cite>) contenant des données de pixels dans l’ordre RGB(A) et produit un nouveau tableau 1D avec les canaux de couleur réorganisés en BGR(A). Cette conversion est utile lors de l’interfaçage avec des bibliothèques ou des routines qui attendent des pixels au format BGR(A) plutôt que dans l’ordre plus courant RGB(A).</p>
<p>La fonction suppose que le tableau d’entrée est de type uint8, et que sa longueur doit être un multiple de 3 (pour les données RGB) ou de 4 (pour les données RGBA). Le drapeau <cite>format_32</cite> indique si l’entrée contient des pixels 32 bits (<cite>True</cite> pour RGBA, <cite>False</cite> pour RGB).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_bgr_array</span> <span class="o">=</span> <span class="n">bgr_1d_cp</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray ou tranche de <cite>memoryview</cite>, forme <cite>(w,)</cite>, type <cite>uint8</cite>) Un tableau 1D ou un tampon contenant des données de pixels au format RGB(A). (Par exemple, si l’image est en RGB, la longueur du tableau doit être de 3 * nombre_de_pixels.)</p>
<p><strong>format_32</strong> (bool, optionnel) Un drapeau indiquant le format des pixels : - <cite>False</cite> (par défaut) : l’entrée est supposée être en 24 bits (RGB, 3 canaux). -<cite>True</cite> : l’entrée est supposée être en 32 bits (RGBA, 4 canaux).</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau 1D (<cite>uint8</cite>) avec les données de pixels converties en ordre BGR(A).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une surface Pygame du format RGB(A) au format BRG(A) en place. Cette fonction modifie la surface donnée en échangeant les canaux de couleur rouge et vert, convertissant ainsi une image du format RGB(A) au format BRG(A). Le canal alpha, s’il est présent, est conservé mais ignoré lors du processus de conversion.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame ou une surface d’affichage compatible avec les formats de pixels 24 bits (RGB) ou 32 bits (RGBA). La fonction agit directement sur la surface fournie.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie la surface d’entrée en place et ne retourne pas de nouvelle surface.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une image du format RGB(A) au format BRG(A) et retourne une nouvelle copie. Cette fonction échange les canaux rouge et vert d’une image tout en conservant le canal bleu. Elle crée et retourne une nouvelle surface avec le format de couleur modifié, laissant la surface originale inchangée.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_surface</span> <span class="o">=</span> <span class="n">brg_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame ou une surface d’affichage au format 24 bits (RGB) ou 32 bits (RGBA). Le canal alpha (s’il est présent) sera ignoré.</p>
<p><strong>Retour :</strong></p>
<p><strong>pygame.Surface</strong> Une nouvelle surface avec les canaux de couleur convertis au format BRG.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 3D du format RGB(A) au format BRG(A) en place. Cette fonction échange les canaux rouge et vert tout en conservant les canaux bleu et alpha (s’ils sont présents). Elle modifie directement le tableau d’entrée sans créer de copie.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray, forme <cite>(w, h, n)</cite>, type <cite>uint8</cite>) Un tableau 3D représentant une image, où les valeurs des pixels varient de 0 à 255. La dernière dimension (n) doit être de 3 (RGB) ou 4 (RGBA).</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction opère en place et ne retourne pas de nouveau tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 1D de données de pixels RGB(A) au format BRG(A) en place. Cette fonction échange les canaux rouge et bleu d’un tableau d’entrée ou d’un tampon représentant des données de pixels RGB ou RGBA. Elle fonctionne avec les formats 24 bits (RGB) et 32 bits (RGBA).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_1d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>  <span class="c1"># Converts an RGB(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray ou <cite>bytearray</cite>) Un tableau 1D de forme <cite>(w,)</cite> contenant des données de pixels <cite>uint8</cite> (valeurs entre 0 et 255). Peut être soit un tableau NumPy, soit un tampon brut d’octets.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut = False) - <cite>True</cite> : traite l’entrée comme un tampon RGB (24 bits). - <cite>False</cite> : traite l’entrée comme un tampon RGBA (32 bits).</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> L’opération est effectuée en place, modifiant directement <cite>rgb_array</cite>.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 1D de données de pixels <cite>uint8</cite> BGR(A) au format BRG(A) et retourne un nouveau tableau. Contrairement à la version en place (<cite>brg_1d</cite>), cette fonction crée et retourne un nouveau tableau avec les canaux rouge et bleu échangés.</p>
<p>BRG signifie Bleu, Rouge, Vert.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_array</span> <span class="o">=</span> <span class="n">brg_1d_cp</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>  <span class="c1"># Converts an BGR(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray ou <cite>bytearray</cite>) Un tableau 1D de forme <cite>(w,)</cite> contenant des données de pixels <cite>uint8</cite> (valeurs entre 0 et 255). Peut être soit un tableau NumPy, soit un tampon brut d’octets.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut = False) - <cite>True</cite> : traite l’entrée comme un tampon BGR (24 bits). - <cite>False</cite> : traite l’entrée comme un tampon BGRA (32 bits).</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau de forme <cite>(w,)</cite> avec le format de pixels BRG(A) (copié).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une image en niveaux de gris tout en préservant la luminosité (en place). Une image en niveaux de gris possède un seul canal représentant l’intensité ou la luminosité des pixels, avec des valeurs variant de 0 (noir) à 255 (blanc). Cette fonction calcule les valeurs en niveaux de gris en se basant sur la luminosité, préservant ainsi la perception de la luminosité de l’image couleur d’origine.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grey</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame ou un objet compatible avec une surface d’affichage, contenant une image au format 24 bits ou 32 bits. La surface peut inclure de la transparence ou un canal alpha.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie la surface d’entrée en place et ne retourne pas de nouvelle surface.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une image en niveaux de gris tout en préservant la luminosité et retourne une nouvelle surface. Une image en niveaux de gris possède un seul canal représentant l’intensité ou la luminosité des pixels, avec des valeurs variant généralement de 0 (noir) à 255 (blanc). Cette fonction convertit l’image d’origine en niveaux de gris en se basant sur la luminosité, préservant ainsi la perception de la luminosité de l’image couleur. Le canal alpha est conservé dans les images avec transparence (format RGBA), mais il n’est pas modifié.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">grey_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame ou un objet compatible avec une surface d’affichage, contenant une image au format 24 bits ou 32 bits. La surface peut inclure de la transparence (canal alpha).</p>
<p><strong>Retour :</strong></p>
<p><strong>pygame.Surface</strong> Un nouvel objet surface contenant l’image en niveaux de gris. La surface d’origine reste inchangée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_2d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_2d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une image en un tableau 2D en niveaux de gris. Une image en niveaux de gris possède un seul canal représentant l’intensité ou la luminosité des pixels, avec des valeurs variant généralement de 0 (noir) à 255 (blanc). Cette fonction convertit l’image d’entrée en niveaux de gris en se basant sur la luminosité, en préservant l’intensité de l’image couleur d’origine. Le canal alpha, s’il est présent, sera ignoré dans le résultat.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gray</span> <span class="o">=</span> <span class="n">grey_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame ou un objet compatible avec une surface d’affichage, contenant une image au format 24 bits ou 32 bits. La surface peut inclure de la transparence (canal alpha), qui sera ignorée lors de la conversion.</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un tableau NumPy 2D contenant les données de l’image en niveaux de gris. Le tableau aura la forme <cite>(w, h)</cite> et le type <cite>uint8</cite>, où chaque valeur représente l’intensité des pixels.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 3D (w, h, n) au format RGB(A) en niveaux de gris (avec alpha) en place. Cette fonction traite directement un tableau 3D, le convertissant en niveaux de gris sur la base de la luminosité tout en préservant le canal alpha (s’il est présent). Les valeurs des pixels dans le tableau de niveaux de gris résultant représentent l’intensité ou la luminosité, allant de 0 (noir) à 255 (blanc).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit image/surface</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

<span class="c1"># For a 32-bit image with alpha channel</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau NumPy 3D de forme (w, h, n) avec le type <cite>uint8</cite>, contenant des données de pixels au format RGB(A). Les valeurs dans le tableau vont de 0 à 255. Pour les tableaux 32 bits (RGBA), le canal alpha sera préservé mais ignoré lors de la conversion en niveaux de gris.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie le tableau d’entrée en place et ne retourne pas de nouveau tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 1D de données uint8 (RGB(A)) en niveaux de gris (avec alpha) en place. Une image en niveaux de gris possède un seul canal représentant l’intensité ou la luminosité des pixels, avec des valeurs généralement comprises entre 0 (noir) et 255 (blanc). Cette fonction convertit le tableau RGB(A) d’entrée en niveaux de gris tout en préservant le canal alpha (s’il est présent). La conversion est effectuée en place, modifiant le tableau d’origine.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit buffer (RGB)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># For a 32-bit buffer (RGBA)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">PIL</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">size</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">getdata</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">arr</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Définissez <cite>format_32</cite> sur <cite>True</cite> si le tableau est un tampon 32 bits contenant des valeurs RGBA.</p>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray ou bytearray) Un tableau 1D ou un tampon contenant des données de pixels au format RGB(A), avec le type <cite>uint8</cite> (valeurs de type char non signées allant de 0 à 255).</p>
<p><strong>format_32</strong> (booléen, optionnel) Si <cite>True</cite>, la fonction considère que l’entrée est un tampon 32 bits (RGBA). Si <cite>False</cite>, la fonction considère un tampon 24 bits (RGB).</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie le tableau d’entrée en place et ne retourne pas de nouveau tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit un tableau 1D de données BGR(A) uint8 en niveaux de gris (avec canal alpha) et retourne une copie. Cette fonction vérifie que le tableau d’entrée a le type de données uint8 attendu, puis convertit les données des pixels du format BGR ou BGRA en niveaux de gris. La conversion préserve le canal alpha (s’il est présent). Elle retourne un nouveau tableau NumPy 1D au format niveaux de gris.</p>
<p>La conversion en niveaux de gris est basée sur la formule de luminosité, qui calcule la luminosité en fonction des canaux rouge, vert et bleu.</p>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tableau 1D contenant des données de pixels au format BGR(A), avec le type <cite>uint8</cite>. Les valeurs des pixels doivent être comprises entre 0 et 255. Si le tableau représente une image BGRA, le canal alpha sera préservé.</p>
<p><strong>format_32</strong> (booléen, optionnel) Si <cite>True</cite>, le tableau d’entrée est supposé être au format BGRA (32 bits). Si <cite>False</cite>, le tableau est supposé être au format BGR (24 bits).</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau 1D NumPy de forme (w,) avec le type <cite>uint8</cite>, contenant les données des pixels en niveaux de gris. Si l’entrée était au format BGRA, le canal alpha est préservé dans la sortie.</p>
<p><strong>Exceptions :</strong></p>
<p><strong>TypeError</strong> Si le tableau d’entrée n’a pas le type <cite>uint8</cite>, une <cite>TypeError</cite> sera levée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre sépia à une image, une surface ou des graphiques de jeu vidéo (en place). Le ton sépia est une technique utilisée en photographie et en imagerie où l’image reçoit une teinte rouge-brun, simulant les tons chauds des anciennes photographies. Il crée une esthétique plus douce et rêveuse par rapport aux niveaux de gris standard, ajoutant de la profondeur et un aspect vintage.</p>
<p>Cette fonction transforme la surface fournie en un modèle équivalent au ton sépia, ajustant les couleurs des pixels en conséquence tout en préservant la structure originale. La transformation est appliquée directement à la surface (en place), et aucune nouvelle surface n’est retournée.</p>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sepia</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Modèle sépia (Nouvelle surface)</p>
<p>Transformez votre jeu vidéo/image ou surface en un modèle équivalent sépia.</p>
<p>Tandis que les photographies noir et blanc traditionnelles utilisent un niveau de gris standard pour créer des zones claires et sombres, les photographies sépia utilisent une teinte rouge-brun pour créer ce spectre. « Le sépia est une manipulation plus douce de la lumière. » Ce qui leur donne une esthétique plus douce et rêveuse.</p>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">sepia_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre sépia à un tableau d’image 3D RGB(A) (en place).</p>
<p>Cette fonction traite un tableau 3D NumPy représentant les données de pixels au format RGB(A) et applique un filtre sépia. L’effet sépia est obtenu en ajustant les canaux rouge, vert et bleu selon des coefficients prédéfinis, créant un effet vintage aux tons chauds. La fonction modifie directement le tableau d’entrée et ne retourne rien.</p>
<p>Seuls les tableaux ayant des formes (w, h, 3) pour RGB ou (w, h, 4) pour RGBA sont pris en charge.</p>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 3D de forme (w, h, 3) pour RGB ou (w, h, 4) pour les données de pixels RGBA, où <cite>w</cite> est la largeur, <cite>h</cite> est la hauteur, et <cite>3</cite> ou <cite>4</cite> correspond aux canaux RGB ou RGBA. Le tableau doit avoir le type <cite>uint8</cite> (caractère non signé) avec des valeurs de pixels comprises entre 0 et 255.</p>
<p><strong>Exceptions :</strong></p>
<p><strong>ValueError</strong> Si le tableau d’entrée n’a pas la forme attendue (w, h, 3) ou (w, h, 4).</p>
<p><strong>TypeError</strong> Si le tableau d’entrée n’a pas le type <cite>uint8</cite>.</p>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction modifie directement le tableau <cite>rgb_array</cite> d’entrée (en place).</p></li>
<li><p>Si l’entrée est au format RGBA, le canal alpha est préservé.</p></li>
<li><p>L’effet sépia est appliqué en ajustant la luminosité des canaux RGB à l’aide d’un ensemble de coefficients.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assuming rgb_array is a 3D NumPy array with shape (w, h, 3) for RGB or (w, h, 4) for RGBA:</span>
<span class="n">sepia_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertir un tableau 1D de données uint8 (RGB(A)) en équivalent sépia (en place).</p>
<p>Tandis que les photographies noir et blanc traditionnelles utilisent un niveau de gris standard pour créer des zones claires et sombres, les photographies sépia utilisent une teinte rouge-brun pour créer ce spectre. « Le sépia est une manipulation plus douce de la lumière, » créant une esthétique plus douce et rêveuse.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Pour une image 24 bits (RGB) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour une image 32 bits (RGBA) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>ou</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 1D de forme (w,) contenant des données de pixels uint8 (valeurs allant de 0 à 255) au format RGB(A). Peut être soit un tableau NumPy soit un tampon brut de bytes.</p>
<p><strong>format_32</strong> (booléen, optionnel, valeur par défaut=False) Si <cite>True</cite>, l’entrée est traitée comme un tampon RGB 24 bits. Si <cite>False</cite>, l’entrée est traitée comme un tampon RGBA 32 bits.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie le tableau d’entrée en place et ne retourne pas un nouveau tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre médian à une surface (en place).</p>
<p>Le filtre médian est une technique de filtrage d’image non linéaire couramment utilisée pour éliminer le bruit d’une image ou d’un signal. Il fonctionne en remplaçant chaque valeur de pixel par la médiane des valeurs de pixel dans un voisinage défini par la taille du noyau. Cette technique est largement utilisée pour la réduction du bruit dans le traitement d’image numérique, surtout pour préserver les bords tout en éliminant le bruit.</p>
<p>La force de l’effet est contrôlée par le paramètre <cite>kernel_size</cite>, avec des tailles de noyau plus grandes produisant des effets de filtrage plus forts. Cependant, des tailles de noyau plus grandes peuvent également ralentir considérablement le processus.</p>
<p><strong>Note :</strong> Ce filtre n’est pas adapté pour le rendu en temps réel dans les jeux ou animations en raison de son coût computationnel.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Pour une image 24 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour une image 32 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Un objet surface Pygame (24 bits ou 32 bits) contenant l’image à traiter. Il peut avoir ou non un canal alpha pour la transparence.</p>
<p><strong>kernel_size_</strong> (entier court non signé, optionnel, valeur par défaut=2) La taille du noyau ou du voisinage des pixels utilisés pour le calcul de la médiane. Augmenter la taille du noyau améliore l’effet du filtre, mais diminue les performances.</p>
<p><strong>fast_</strong> (booléen, optionnel, valeur par défaut=True) Un indicateur pour activer le calcul rapide. Si <cite>True</cite>, le filtre utilise une taille de texture plus petite pour améliorer les performances, ce qui peut réduire la qualité en fonction de l’argument <cite>reduce_factor_</cite>.</p>
<p><strong>reduce_factor_</strong> (entier court non signé, optionnel, valeur par défaut=1) Un facteur pour réduire la taille de la surface avant traitement. Une valeur de 1 divise la surface par 2, et une valeur de 2 réduit la surface de 4. Des valeurs supérieures à 2 peuvent dégrader la qualité de l’image. N’a aucun effet si <cite>fast_</cite> est <cite>False</cite>.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie directement la surface (en place) et ne retourne pas de valeur.</p>
<p><strong>Exceptions :</strong></p>
<p><strong>ValueError</strong> Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite> valide ou si les <cite>kernel_size_</cite> ou <cite>reduce_factor_</cite> sont hors des plages valides.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.painting">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">painting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.painting" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de peinture (en place) à une surface Pygame.</p>
<p>Cette fonction transforme une image pour lui donner un style artistique ressemblant à une peinture à la main. Elle y parvient en utilisant un algorithme de filtre médian rapide (<cite>median_fast</cite>), qui lisse les valeurs de pixels tout en maintenant les détails des bords, donne à l’image une apparence similaire à celle de coups de pinceau.</p>
<p><strong>Note :</strong> - Cette méthode <strong>modifie la surface d’entrée en place</strong>. - Elle <strong>n’est pas optimisée pour le rendu en temps réel</strong> et est destinée au traitement hors ligne des images.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Pour une image 24 bits ou 32 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">painting</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits), avec ou sans transparence par pixel (canal alpha).</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie directement la surface d’entrée.</p>
<p><strong>Exceptions :</strong></p>
<p>ValueError Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite> valide.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixels" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de pixelisation à une image (EN PLACE).</p>
<p>La pixelisation est un effet visuel où une image est affichée à une faible résolution, rendant les pixels individuels (petits éléments carrés de couleur unie) clairement visibles. Cette technique est souvent utilisée dans les graphiques numériques pour créer des styles artistiques, censurer des parties d’une image, ou simuler des graphiques rétro de jeux vidéo à faible résolution.</p>
<p>Cette fonction modifie la surface d’entrée en place, réduisant les détails fins et mettant en évidence les structures de pixels carrés.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Pour les images 24 bits et 32 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Rescale image</span>
<span class="n">pixels</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c1"># Apply pixelation effect</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (image 24 bits ou 32 bits) avec ou sans transparence par pixel (canal alpha).</p>
<p><strong>Retour :</strong></p>
<p>None La surface d’entrée est modifiée directement (en place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median_grayscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median_grayscale" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre médian à une version en niveaux de gris de l’image (EN PLACE).</p>
<p>Le <strong>filtre médian</strong> est une technique de filtrage numérique non linéaire couramment utilisée pour éliminer le bruit des images tout en préservant les bords. Il est largement utilisé dans le traitement d’image numérique comme étape de pré-traitement pour des tâches telles que la détection de bords et la segmentation.</p>
<p>Cette fonction convertit la surface d’entrée en niveaux de gris et applique un effet de filtre médian. La force de l’effet de filtrage est contrôlée par le paramètre <cite>kernel_size_</cite>.</p>
<p>⚠ <strong>Note</strong>: - Cette méthode <strong>modifie la surface en place</strong>. - Elle n’est <strong>pas adaptée au rendu en temps réel</strong>. - Compatible avec des <strong>surfaces 24 bits et 32 bits</strong>, avec ou sans un canal alpha.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Appliquer un filtre médian à une image 24 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p>Appliquer un filtre médian à une image 32 bits (avec canal alpha) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits, avec ou sans alpha).</p>
<p><strong>kernel_size_</strong> (int, optionnel, valeur par défaut=2) La taille du noyau (voisinage des pixels considérés pour le filtrage). Doit être supérieur à 0. Augmenter la taille du noyau améliore l’effet de filtrage mais impacte considérablement les performances.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie directement la surface d’entrée (en place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.posterize_surface">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">posterize_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.posterize_surface" title="Lien vers cette définition">¶</a></dt>
<dd><p>Réduire le nombre de couleurs dans une image (EN PLACE).</p>
<p>Cette fonction réduit le nombre de couleurs uniques dans la surface donnée, créant ainsi un effet de postérisation. Réduire le nombre de couleurs peut être utile pour des effets artistiques, la compression d’images ou un pré-traitement pour des graphiques stylisés.</p>
<p>⚠ <strong>Note</strong>: - <strong>Modifie la surface en place</strong>. - <strong>Fonctionne avec des surfaces 24 bits et 32 bits</strong>, avec ou sans un canal alpha. - Si la surface a un <strong>canal alpha par pixel 32 bits</strong>, le canal alpha sera ignoré, ce qui signifie que l’effet est appliqué uniquement aux valeurs RGB.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Réduire le nombre de couleurs dans une surface Pygame à 8 :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">color_reduction</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits, avec ou sans alpha).</p>
<p><strong>color_</strong> (int, optionnel, valeur par défaut=8) Le nombre de couleurs auquel réduire l” image. Doit être supérieur à 0. Des valeurs plus faibles produisent un effet plus dramatique.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie directement la surface d’entrée (en place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer la détection de bords de Sobel (en place)</p>
<p>L’opérateur Sobel, également connu sous le nom d’opérateur Sobel-Feldman, est couramment utilisé dans le traitement d’image pour la détection de bords. Il met en évidence les bords dans une image en accentuant les zones avec de forts gradients d’intensité.</p>
<p>Cette fonction applique la détection de bords de Sobel à une surface Pygame, transformant la surface pour mettre en évidence ses bords en fonction du gradient des intensités des pixels.</p>
<p>La surface d’entrée doit être en niveaux de gris (24 - 32 bits) pour de meilleurs résultats. Si la surface n’est pas en niveaux de gris, seul le canal rouge sera utilisé pour la détection des bords.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Appliquer la détection de bords de Sobel avec un seuil de 64 :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Un objet Pygame.Surface (profondeur 24 - 32 bits), qui peut ou non avoir un canal alpha. La surface doit être en niveaux de gris, bien que les images non en niveaux de gris utiliseront le canal rouge pour la détection des bords.</p>
<p><strong>threshold_</strong> (int, optionnel, valeur par défaut=64) Un entier représentant le seuil pour la détection des bords. Le seuil détermine la sensibilité de la détection des bords, des valeurs plus élevées nécessitant des gradients plus forts pour être considérés comme un bord.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie la surface d’entrée en place, la mettant à jour avec le résultat de la détection de bords de Sobel.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">greyscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer la détection de bords de Sobel 1D (en place)</p>
<p>Cette fonction applique l’opérateur Sobel 1D à une image (ou surface) donnée, mettant en évidence les bords dans la direction horizontale ou verticale en fonction du gradient des intensités des pixels. Elle modifie les tampons d’entrée en place.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<p>Pour une image 24 bits :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">grey</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Pour une image 32 bits (avec alpha) :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>w</strong> (int) Largeur de la surface Pygame que le tableau source (<cite>bgr_array</cite>) référence.</p>
<p><strong>h</strong> (int) Hauteur de la surface Pygame que le tableau source (<cite>bgr_array</cite>) référence.</p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tampon C 1D de type uint8 contenant les données des pixels au format BGR. Si l’image n’est pas en niveaux de gris, l’algorithme traite les trois canaux RGB. Si les niveaux de gris sont activés, seul le canal bleu est utilisé pour la détection des bords.</p>
<p><strong>tmp_array</strong> (numpy.ndarray, optionnel) Un tampon C 1D de type uint8 contenant des données de pixels au format BGR. C’est une copie du tableau source <cite>bgr_array</cite>. Les tableaux <cite>bgr_array</cite> et <cite>tmp_array</cite> doivent avoir la même taille et le même format de données. Il est utilisé comme tampon temporaire lors du traitement.</p>
<p><strong>threshold</strong> (int, optionnel, valeur par défaut=64) Le seuil pour la détection des bords. Les pixels ayant des valeurs de gradient supérieures à ce seuil seront considérés comme des bords.</p>
<p><strong>format_32</strong> (bool, optionnel, valeur par défaut=False) Si <cite>True</cite>, le tableau d’entrée est supposé être au format 32 bits BGRA. Si <cite>False</cite>, le tableau d’entrée est supposé être au format 24 bits BGR.</p>
<p><strong>greyscale</strong> (bool, optionnel, valeur par défaut=False) Si <cite>True</cite>, l’algorithme traite uniquement le canal bleu pour la détection des bords, ce qui peut simplifier le calcul pour les images en niveaux de gris. Si <cite>False</cite>, les trois canaux RGB sont utilisés dans l’opérateur Sobel.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie les tampons d’entrée (<cite>bgr_array</cite> et <cite>tmp_array</cite>) en place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_fast" title="Lien vers cette définition">¶</a></dt>
<dd><p>Sobel rapide (en place)</p>
<p>L’opérateur Sobel, parfois appelé opérateur Sobel–Feldman ou filtre Sobel, est utilisé dans le traitement d’image et la vision par ordinateur, notamment dans les algorithmes de détection de bords où il crée une image mettant en évidence les bords.</p>
<p>Cette fonction transforme l’affichage du jeu ou une surface Pygame en un modèle équivalent de Sobel. Elle est plus rapide que l’opérateur Sobel standard (<cite>sobel_inplace_c</cite>) car elle réduit la taille du tableau contenant tous les pixels et applique l’algorithme Sobel à un échantillon plus petit. Après traitement, le tableau est redimensionné à ses dimensions d’origine. Bien que cette méthode soit théoriquement plus rapide, la réduction et l’agrandissement d’un tableau entraînent une diminution de la qualité globale de l’image (par exemple, des lignes dentelées, pas d’anti-crénelage).</p>
<p><strong>Compatible avec des surfaces 24 bits et 32 bits</strong>, avec ou sans couche alpha. La surface doit être en niveaux de gris, mais les images non en niveaux de gris fonctionneront également ; en revanche, seul le canal rouge sera utilisé pour la détection des bords de Sobel.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel_fast</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits) avec ou sans couche alpha.</p>
<p><strong>threshold_</strong> (int, optionnel, valeur par défaut=64) Un entier représentant le seuil pour la détection des bords. Les pixels ayant des valeurs de gradient supérieures à ce seuil sont considérés comme des bords.</p>
<p><strong>factor_</strong> (entier non signé court, optionnel, valeur par défaut=1) Un entier qui contrôle le facteur de réduction de l’image. Une valeur de 1 signifie qu’il n’y a pas de réduction, et des valeurs plus grandes réduisent la taille de l’image avant le traitement.</p>
<p><strong>Retour :</strong></p>
<p>None Cette fonction modifie directement la surface d’entrée (en place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverser les pixels (en place)</p>
<p>Inverser une image signifie inverser les valeurs des pixels. Les images sont représentées en utilisant des valeurs RGB ou Rouge-Vert-Bleu, où chaque canal peut avoir une valeur entière entre 0 et 255 (inclus). Par exemple, le rouge est représenté comme (255, 0, 0), le blanc comme (255, 255, 255), le noir comme (0, 0, 0), etc. Inverser une image signifie inverser les couleurs. Par exemple, la couleur inversée pour le rouge sera (0, 255, 255), où 255 devient 0 et 0 devient 255. Effectivement, inverser une image équivaut à soustraire les valeurs RGB d’origine de 255.</p>
<p><strong>Compatible avec des surfaces 24 bits et 32 bits</strong>, avec ou sans canal alpha.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">invert</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits) avec ou sans canal alpha.</p>
<p><strong>Retour :</strong></p>
<p>None Cette fonction modifie directement la surface d’entrée (en place).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverser les pixels et retourner une copie</p>
<p>Inverser une image signifie inverser les valeurs des pixels. Les images sont représentées en utilisant des valeurs RGB ou Rouge-Vert-Bleu, où chaque canal peut avoir une valeur entière entre 0 et 255 (inclus). Par exemple, le rouge est représenté comme (255, 0, 0), le blanc comme (255, 255, 255), le noir comme (0, 0, 0), etc. Inverser une image signifie inverser les couleurs. Par exemple, la couleur inversée pour le rouge sera (0, 255, 255), où 255 devient 0 et 0 devient 255. Effectivement, inverser une image équivaut à soustraire les valeurs RGB d’origine de 255.</p>
<p><strong>Compatible avec des surfaces 24 bits et 32 bits</strong>, avec ou sans canal alpha.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inv</span> <span class="o">=</span> <span class="n">invert_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface compatible Pygame (24 bits ou 32 bits) avec ou sans canal alpha.</p>
<p><strong>Retour :</strong></p>
<p>(pygame.Surface) Une nouvelle surface avec les pixels inversés, laissant la surface originale inchangée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverser les pixels d’un tableau 3D (en place)</p>
<p>Inverser une image signifie inverser les valeurs des pixels. Les images sont représentées en utilisant des valeurs RGB ou Rouge-Vert-Bleu, où chaque canal peut avoir une valeur entière entre 0 et 255 (inclus). Par exemple, le rouge est représenté comme (255, 0, 0), le blanc comme (255, 255, 255), le noir comme (0, 0, 0), etc. Inverser une image signifie inverser les couleurs. Par exemple, la couleur inversée pour le rouge sera (0, 255, 255), où 255 devient 0 et 0 devient 255. Effectivement, inverser une image équivaut à soustraire les valeurs RGB d’origine de 255.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 3D de forme (w, h, n), où <cite>w</cite> et <cite>h</cite> représentent la largeur et la hauteur de l’image, et <cite>n</cite> est le nombre de canaux (par exemple, 3 pour RGB, 4 pour RGBA). Le tableau contient des données de pixels au format RGB(A) ou formats similaires, comme BGR, BGRA.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie le tableau d’entrée en place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverser directement les valeurs des pixels d’un tampon C</p>
<p>Inverser une image signifie inverser les valeurs des pixels. Les images sont représentées en utilisant des valeurs RGB ou Rouge-Vert-Bleu, où chaque canal peut avoir une valeur entière entre 0 et 255 (inclus). Par exemple, le rouge est représenté comme (255, 0, 0), le blanc comme (255, 255, 255), le noir comme (0, 0, 0), etc. Inverser une image signifie inverser les couleurs. Par exemple, la couleur inversée pour le rouge sera (0, 255, 255), où 255 devient 0 et 0 devient 255. Effectivement, inverser une image équivaut à soustraire les valeurs RGB d’origine de 255.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 1D (tampon C) avec un type de données uint8 contenant des données de pixels au format RGB(A). La méthode fonctionne avec d’autres formats tels que BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (booléen, optionnel, valeur par défaut=False) Si <cite>True</cite>, le tableau est considéré comme étant au format RGBA (32 bits). Si <cite>False</cite>, le tableau est considéré comme étant au format RGB (24 bits).</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie le tableau d’entrée en place.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverser directement les valeurs des pixels d’un tampon C (retourner une copie)</p>
<p>Inverser une image signifie inverser les valeurs des pixels. Les images sont représentées en utilisant des valeurs RGB ou Rouge-Vert-Bleu, où chaque canal peut avoir une valeur entière entre 0 et 255 (inclus). Par exemple, le rouge est représenté comme (255, 0, 0), le blanc comme (255, 255, 255), le noir comme (0, 0, 0), etc. Inverser une image signifie inverser les couleurs. Par exemple, la couleur inversée pour le rouge sera (0, 255, 255), où 255 devient 0 et 0 devient 255. Effectivement, inverser une image équivaut à soustraire les valeurs RGB d’origine de 255.</p>
<p>Cette fonction retourne une copie du tableau d’entrée avec les valeurs des pixels inversées.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 1D (tampon C) avec un type de données uint8 contenant des données de pixels au format RGB(A). La méthode fonctionne avec d’autres formats tels que BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (booléen, optionnel, valeur par défaut=False) Si <cite>True</cite>, le tableau est considéré comme étant au format RGBA (32 bits). Si <cite>False</cite>, le tableau est considéré comme étant au format RGB (24 bits).</p>
<p><strong>Retour :</strong></p>
<p>numpy.ndarray Un tableau 1D avec un type de données uint8, représentant une copie du tampon d’entrée avec les valeurs des pixels inversées.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl_effect" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer une rotation de teinte à une image (espace colorimétrique HSL)</p>
<p>Cette fonction modifie directement la teinte d’une surface Pygame en utilisant le modèle colorimétrique HSL (Teinte, Saturation, Luminosité). La rotation de la teinte déplace les couleurs de la surface de manière à correspondre à une rotation sur la roue des couleurs, vous permettant de modifier le ton global de l’image.</p>
<p>La surface doit être compatible avec une profondeur de couleur de 24 bits ou 32 bits, avec ou sans couche alpha. Si la valeur de <cite>shift</cite> est 0.0, la surface reste inchangée.</p>
<p>La valeur de décalage de la teinte doit être comprise dans la plage [0.0, 1.0], où 0.0 représente aucune rotation, et 1.0 représente une rotation complète de 360 degrés.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hsl_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift to the surface.</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec des formats de couleur 24 bits ou 32 bits (avec ou sans alpha).</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0], où 0.0 correspond à aucun décalage de teinte, et 1.0 correspond à une rotation complète de 360 degrés de la teinte.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie la <cite>surface_</cite> d’entrée en place, appliquant l’effet de rotation de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer une rotation de teinte à un tableau 3D (espace colorimétrique HSL)</p>
<p>Cette fonction applique la rotation de teinte à un tableau numpy 3D représentant une image dans l’espace colorimétrique HSL (Teinte, Saturation, Luminosité). Le décalage de teinte est appliqué directement au tableau, modifiant le ton coloré de l’image.</p>
<p>Le tableau doit avoir la forme (w, h, n), où <cite>w</cite> est la largeur, <cite>h</cite> est la hauteur, et <cite>n</cite> est le nombre de canaux de couleur (3 pour RGB ou 4 pour RGBA, etc.). Le type de données doit être uint8.</p>
<p>La valeur de <cite>shift</cite> doit être comprise dans la plage [0.0, 1.0], où 0.0 représente aucune rotation de teinte, et 1.0 représente une rotation complète de 360 degrés de la teinte.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau numpy 3D de forme (w, h, n) contenant des données de pixels RGB ou RGBA. Le tableau peut également représenter d’autres formats comme BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0], représentant la rotation de teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à un décalage complet de 360 degrés de la teinte.</p>
<p><strong>Retour :</strong></p>
<p>None La fonction modifie le <cite>rgb_array</cite> d’entrée en place, appliquant le changement de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer une rotation de teinte à un tampon C (espace colorimétrique HSL)</p>
<p>Cette fonction effectue une rotation de teinte sur un tampon C (tableau 1D) contenant des données de pixels au format RGB(A) en utilisant le modèle de couleur HSL (Teinte, Saturation, Luminosité). Elle modifie le tableau en place.</p>
<p>La fonction prend en charge des formats de pixels comme RGB, BGR, RGBA et BGRA, ajustant la teinte de chaque pixel en fonction du <cite>shift</cite> spécifié. La valeur de <cite>shift</cite> doit être dans la plage [0.0, 1.0], ce qui correspond à une rotation de 0.0 à 360.0 degrés sur la roue des couleurs de teinte.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tableau numpy 1D (tampon C) de type uint8 contenant des données de pixels au format RGB(A). Le tableau peut également représenter d’autres formats tels que BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0] représentant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut=False) Si <cite>True</cite>, le tableau d’entrée est supposé être au format RGBA 32 bits. Si <cite>False</cite>, le tableau est supposé être au format RGB 24 bits.</p>
<p><strong>Retour :</strong></p>
<p>Aucune La fonction modifie directement le <cite>bgr_array</cite> en appliquant le changement de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Faire une rotation de la teinte (HSL) directement sur un C-buffer (retourner une copie)</p>
<p>Cette fonction effectue une rotation de la teinte dans l’espace colorimétrique HSL (Teinte, Saturation, Luminosité) sur un C-buffer (tableau 1D) contenant des données de pixels au format RGB(A), retournant une copie modifiée du tableau.</p>
<p>La méthode fonctionne avec des formats de pixels comme RGB, BGR, RGBA et BGRA. La valeur du décalage de teinte (<cite>shift</cite>) doit être dans la plage [0.0, 1.0], correspondant à une rotation de 0.0 à 360.0 degrés.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tableau numpy 1D (tampon C) de type uint8 contenant des données de pixels au format RGB(A). Le tableau peut également représenter d’autres formats tels que BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0], représentant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut=False) Si <cite>True</cite>, le tableau d’entrée est supposé être au format RGBA 32 bits. Si <cite>False</cite>, le tableau est supposé être au format RGB 24 bits.</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un tableau 1D numpy de type uint8 contenant les données de pixels avec la teinte tournante.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv_effect" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer la rotation de la teinte à une surface (espace de couleur HSV)</p>
<p>Cette fonction applique une rotation de la teinte à une surface Pygame en utilisant le modèle de couleur HSV (Teinte, Saturation, Valeur). Elle modifie directement la surface, en faisant tourner la teinte des couleurs sur la surface selon le changement spécifié.</p>
<p>La surface doit être compatible avec des formats de couleur 24 bits ou 32 bits, avec ou sans canal alpha. Le décalage de teinte est spécifié comme une valeur flottante dans la plage [0.0, 1.0], où 0.0 signifie aucune modification de la teinte, et 1.0 représente une rotation complète de 360 degrés.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees (0.2 * 360)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec des formats de couleur 24 bits ou 32 bits (avec ou sans alpha).</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0], spécifiant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant le changement de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Faire une rotation de la teinte d’un tableau 3D</p>
<p>Faire une rotation de la teinte (méthode de conversion HSV), directement à partir d’un tableau 3D</p>
<p>Compatible 24 - 32 bits avec ou sans couche alpha</p>
<p>HSV (Teinte, Saturation, Valeur) est un modèle de couleur similaire à HSL (Teinte, Saturation, Luminosité) mais avec quelques différences dans la façon dont il représente et manipule les couleurs. Il est souvent utilisé dans les logiciels graphiques et les applications de vision par ordinateur en raison de sa simplicité pour spécifier et ajuster les attributs de couleur.</p>
<p>Nouvelle valeur de décalage. Doit être entre [0.0 … 1.0] correspondant à 0.0 - 360.0 degrés (par exemple 0.5 = 180 degrés)</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsv3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau numpy 3D de forme (w, h, n) contenant des données de pixels RGB ou RGBA. Le tableau peut également représenter d’autres formats comme BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0] représentant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement le <cite>rgb_array</cite> en appliquant le changement de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Faire une rotation de la teinte d’un tableau 1D</p>
<p>Faire une rotation de la teinte directement à partir d’un C-buffer (tableau 1D de types de données uint8 au format RGB(A)) Les modifications sont appliquées directement.</p>
<p>Cette méthode fonctionne avec d’autres formats de tampon tels que BGR, BGRA.</p>
<p>HSV (Teinte, Saturation, Valeur) est un modèle de couleur similaire à HSL (Teinte, Saturation, Luminosité) mais avec quelques différences dans la façon dont il représente et manipule les couleurs. Il est souvent utilisé dans les logiciels graphiques et les applications de vision par ordinateur en raison de sa simplicité pour spécifier et ajuster les attributs de couleur.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compatible with 32-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Compatible with 24-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tableau 1D numpy (C-buffer) de type uint8 contenant des données de pixels au format BGR(A). Le tableau peut également représenter d’autres formats tels que BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0] représentant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut=False) Si <cite>True</cite>, le tableau d’entrée est supposé être au format BGRA 32 bits. Si <cite>False</cite>, le tableau est supposé être au format BGR 24 bits.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement le <cite>bgr_array</cite> en appliquant le changement de teinte.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Faire une rotation de la teinte du tableau 1D (retourner une copie)</p>
<p>HSV tableau 1D (C buffer) de types de données uint8 au format RGB(A)</p>
<p>Cette méthode fonctionne avec d’autres formats de tampon tels que BGR, BGRA.</p>
<p>HSV (Teinte, Saturation, Valeur) est un modèle de couleur similaire à HSL (Teinte, Saturation, Luminosité) mais avec quelques différences dans la façon dont il représente et manipule les couleurs. Il est souvent utilisé dans les logiciels graphiques et les applications de vision par ordinateur en raison de sa simplicité pour spécifier et ajuster les attributs de couleur.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>

<span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un tableau numpy 1D (tampon C) de type uint8 contenant des données de pixels au format RGB(A). Le tableau peut également représenter d’autres formats tels que BGR, BGRA.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [0.0, 1.0] représentant la rotation de la teinte. Une valeur de 0.0 signifie aucune rotation, tandis que 1.0 correspond à une rotation complète de 360 degrés.</p>
<p><strong>format_32</strong> (bool, optionnel, par défaut=False) Si <cite>True</cite>, le tableau d’entrée est supposé être au format BGRA 32 bits. Si <cite>False</cite>, le tableau est supposé être au format BGR 24 bits.</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau 1D numpy de type uint8 contenant les pixels avec la teinte tournée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de vague à une surface (en place)</p>
<p>Cette fonction applique un effet de vague à une surface Pygame, la modifiant directement. L’effet est appliqué à la surface en fonction d’un angle (en radians) et du nombre de sous-surfaces. Il est compatible avec les surfaces 24 bits.</p>
<p>L’effet de vague crée une distorsion dynamique, semblable à une vague, souvent utilisée pour des effets visuels d’eau ou d’autres effets fluides dans les jeux.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">+</span> <span class="n">frame_number</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Animate with a changing angle</span>
<span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave with a fixed angle</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec une profondeur de couleur de 24 bits.</p>
<p><strong>rad</strong> (float) L’angle en radians pour l’effet de vague. Cette valeur contrôle le mouvement de la vague au fil du temps.</p>
<p><strong>size</strong> (int, optionnel, par défaut=5) Le nombre de sous-surfaces utilisées pour créer l’effet de vague. Un nombre plus élevé donne une vague plus complexe.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de vague.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave32" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de vague à une surface 32 bits (en place)</p>
<p>Cette fonction applique un effet de vague à une surface Pygame 32 bits, la modifiant directement. L’effet est appliqué à la fois aux canaux RGB et alpha, ce qui signifie que la vague déplacera également la couche alpha (transparence) de la surface. Elle est entièrement compatible avec les surfaces SDL 32 bits, y compris celles avec un canal alpha.</p>
<p>L’effet de vague crée une distorsion dynamique qui simule le mouvement des vagues, souvent utilisé pour des effets tels que l’eau ou le mouvement des fluides dans les jeux.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave32</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave effect with a rotating angle</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec une profondeur de couleur 32 bits et un canal alpha (RGBA).</p>
<p><strong>rad</strong> (float) L’angle en radians pour l’effet de vague, contrôlant sa rotation au fil du temps.</p>
<p><strong>size</strong> (int, optionnel, par défaut=5) Le nombre de sous-surfaces utilisées pour créer l’effet de vague. Une valeur plus élevée donne une vague plus détaillée.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de vague aux canaux de couleur et alpha.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave_static">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave_static</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave_static" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effet de vague pour un fond statique (en place)</p>
<p>Cette fonction diffère de la méthode <cite>wave</cite> car une copie de l’arrière-plan statique ou de l’affichage du jeu est passée à la fonction en tant qu’argument <cite>array_</cite> pour améliorer les performances globales.</p>
<p>Compatible avec les surfaces 24 bits.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">wave_static</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background_cp</span><span class="p">),</span> <span class="n">FRAME</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec une profondeur de couleur de 24 bits.</p>
<p><strong>array_</strong> (numpy.ndarray) Un tableau numpy 3D avec la forme (w, h, 3), de type <cite>uint8</cite>, représentant une copie de l’affichage du jeu ou de l’image à modifier.</p>
<p><strong>rad</strong> (float) L’angle en radians pour l’effet de vague, contrôlant sa rotation au fil du temps.</p>
<p><strong>size</strong> (int, optionnel, par défaut=5) Le nombre de sous-surfaces utilisées pour créer l’effet de vague. Une valeur plus élevée donne une vague plus détaillée.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement le <cite>array_</cite> d’entrée en appliquant l’effet de vague.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array_cp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl" title="Lien vers cette définition">¶</a></dt>
<dd><p>Tourner une image (en place)</p>
<p>L’effet de tourbillon est une distorsion visuelle qui crée une apparence en spirale dans une image ou un graphique. Cet effet peut attirer l’attention sur des zones spécifiques d’un design et ajouter un sens de mouvement ou de dynamisme. Il peut être utilisé de manière créative dans divers contextes, des graphiques sur les réseaux sociaux à la publicité et à l’art numérique.</p>
<p><strong>Fonctionne avec :</strong> Formats d’image 24 bits et 32 bits, mais pas compatible avec le 32 bits en raison de la couche alpha.</p>
<p>Si l’image est en 32 bits avec un canal alpha, la couche alpha restera inchangée pendant la transformation, ce qui provoque une interférence de la couche alpha sur l’effet. Pour éviter cela, convertissez l’image en 24 bits. Pour les images 32 bits avec une couche alpha, utilisez la méthode <cite>swirl32</cite> (conçue pour le 32 bits).</p>
<p>Cet algorithme utilise un tableau de cosinus et sinus pour obtenir l’effet.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># in the game loop</span>
<span class="n">swirl</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">angle</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec les formats 24 bits et 32 bits. Cependant, non compatible avec le 32 bits en raison du canal alpha.</p>
<p><strong>rgb_array_cp</strong> (numpy.ndarray) Un tableau numpy 3D avec la forme (w, h, 3), contenant des données de pixels RGB. Une copie de l’image à faire tourner. Les deux <cite>surface_</cite> et <cite>rgb_array_cp</cite> doivent avoir la même forme et le même type.</p>
<p><strong>degrés</strong> (float) L’angle en degrés pour l’effet de tourbillon.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de tourbillon.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl32" title="Lien vers cette définition">¶</a></dt>
<dd><p>Tourner une image (en place)</p>
<p><strong>Compatible avec :</strong> Formats 24 bits et 32 bits (avec ou sans couche alpha).</p>
<p>L’effet de tourbillon est une distorsion visuelle qui crée une apparence en spirale dans une image ou un graphique. Cet effet peut attirer l’attention sur des zones spécifiques d’un design et ajouter un sens de mouvement ou de dynamisme. Il peut être utilisé de manière créative dans divers contextes, des graphiques sur les réseaux sociaux à la publicité et à l’art numérique.</p>
<p>Cet algorithme utilise un tableau de cosinus et sinus pour l’approximation des angles.</p>
<p>Contrairement à la méthode <cite>swirl</cite>, <cite>swirl32</cite> prend en compte la couche alpha pendant la transformation, ce qui signifie qu’elle fonctionne avec des images 32 bits ayant une transparence par pixel, préservant ainsi le canal alpha.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirl32</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec les formats 24 bits et 32 bits, y compris les canaux alpha.</p>
<p><strong>degrés</strong> (float) L’angle en degrés pour l’effet de tourbillon.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de tourbillon.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirlf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirlf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirlf" title="Lien vers cette définition">¶</a></dt>
<dd><p>Tourner une image (en place) avec une précision en virgule flottante</p>
<p><strong>Compatible avec :</strong> Format 24 bits uniquement.</p>
<p>Cet algorithme n’utilise pas de tables de cosinus et sinus ; il calcule les angles avec une précision en virgule flottante.</p>
<p>L’effet de tourbillon est une distorsion visuelle qui crée une apparence en spirale dans une image ou un graphique. Cet effet peut attirer l’attention sur des zones spécifiques d’un design et ajouter un sens de mouvement ou de dynamisme. Il peut être utilisé de manière créative dans divers contextes, des graphiques sur les réseaux sociaux à la publicité et à l’art numérique.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirlf</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec les formats 24 bits.</p>
<p><strong>degrés</strong> (float) L’angle en degrés pour l’effet de tourbillon.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de tourbillon.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma_config">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hue_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma_config" title="Lien vers cette définition">¶</a></dt>
<dd><p>Créer un effet de plasma de base sur une surface Pygame (en place)</p>
<p><strong>Compatible avec :</strong> Surfaces 24 - 32 bits, avec ou sans couche alpha.</p>
<p>Cette fonction crée un effet de plasma qui peut être appliqué à une surface Pygame. Elle modifie directement la surface. L’effet simule des distorsions visuelles semblables au plasma en utilisant des facteurs mathématiques tels que la teinte, la saturation et la valeur.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma_config</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec les formats 24 bits ou 32 bits.</p>
<p><strong>frame</strong> (int) Une variable qui change au fil du temps, contrôlant la progression de l’effet de plasma.</p>
<p><strong>hue_</strong> (float, optionnel) Un facteur contrôlant la teinte, la valeur par défaut est 1.0/6.0.</p>
<p><strong>sat_</strong> (float, optionnel) Un facteur contrôlant la saturation, la valeur par défaut est 1.0/6.0.</p>
<p><strong>value_</strong> (float, optionnel) Un facteur contrôlant la valeur, la valeur par défaut est 1.0/8.0.</p>
<p><strong>a_</strong> (float, optionnel) Un paramètre de contrôle pour l’équation du plasma, la valeur par défaut est 1.0/255.0.</p>
<p><strong>b_</strong> (float, optionnel) Un paramètre de contrôle pour l’équation du plasma, la valeur par défaut est 1.0/12.0.</p>
<p><strong>c_</strong> (float, optionnel) Un paramètre de contrôle pour l’équation du plasma, la valeur par défaut est 1.0/12.0.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de plasma.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">palette_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer l’effet de plasma directement sur une surface</p>
<p>Cette fonction génère un effet de plasma dynamique sur une surface Pygame. L’effet évolue au fil du temps, produisant un motif visuel fluide et lumineux. L’effet de plasma est appliqué directement à la surface, modifiant ses pixels en place.</p>
<p>La fonction fonctionne avec des surfaces 24 bits et 32 bits (avec ou sans canal alpha).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">,</span> <span class="n">palette</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame, compatible avec les formats 24 bits ou 32 bits. L’effet de plasma est appliqué directement à cette surface, modifiant ses pixels en place.</p>
<p><strong>frame</strong> (float) Le numéro du cadre actuel, qui détermine l’évolution de l’effet de plasma. Cette valeur détermine les motifs changeants et l’animation dans l’effet de plasma.</p>
<p><strong>palette_</strong> (numpy.ndarray) Un tableau 1D contenant une palette de couleurs (en entiers non signés) utilisées pour générer l’effet de plasma. Les couleurs sont appliquées cycliquement pour créer l’effet visuel.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucune</strong> La fonction modifie directement la surface d’entrée en appliquant l’effet de plasma.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajuster la luminosité en place</p>
<p>Cette fonction contrôle le niveau de luminosité d’un affichage Pygame ou d’une surface SDL. Le paramètre <cite>shift_</cite> est une valeur flottante dans la plage [-1.0, 1.0], où +1.0 représente la luminosité maximale, et 0.0 n’applique aucune modification à la surface. Les valeurs négatives assombrissent la surface.</p>
<p>La fonction fonctionne avec des surfaces 24 bits et 32 bits (avec ou sans canal alpha).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits (avec ou sans un canal alpha).</p>
<p><strong>shift_</strong> (float) Une valeur flottante dans la plage [-1.0, 1.0], où +1.0 augmente la luminosité, 0.0 laisse la surface inchangée, et les valeurs négatives diminuent la luminosité.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucun</strong> La fonction modifie <cite>surface_</cite> en place en ajustant sa luminosité.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajuster la luminosité d’un tableau d’image 3D en place</p>
<p>Cette fonction ajuste la luminosité d’une image en modifiant son tableau 3D en place. Le tableau doit avoir la forme (w, h, n) où <cite>n</cite> est généralement 3 (RGB) ou 4 (RGBA). Le paramètre <cite>shift</cite> contrôle le niveau de luminosité et doit être une valeur flottante dans la plage [-1.0, 1.0]. Les valeurs positives augmentent la luminosité, les valeurs négatives la diminuent, et 0.0 n’apporte aucun changement.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau 3D numpy de forme (w, h, n), où <cite>n</cite> est le nombre de canaux de couleur (3 pour RGB ou 4 pour RGBA). Le tableau doit contenir des données uint8 (valeurs de 0 à 255 pour chaque canal de couleur).</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, 1.0] qui contrôle le niveau de luminosité. Les valeurs positives augmentent la luminosité, les valeurs négatives la diminuent, et 0.0 laisse le tableau inchangé.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucun</strong> La fonction modifie le tableau <cite>rgb_array</cite> en place en ajustant sa luminosité.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Contrôler la luminosité d’une image depuis un tampon C (en place)</p>
<p>Cette fonction ajuste la luminosité d’une image basée sur un tampon de tableau 1D. Le tampon doit représenter les données de pixels de l’image soit en format BGR(A) ou RGB(A). La luminosité est ajustée par une valeur <cite>shift</cite>, qui doit être un float dans la plage [-1.0, 1.0]. Le paramètre <cite>format_32</cite> indique si le tampon est en 32 bits (<cite>True</cite> pour BGRA) ou en 24 bits (<cite>False</cite> pour BGR).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray ou bytearray) Un tableau 1D numpy ou bytearray contenant les données des pixels en format BGR(A) ou RGB(A). Le tableau doit contenir des données uint8 (valeurs de 0 à 255 pour chaque canal de couleur).</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, 1.0] qui contrôle le niveau de luminosité. Les valeurs positives augmentent la luminosité, les valeurs négatives la diminuent, et 0.0 laisse le tableau inchangé.</p>
<p><strong>format_32</strong> (bool) Un booléen indiquant si le tampon est en 32 bits (<cite>True</cite> pour BGRA) ou en 24 bits (<cite>False</cite> pour BGR).</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucun</strong> La fonction modifie le tampon <cite>bgr_array</cite> en place en ajustant sa luminosité.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Contrôler la luminosité d’une image (retourner une copie)</p>
<p>Cette fonction ajuste la luminosité d’une image donnée son tampon C. Le <cite>bgr_array</cite> doit être un tableau 1D contenant des données de pixels en format BGR ou BGRA. La fonction retourne un nouveau tableau avec la luminosité ajustée selon la valeur de <cite>shift</cite>, qui doit être un float dans la plage [-1.0, 1.0]. Le paramètre <cite>format_32</cite> spécifie si l’image est en 32 bits (BGRA) ou en 24 bits (BGR).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray ou bytearray) Un tableau 1D numpy ou bytearray contenant les données des pixels en format BGR(A) ou RGB(A). Le tableau doit contenir des données uint8 (valeurs de 0 à 255 pour chaque canal de couleur).</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, 1.0] qui contrôle le niveau de luminosité. Les valeurs positives augmentent la luminosité, les valeurs négatives la diminuent, et 0.0 laisse le tableau inchangé.</p>
<p><strong>format_32</strong> (bool) Un booléen indiquant si le tampon est en 32 bits (<cite>True</cite> pour BGRA) ou en 24 bits (<cite>False</cite> pour BGR).</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau numpy contenant les données de pixels avec la luminosité ajustée. Le tableau original n’est pas modifié.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_copy" title="Lien vers cette définition">¶</a></dt>
<dd><p>Luminosité (retourner une copie)</p>
<p>Cette fonction applique une transformation de luminosité à une nouvelle surface SDL. Le niveau de luminosité de la surface est modifié en fonction du paramètre <cite>shift</cite>, qui est un float dans la plage [-1.0, 1.0]. Une valeur de +1.0 correspond à la luminosité maximale, tandis qu’une valeur de 0.0 laissera la surface inchangée.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">brightness_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits, avec ou sans un canal alpha.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, 1.0] qui ajuste la luminosité de la surface. Les valeurs positives augmentent la luminosité, les valeurs négatives la diminuent, et 0.0 laisse la surface inchangée.</p>
<p><strong>Retour :</strong></p>
<p><strong>pygame.Surface</strong> Une nouvelle surface Pygame avec luminosité ajustée, en format 24 bits sans canal alpha.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_exclude">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_exclude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_exclude" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajustement de la luminosité avec exclusion de couleur (en place)</p>
<p>Cette fonction modifie la luminosité d’une image, excluant une couleur spécifique du processus de transformation. Le paramètre <cite>shift_</cite> contrôle le niveau de luminosité, avec +1.0 correspondant à la luminosité maximale. L’exclusion de couleur permet d’éviter d’affecter des couleurs spécifiques pendant la transformation.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits.</p>
<p><strong>shift_</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant l’ajustement de la luminosité. +1.0 correspond à la luminosité maximale, et 0.0 laissera la surface inchangée.</p>
<p><strong>color_</strong> (tuple, optionnel) Un tuple de valeurs RGB (par exemple, (10, 22, 0)) à exclure de la transformation de luminosité. La valeur par défaut est (0, 0, 0) pour le noir.</p>
<p><strong>Retour :</strong></p>
<p><strong>Aucun</strong> Cette fonction modifie <cite>surface_</cite> en place, en ajustant sa luminosité tout en excluant la couleur spécifiée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_bpf" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajustement de la luminosité avec exclusion du bpf (en place) Cette fonction ajuste la luminosité d’une image en utilisant un filtre passe-lumière (bpf). Les pixels dont la somme RGB est inférieure au <cite>bpf_threshold</cite> spécifié sont exclus de la transformation. Cela permet d’éviter de modifier les pixels plus sombres tout en ajustant la luminosité des autres.</p>
<p>Le paramètre <cite>shift_</cite> contrôle le niveau de luminosité, +1.0 correspondant à la luminosité maximale. La fonction fonctionne avec des images en 24 bits et 32 bits.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits.</p>
<p><strong>shift_</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant l’ajustement de la luminosité. +1.0 correspond à la luminosité maximale, et 0.0 laissera la surface inchangée.</p>
<p><strong>bpf_threshold</strong> (int, optionnel) Une valeur entière dans la plage [0, 255] qui détermine le seuil pour le filtre de luminosité. Les pixels dont la somme RGB est inférieure à ce seuil ne seront pas modifiés. La valeur par défaut est 64.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie la <cite>surface_</cite> en place, ajustant sa luminosité en fonction des paramètres donnés.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajustement de la saturation (en place)</p>
<p>Cette fonction ajuste le niveau de saturation d’une surface Pygame ou d’une texture. Un <cite>shift_</cite> positif augmente la saturation, tandis qu’une valeur négative la diminue. Le décalage de saturation est appliqué en place à la surface, ce qui signifie que la surface originale est modifiée directement.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits.</p>
<p><strong>shift_</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant le niveau de saturation. Une valeur de 1.0 correspond à la saturation maximale, 0.0 laissera la surface inchangée, et -1.0 entraînera une absence de saturation des couleurs.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie la <cite>surface_</cite> en place, ajustant sa saturation.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation3d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Saturer un tableau 3D directement (en place)</p>
<p>Cette fonction ajuste le niveau de saturation d’une image en modifiant les données de son tableau 3D. Le tableau doit être au format <cite>uint8</cite> avec une forme de <cite>(w, h, 3)</cite> et doit contenir des données de pixels RGB. D’autres formats de pixels peuvent également être compatibles. L’image résultante sera en format 24 bits sans couche alpha.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un tableau numpy 3D (ou vue mémoire) avec une forme <cite>(w, h, 3)</cite> et un type <cite>uint8</cite>, contenant des données RGB ou un autre format de pixel. Il doit faire référence à une surface SDL ou des données d’image.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant le niveau de saturation. Une valeur de 1.0 correspond à la saturation maximale, 0.0 laisse l’image inchangée, et -1.0 diminue la saturation.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie le <cite>rgb_array</cite> en place, ajustant la saturation des données d’image référencées.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Saturer un tableau 1D directement (en place)</p>
<p>Cette fonction ajuste le niveau de saturation d’une image en modifiant son tampon de données 1D. Le tampon doit être au format <cite>uint8</cite> avec une forme de <cite>(w,)</cite>, et il peut contenir des formats de pixels RGB(A), BGR(A) ou d’autres. Pour les images 32 bits, le canal alpha doit être à la fin du pixel (par exemple, RGB(A) ou BGR(A)).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.3</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>buffer</strong> (numpy.ndarray ou memoryviewslice) Un tableau 1D (ou vue mémoire) avec une forme <cite>(w,)</cite> et un type <cite>uint8</cite>, contenant des données de pixels au format RGB(A), BGR(A), ou d’autres formats. Il doit faire référence à une surface SDL ou un tampon d’image.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant le niveau de saturation. Une valeur de 1.0 correspond à la saturation maximale, 0.0 laisse l’image inchangée, et -1.0 diminue la saturation.</p>
<p><strong>format_32</strong> (bool, optionnel) Un indicateur du format des pixels : - <cite>True</cite> pour “RGBA” (format 32 bits avec un canal alpha). - <cite>False</cite> pour “RGB” (format 24 bits sans alpha).</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie le <cite>buffer</cite> en place, ajustant la saturation des données d’image référencées. L’image finale conserve le même format de pixel que l’image d’entrée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Saturer une image en utilisant un C-buffer (retourner une copie)</p>
<p>Cette fonction ajuste le niveau de saturation d’une image en modifiant son tampon de données 1D et retourne un nouveau tableau avec la saturation ajustée. Le <cite>buffer</cite> doit être au format <cite>uint8</cite> avec une forme de <cite>(w,)</cite>, et peut contenir des formats de pixels RGB(A), BGR(A) ou d’autres formats. Pour les images 32 bits, le canal alpha doit être placé à la fin du format de pixel (par exemple, RGB(A) ou BGR(A)).</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>buffer</strong> (numpy.ndarray ou memoryviewslice) Un tableau 1D (ou vue mémoire) avec une forme <cite>(w,)</cite> et un type <cite>uint8</cite>, contenant des données de pixels au format RGB(A), BGR(A), ou d’autres formats. Il doit faire référence à une surface SDL ou un tampon d’image.</p>
<p><strong>shift</strong> (float) Une valeur flottante dans la plage [-1.0, +1.0] contrôlant le niveau de saturation. Une valeur de 1.0 correspond à la saturation maximale, 0.0 laisse l’image inchangée, et -1.0 diminue la saturation.</p>
<p><strong>format_32</strong> (bool, optionnel) Un indicateur du format des pixels : - <cite>True</cite> pour “RGBA” (format 32 bits avec un canal alpha). - <cite>False</cite> pour “RGB” (format 24 bits sans alpha).</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un nouveau tableau 1D avec une forme <cite>(w,)</cite> et un type <cite>uint8</cite>, contenant le même format de pixel que le tableau d’entrée, mais avec le niveau de saturation ajusté.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatconvection">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatconvection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatconvection" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convection de flux thermique</p>
<p>Cette fonction simule la convection de flux thermique (ou transfert de chaleur convectif) en appliquant une transformation gaussienne à une image, créant un effet de flux vertical. La transformation est influencée par des paramètres, tels que l’amplitude, le centre, sigma, et mu, qui modifient l’intensité et la direction de l’effet.</p>
<p>L’effet de convection peut être utilisé pour simuler des phénomènes comme la turbulence de l’air ou le flux thermique. Une variable périodique pour <cite>amplitude</cite> (par exemple, en utilisant une fonction cosinus) peut créer des effets dynamiques et changeants.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-24 bit image format</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/fire.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">3.14</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">heatconvection</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">mu</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># Restore the original image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec des formats 24 bits ou 32 bits. La transformation est appliquée directement à cette surface.</p>
<p><strong>amplitude</strong> (float) L’amplitude maximale (déplacement vertical des pixels) de la transformation gaussienne. Si l’amplitude est zéro, aucune transformation ne sera appliquée. Une fonction périodique peut être utilisée pour créer une amplitude dynamique.</p>
<p><strong>center</strong> (float, optionnel) Le centre de la transformation gaussienne. La valeur par défaut est 0.0, ce qui centre l’effet.</p>
<p><strong>sigma</strong> (float, optionnel) La valeur sigma de l’équation gaussienne. Une petite valeur crée un effet étroit, tandis qu’une valeur plus grande élargit l” effet. La valeur par défaut est 2.0.</p>
<p><strong>mu</strong> (float, optionnel) La valeur mu de l’équation gaussienne. Lorsque mu est périodique (par exemple, en utilisant une fonction cosinus), cela permet à l’effet de se déplacer horizontalement. La valeur par défaut est 0.0.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie le <cite>surface_</cite> en place, appliquant l’effet de convection thermique.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_glitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_glitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_glitch" title="Lien vers cette définition">¶</a></dt>
<dd><p>Glitch horizontal (en place)</p>
<p>Cette fonction applique un effet de glitch horizontal à une surface Pygame, déformant l’image horizontalement en fonction d’un signal défini par les paramètres donnés. L’effet est obtenu en modifiant les pixels de l’image de manière aléatoire et déformée, en fonction des paramètres de déformation, de fréquence et d’amplitude.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_glitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec des formats 24 bits ou 32 bits. La transformation est appliquée directement à cette surface.</p>
<p><strong>deformation</strong> (float) L’angle en radians qui contrôle la variation de la déformation horizontale. Cette valeur influence le motif global du glitch.</p>
<p><strong>fréquence</strong> (float) Un facteur qui amplifie la variation de l’angle. Il détermine le rythme auquel l’effet de glitch change au fil du temps.</p>
<p><strong>amplitude</strong> (float) L’amplitude de la fonction cosinus utilisée pour moduler l’effet de glitch. Une amplitude plus élevée conduit à une déformation plus intense.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie le <cite>surface_</cite> en place, appliquant l’effet de glitch horizontal.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_sglitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_sglitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_sglitch" title="Lien vers cette définition">¶</a></dt>
<dd><p>Glitch pour fond d’image statique (en place)</p>
<p>Cette fonction applique un effet de glitch horizontal à une surface Pygame, modifiant l’image en la déformant selon un signal défini par les paramètres de déformation, de fréquence et d’amplitude. Elle crée un effet de glitch spécifiquement pour les fonds d’images statiques.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_sglitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">bgr_array</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec des formats 24 bits ou 32 bits. La transformation est appliquée directement à cette surface.</p>
<p><strong>array_</strong> (numpy.ndarray) Un tableau numpy contenant une copie des pixels utilisée pour l’effet de glitch. Ce tableau sert de référence pour la transformation.</p>
<p><strong>déformation</strong> (float) L’angle en radians qui contrôle la variation de la déformation horizontale. Cette valeur détermine le degré de l’effet de glitch.</p>
<p><strong>fréquence</strong> (float) Un facteur qui amplifie la variation de l’angle, influençant le rythme auquel l’effet de glitch change au fil du temps.</p>
<p><strong>amplitude</strong> (float) L’amplitude de la fonction cosinus qui module l’effet de glitch. Une plus grande amplitude conduit à une déformation plus intense.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> La fonction modifie le <cite>surface_</cite> en place, appliquant l’effet de glitch horizontal en utilisant les paramètres fournis.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bpf" title="Lien vers cette définition">¶</a></dt>
<dd><p>BPF, filtre passe-haut lumineux (en place)</p>
<p>Cette fonction applique un filtre passe-haut lumineux à une surface Pygame, conservant uniquement les pixels les plus lumineux. Les pixels dont la luminosité est inférieure au seuil spécifié sont exclus de la surface, éclaircissant ainsi l’image.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># For 32-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec des formats 24 bits ou 32 bits. La transformation est appliquée directement à cette surface.</p>
<p><strong>seuil</strong> (int) Le seuil passe-haut lumineux, avec une valeur par défaut de 128. Les pixels dont la luminosité est inférieure à ce seuil seront exclus de la transformation.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie le <cite>surface_</cite> en place en appliquant le filtre passe-haut lumineux.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom" title="Lien vers cette définition">¶</a></dt>
<dd><p>Créer un effet bloom (en place)</p>
<p>Cette fonction applique un effet bloom à une surface Pygame ou une image. L’effet bloom éclaircit l’image et ajoute un effet lumineux autour des zones lumineuses. L’effet peut être filtré sélectivement à l’aide d’un masque, et les performances peuvent être améliorées avec l’option rapide, au prix d’une réduction de l’apparence de l’effet.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the demo_bloom_mask.py script in the Demo folder</span>
<span class="n">bloom</span><span class="p">(</span><span class="n">SCREEN</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">BPF</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Une surface Pygame compatible avec les formats 24 bits ou 32 bits. Cette surface sera transformée sur place en appliquant l’effet bloom.</p>
<p><strong>threshold_</strong> (int) Une valeur de seuil entière dans la plage [0…255]. Cette valeur est utilisée pour détecter les pixels lumineux dans la texture ou l’image pour appliquer l’effet bloom.</p>
<p><strong>fast_</strong> (bool) Une valeur booléenne qui, lorsqu’elle est définie sur <cite>True</cite>, approxime l’effet bloom pour améliorer les performances (10x - 80x), mais réduit l’intensité visuelle de l’effet. La valeur par défaut est <cite>False</cite>.</p>
<p><strong>mask_</strong> (numpy.ndarray ou memoryviewslice) Un tableau 2D de type uint8 représentant l’alpha du masque, avec une forme <cite>(w, h)</cite>. Les valeurs dans la plage [0..255] contrôlent la transparence et, par conséquent, l’application sélective de l’effet bloom. Un tableau rempli de 255 rend l’effet bloom complet, tandis qu’un tableau rempli de 0 désactive l’effet. Les valeurs intermédiaires créent des effets bloom partiels.</p>
<p><strong>Retour :</strong></p>
<p><strong>None</strong> Cette fonction modifie le <cite>surface_</cite> en place en appliquant l’effet bloom.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint" title="Lien vers cette définition">¶</a></dt>
<dd><p>Créer un modèle d’objectif fisheye contenant les coordonnées des pixels d’une surface</p>
<p>Cette fonction génère un modèle d’objectif fisheye qui contient les coordonnées des pixels de chaque pixel d’une surface donnée. Le modèle peut être utilisé pour appliquer un effet fisheye à une surface en mappant ses coordonnées dans une projection d’objectif fisheye.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>w</strong> (int) La largeur de la surface à projeter dans le modèle fisheye. La valeur doit correspondre à la largeur de la surface.</p>
<p><strong>h</strong> (int) La hauteur de la surface à projeter dans le modèle fisheye. La valeur doit correspondre à la hauteur de la surface.</p>
<p><strong>centre_x</strong> (int) La coordonnée x du centre de l’effet fisheye.</p>
<p><strong>centre_y</strong> (int) La coordonnée y du centre de l’effet fisheye.</p>
<p><strong>Retour :</strong></p>
<p><strong>numpy.ndarray</strong> Un tableau 2D de type <cite>np.uint32_t</cite> avec une forme <cite>(w, h, 2)</cite>, représentant le modèle fisheye et contenant les coordonnées de tous les pixels projetés à travers le modèle d’objectif fisheye.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint_param">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmp_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param1_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint_param" title="Lien vers cette définition">¶</a></dt>
<dd><p>Créer un modèle fisheye pour contenir les coordonnées des pixels avec des paramètres supplémentaires</p>
<p>Cette fonction génère un modèle fisheye qui contient les coordonnées des pixels d’une surface, avec la possibilité supplémentaire de contrôler l’aspect du modèle fisheye et la longueur focale.</p>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">fisheye_footprint_param</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres :</strong></p>
<p><strong>tmp_array_</strong> (numpy.ndarray) Un tableau 3D avec une forme <cite>(w, h, 2)</cite> de nombres entiers non signés. La forme de ce tableau déterminera le modèle fisheye.</p>
<p><strong>centre_x</strong> (float) La coordonnée x du centre de l’effet fisheye. Correspond à la moitié de la longueur du modèle fisheye.</p>
<p><strong>centre_y</strong> (float) La coordonnée y du centre de l’effet fisheye. Correspond à la moitié de la largeur du modèle fisheye.</p>
<p><strong>param1_</strong> (float) Un paramètre qui contrôle l’aspect du modèle fisheye. Les valeurs supérieures à 1.0 font converger l’effet vers le centre, tandis que les valeurs inférieures à 1.0 font diverger l’effet du centre.</p>
<p><strong>focal_length</strong> (float) Contrôle le type d’objectif fisheye. Les valeurs supérieures à 1.0 créent un effet de lentille divergente, tandis que les valeurs inférieures à 0 créent un effet de lentille convergente.</p>
<p><strong>Retour :</strong></p>
<p><strong>void</strong> Cette fonction effectue une transformation sur place sur le tableau <cite>tmp_array_</cite>, le mettant à jour avec les coordonnées du modèle fisheye.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisheye_model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye" title="Lien vers cette définition">¶</a></dt>
<dd><p>Afficher la surface ou le gameplay à travers un effet de lentille (sur place).</p>
<p>Compatible uniquement avec les surfaces 24 bits.</p>
<p>Un objectif fisheye est un objectif ultra grand-angle qui produit une forte distorsion visuelle destinée à créer une image panoramique ou hémisphérique large.</p>
<p>Cette fonction applique un effet de lentille fisheye en temps réel. Pour ce faire, l’algorithme utilise une transformation du modèle de lentille pré-calculée qui est stockée dans un ndarray numpy, passé en tant qu’argument <cite>fisheye_model</cite>. Le tableau <cite>fisheye_model</cite> a une forme de (w, h, 2) et contient les coordonnées des pixels de la surface après la transformation de la lentille. Toutes les calculs sont effectués en amont.</p>
<p>Utilisez la fonction <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code> pour créer le tableau pré-calculé. Cette méthode doit être appelée une seule fois.</p>
<p>La transformation de lentille fisheye est appliquée sur place.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Un objet surface compatible avec une profondeur de couleur 24 bits. - <cite>fisheye_model</cite> (numpy.ndarray) : Un tableau numpy avec la forme (w, h, 2) contenant des valeurs uint32 représentant les coordonnées des pixels transformés (<cite>x”</cite>, <cite>y”</cite>). Ces valeurs sont pré-calculées en utilisant la fonction <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code>.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La transformation est appliquée sur place, et aucune valeur n’est retournée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tv_scan">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tv_scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tv_scan" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de ligne de balayage TV sur une surface pygame (sur place).</p>
<p>L’espace entre chaque ligne de balayage peut être ajusté avec la valeur <cite>space</cite>.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tv_scan</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Un objet surface compatible avec des formats de couleur 24 bits ou 32 bits. - <cite>space</cite> (int, facultatif) : L’espace entre chaque ligne de balayage. Vous pouvez définir une valeur constante ou utiliser une variable pour un effet dynamique. La valeur par défaut est 5.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : L’effet est appliqué sur place, et aucune valeur n’est retournée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de vague sans déformation de l’arrière-plan.</p>
<p>Cette fonction simule un effet de vague sur une surface, en utilisant les états précédent et actuel de la vague, ainsi qu’une image d’arrière-plan. L’effet est appliqué sans déformer l’image d’arrière-plan, qui reste statique.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ripple</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.008</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>rows_</cite> (int) : La largeur de l’écran ou de la surface. - <cite>cols_</cite> (int) : La hauteur de l’écran ou de la surface. - <cite>previous_</cite> (numpy.ndarray) : Un tableau de flottants avec la forme (w, h) utilisé pour la transformation. Il contient l’état précédent de l’effet de vague. - <cite>current_</cite> (numpy.ndarray) : Un tableau de flottants avec la forme (w, h) utilisé pour la transformation. Il contient l’état actuel de l’effet de vague. - <cite>array_</cite> (numpy.ndarray) : Un tableau uint8 avec la forme (w, h, 3) contenant l’image d’arrière-plan statique au format RGB. Ce tableau reste inchangé. - <cite>dispersion_</cite> (float, facultatif) : Le facteur d’atténuation des vagues, qui contrôle l’intensité de l’effet de vague. Des valeurs plus élevées réduisent le rayon de l’effet de vague. La valeur par défaut est 0.008.</p>
<p><strong>Retour</strong> : - <cite>tuple</cite> : Un tuple contenant deux tableaux <cite>(current_, previous_)</cite>, qui représentent les états mis à jour des vagues. Voir la section Paramètres pour les tailles de chaque tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple_seabed">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple_seabed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple_seabed" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de vague avec déformation de l’arrière-plan.</p>
<p>Cette fonction simule un effet de vague sur une surface, où l’image d’arrière-plan est déformée dans le cadre de l’effet. La fonction utilise les états précédent et actuel de la vague, ainsi qu’une texture et une image d’arrière-plan.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span> <span class="o">=</span> <span class="n">ripple_seabed</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span>
   <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.009</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>cols_</cite> (int) : La largeur de l’écran ou de la surface. - <cite>rows_</cite> (int) : La hauteur de l’écran ou de la surface. - <cite>previous_</cite> (numpy.ndarray) : Un tableau de flottants avec la forme (w, h) utilisé pour la transformation. Il contient l’état précédent de l’effet de vague. - <cite>current_</cite> (numpy.ndarray) : Un tableau de flottants avec la forme (w, h) utilisé pour la transformation. Il contient l’état actuel de l’effet de vague. - <cite>texture_array_</cite> (numpy.ndarray) : Un tableau uint8 avec la forme (w, h, 3) contenant l’image d’arrière-plan statique au format RGB. Ce tableau reste inchangé pendant la transformation des vagues. - <cite>background_array_</cite> (numpy.ndarray) : Un tableau uint8 avec la forme (w, h, 3) contenant l’image d’arrière-plan au format RGB. Ce tableau est transformé par l’effet de vague. - <cite>dispersion_</cite> (float, facultatif) : Le facteur d’atténuation des vagues, qui contrôle l’intensité de l’effet de vague. Des valeurs plus élevées réduisent le rayon de l’effet de vague. La valeur par défaut est 0.008.</p>
<p><strong>Retour</strong> : - <cite>tuple</cite> : Un tuple contenant trois tableaux <cite>(current_, previous_, bck_array)</cite>. Les tableaux représentent les états mis à jour de l’effet de vague et de la déformation de l’arrière-plan. Voir la section Paramètres pour les tailles de chaque tableau.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatmap">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatmap" title="Lien vers cette définition">¶</a></dt>
<dd><p>Transformer une image en équivalent carte thermique (sur place).</p>
<p>Cette fonction modifie la surface de l’image donnée pour appliquer un effet de carte thermique.L’application de la transformation se fait directement sur la surface, donc aucun nouvel objet n’est retourné. Elle permet également à l’utilisateur de choisir si la carte thermique doit être dans le modèle de couleur RGB ou BGR.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, convert to an alpha surface, and apply heatmap</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Un objet pygame.Surface, généralement au format d’image 24 bits ou 32 bits (compatible avec pygame). L’image sur laquelle l’effet de carte thermique sera appliqué. - <cite>rgb_</cite> (bool, facultatif) : Si True, l’image sera transformée en carte thermique basée sur RGB. Si False, la transformation utilisera le modèle de carte thermique basé sur BGR. La valeur par défaut est True (RGB).</p>
<p><strong>Retour</strong> : - <cite>None</cite> : Cette fonction fonctionne sur place, ce qui signifie que la surface d’entrée est modifiée directement sans retourner un nouvel objet.</p>
<p><strong>Lance</strong> : - <cite>TypeError</cite> : Si <cite>surface_</cite> n’est pas un objet pygame.Surface valide.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.predator_vision">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">predator_vision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.predator_vision" title="Lien vers cette définition">¶</a></dt>
<dd><p>Simuler le mode Vision Prédateur.</p>
<p>Cette fonction simule la vision du prédateur en utilisant une série de filtres de traitement d’image. Elle applique la détection des bords de Sobel, un filtre de passage des hautes lumières (BPF), des effets de bloom et une inversion du colormap à la surface donnée. Optionnellement, elle permet d’accélérer le traitement et d’appliquer des effets de fusion.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">predator_vision</span><span class="p">(</span>
   <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sobel_threshold</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
   <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inv_colormap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters</strong>:
- <cite>surface_</cite> (pygame.Surface): A pygame.Surface object, compatible with 24-bit or 32-bit formats. This is the image to which the predator vision effect will be applied.
- <cite>sobel_threshold</cite> (int, optional): The threshold for Sobel edge detection, used to detect edges in the image. The default value is 12.
- <cite>bpf_threshold</cite> (int, optional): The threshold for the Bright Pass Filter (BPF), used to detect and highlight bright pixels. The default value is 50.
- <cite>bloom_threshold</cite> (int, optional): The intensity of the bloom effect, which adds a glow around bright pixels. The default value is 50.
- <cite>inv_colormap</cite> (bool, optional): If True, the colormap will be inverted, changing the color scheme to resemble a predator’s vision more closely. The default value is False.
- <cite>fast</cite> (bool, optional): If True, a faster processing mode is used. This will reduce the quality in exchange for faster processing time. The default value is False.
- <cite>blend</cite> (int, optional): The blending mode to apply after all effects have been processed. This can be a value from <cite>pygame.BLEND_*</cite> modes. The default is <cite>pygame.BLEND_RGB_ADD</cite>.</p>
<p><strong>Retour</strong> : - <cite>pygame.Surface</cite> : Un nouvel objet pygame.Surface avec l’effet de vision du prédateur appliqué. La surface est au format 24 bits.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blood">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blood" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de sang (sur place).</p>
<p>Cette fonction applique un effet de sang à une surface donnée en utilisant un tableau de masque qui définit le contour de l’effet de sang. La surface et le masque doivent avoir les mêmes dimensions. Le paramètre <cite>percentage</cite> détermine l’intensité de l’effet de sang, avec 1.0 représentant l’intensité maximale.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/Aliens.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">RLEACCEL</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/redvignette.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">BLOOD_MASK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels_alpha</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Then call the method in your main loop (percentage must vary over time)</span>
<span class="n">blood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">BLOOD_MASK</span><span class="p">,</span> <span class="n">percentage</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : La surface (par exemple, l’affichage du jeu) sur laquelle l’effet de sang sera appliqué. Elle doit être dans un format compatible 24 bits ou 32 bits. - <cite>mask_</cite> (numpy.ndarray ou cython.view.memoryview) : Un tableau normalisé ou une vue mémoire (forme : (w, h), type : float) représentant le masque de sang. Les valeurs doivent être dans la plage [0.0, 1.0], où 1.0 représente l’intensité maximale de l’effet. - <cite>percentage_</cite> (float) : Une valeur dans la plage [0.0, 1.0] qui détermine l’intensité de l’effet de sang. Une valeur de 1.0 applique l’effet complet, tandis que 0.0 n’applique aucun effet.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La fonction modifie la surface donnée sur place (c’est-à-dire qu’elle n’a pas de valeur de retour).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring_array">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring_array" title="Lien vers cette définition">¶</a></dt>
<dd><p>Retourner un tableau numpy miroir.</p>
<p>Cette méthode retourne un numpy.ndarray avec des pixels inversés, retournant l’image le long de l’axe horizontal. Le tableau de sortie a la même forme et le même type que l’entrée, avec les valeurs des pixels inversées.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rgb_array</span> <span class="o">=</span> <span class="n">mirroring_array</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">make_surface</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>rgb_array</cite> (numpy.ndarray) : Un tableau avec la forme (w, h, 3) de type uint8, contenant RGB ou tout autre format de pixel (comme BGR).</p>
<p><strong>Retour</strong> : - <cite>numpy.ndarray</cite> : Un tableau numpy ndarray avec la forme (w, h, 3) de type uint8, identique au tableau d’entrée mais avec les pixels inversés.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet de miroir (sur place).</p>
<p>Cette méthode crée une image miroir de la surface donnée en la réfléchissant horizontalement. L’effet est appliqué directement sur la surface (sur place).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, apply the mirroring effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">mirroring</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Une surface pygame compatible avec les formats 24 bits ou 32 bits qui subira l’effet de miroir.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La fonction modifie la surface donnée sur place, ce qui signifie qu’elle ne retourne pas une nouvelle surface, mais modifie la surface d’entrée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen" title="Lien vers cette définition">¶</a></dt>
<dd><p>Aiguiser une image (sur place) en utilisant un noyau 3x3.</p>
<p>Cette fonction applique un filtre de netteté à l’image sur la surface donnée. Le filtre utilise un noyau 3x3 pour renforcer les bords et les détails en augmentant le contraste autour des bords, rendant l’image plus nette.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image and apply the sharpen effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sharpen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec les formats 24 bits ou 32 bits qui sera modifiée sur place pour appliquer l’effet de netteté.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>None</cite> : La fonction modifie la surface donnée sur place, ce qui signifie qu’aucune nouvelle surface n’est retournée. La surface originale sera aiguisée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Aiguiser un tableau (sur place) en utilisant un noyau 3x3.</p>
<p>Cette fonction applique un filtre de netteté directement à un tableau 1D en utilisant un noyau 3x3. Il est compatible avec les types de tableaux BGR ou BGR(A), et peut également fonctionner avec d’autres formats de pixels tels que RGB ou RGB(A). Le filtre de netteté renforce les bords en augmentant le contraste autour d’eux, rendant l’image plus nette. Si le tableau contient une transparence alpha, définissez <cite>format_32=True</cite>.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>w</cite> (int) : La largeur du tableau. - <cite>h</cite> (int) : La hauteur du tableau. - <cite>bgr_array</cite> (numpy.ndarray) : Un tableau 1D (forme : (w, )) de type uint8, contenant les valeurs de pixels BGR ou RGB. - <cite>format_32</cite> (bool, optionnel) : Si <cite>True</cite>, le tableau contient une transparence alpha (format BGRA). Si <cite>False</cite>, le tableau est au format BGR (par défaut c’est <cite>False</cite>).</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La fonction modifie le tableau donné sur place (c’est-à-dire qu’aucun nouveau tableau n’est retourné).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Aiguiser un tableau (retourner un nouveau tableau).</p>
<p>Cette fonction retourne un nouveau tableau avec un filtre de netteté appliqué, en utilisant un noyau 3x3. Il est compatible avec les types de tableaux BGR ou BGR(A), et peut également fonctionner avec d’autres formats de pixels tels que RGB ou RGB(A). Le filtre de netteté renforce les bords en augmentant le contraste autour d’eux, rendant l’image plus nette. Si le tableau contient une transparence alpha, définissez <cite>format_32=True</cite>.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>w</cite> (int) : La largeur du tableau. - <cite>h</cite> (int) : La hauteur du tableau. - <cite>bgr_array</cite> (numpy.ndarray) : Un tableau 1D (forme : (w, )) de type uint8, contenant les valeurs de pixels BGR ou RGB. - <cite>format_32</cite> (bool, optionnel) : Si <cite>True</cite>, le tableau contient une transparence alpha (format BGRA). Si <cite>False</cite>, le tableau est au format BGR (par défaut c’est <cite>False</cite>).</p>
<p><strong>Retour</strong> : - <cite>numpy.ndarray</cite> : Un tableau numpy 1D (forme : (w, )) de type uint8, avec des pixels aiguisés similaires à ceux du tableau d’entrée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen32" title="Lien vers cette définition">¶</a></dt>
<dd><p>Aiguiser l’image en utilisant un noyau 3x3 (sur place).</p>
<p>Cette fonction applique un filtre de netteté directement à l’image sur la surface donnée. Le filtre utilise un noyau 3x3 pour renforcer les bords et les détails en augmentant le contraste autour des bords, rendant l’image plus nette. Il est compatible avec les images 24 bits et 32 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit images</span>
<span class="n">sharpen32</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec des formats 24 bits ou 32 bits à aiguiser.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La fonction modifie la surface donnée sur place (c’est-à-dire qu’aucune nouvelle surface n’est retournée).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dirt_lens">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dirt_lens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lens_model_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">light_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dirt_lens" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effet de lentille sale (sur place).</p>
<p>Cette fonction applique une texture de lentille sale sur l’affichage du jeu pour simuler un artefact de caméra ou un effet réaliste de caméra, particulièrement lorsque la lumière de la scène est orientée directement vers la caméra. La fonction mélange la texture de la lentille avec l’affichage, créant un effet de saleté sur la lentille.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dirt_lens</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lens_model</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">,</span> <span class="n">light_</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : La surface (affichage ou écran de jeu) qui sera modifiée par l’effet de lentille sale. Elle doit être en format 24 bits ou 32 bits. - <cite>lens_model_</cite> (pygame.Surface) : La texture du modèle de lentille (par exemple, lentille sale) à appliquer à la surface. Vous pouvez choisir parmi diverses textures de lentilles fournies dans le dossier des ressources. Ces textures doivent être redimensionnées pour correspondre aux dimensions de l’affichage. - <cite>flag_</cite> (int, optionnel) : Le paramètre de fusion à appliquer à la texture de la lentille. La valeur par défaut est <cite>pygame.BLEND_RGB_ADD</cite>, qui ajoute la texture de lentille au-dessus de la surface. Vous pouvez utiliser d’autres paramètres de fusion Pygame comme <cite>BLEND_RGB_MAX</cite>, etc. - <cite>light_</cite> (float, optionnel) : Une valeur flottante comprise entre -1.0 et 0.2 qui ajuste la luminosité de la texture de la lentille. Des valeurs inférieures à 0 réduiront l’effet de lentille, tandis que des valeurs supérieures à 0 éclaireront l’affichage et augmenteront l’effet de lentille sale. La valeur par défaut est 0.0.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : Cette fonction modifie la surface d’entrée sur place et ne retourne pas un nouvel objet.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (copie).</p>
<p>Cette fonction applique l’algorithme de dithering Floyd-Steinberg à une surface Pygame pour créer l’illusion de profondeur de couleur dans des images avec une palette de couleurs limitée. Le dithering approxime les couleurs qui ne sont pas disponibles dans la palette en diffusant des pixels colorés à partir de la palette disponible. Le résultat est une image en dithering avec une apparence granuleuse ou tachetée caractéristique.</p>
<p>L’image d’entrée est convertie d’une surface Pygame en un tableau 3D (w, h, 3) avec un type de données flottant. Comme l’image est convertie en un autre type de données (de <cite>uint8</cite> à <cite>float32</cite>), la transformation n’est pas appliquée sur place, et une copie de l’image originale (sans le canal alpha) est retournée.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Un objet surface Pygame en format 24 bits ou 32 bits. La surface à dither.</p>
<p><strong>Retour</strong> : - <cite>pygame.Surface</cite> : Une nouvelle surface Pygame en format 24 bits (sans le canal alpha) représentant la version en dithering de l’image d’entrée.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (sur place).</p>
<p>Cette fonction applique l’algorithme de dithering Floyd-Steinberg à une surface Pygame pour créer l’illusion de profondeur de couleur dans des images avec une palette de couleurs limitée. Le dithering approxime les couleurs qui ne sont pas disponibles dans la palette en diffusant des pixels colorés à partir de la palette disponible. Le résultat est une image en dithering avec une apparence granuleuse ou tachetée caractéristique. Contrairement à la version non-sur-place, cette fonction modifie directement la surface de l’image.</p>
<p>L’image d’entrée est convertie d’une surface Pygame en un tableau 3D (w, h, 3) avec un type de données flottant. L’image est modifiée directement, et aucun nouvel objet n’est retourné.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> : - <cite>surface_</cite> (pygame.Surface) : Un objet surface Pygame en format 24 bits ou 32 bits. La surface à dither.</p>
<p><strong>Retour</strong> : - <cite>None</cite> : La surface d’entrée est modifiée sur place (c’est-à-dire qu’aucune nouvelle surface n’est retournée).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (sur place) sur un tableau 1D.</p>
<p>Cette fonction applique l’algorithme de dithering Floyd-Steinberg à un tableau 1D, simulant l’illusion de profondeur de couleur dans des images avec une palette de couleurs limitée. Le dithering approxime les couleurs qui ne sont pas disponibles dans la palette en diffusant des pixels colorés à partir de la palette disponible. Le résultat est une image en dithering avec une apparence granuleuse ou tachetée caractéristique. Cette fonction modifie le tableau d’entrée sur place.</p>
<p>Le processus de dithering peut traiter des images 24 bits et 32 bits, avec le paramètre <cite>format_32</cite> indiquant si l’entrée est une image 32 bits (avec transparence) ou une image 24 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>w</cite> (int) : La largeur du tableau d’image.</p></li>
<li><p><cite>h</cite> (int) : La hauteur du tableau d’image.</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray) : Un tableau 1D avec la forme <cite>(w, h, 3)</cite> pour les images 24 bits (BGR) ou <cite>(w, h, 4)</cite> pour les images 32 bits (BGRA).</p></li>
<li><p><cite>format_32</cite> (booléen, optionnel) : Un indicateur du format de l’image. Défini sur <cite>True</cite> pour les images 32 bits (BGRA), ou <cite>False</cite> pour les images 24 bits (BGR). Par défaut, il est <cite>False</cite>.</p></li>
</ul>
<p><strong>Retour</strong> : - <cite>None</cite> : Cette fonction modifie le tableau d’entrée sur place (c’est-à-dire qu’aucun nouveau tableau n’est retourné).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d_cp" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Floyd-Steinberg (copie) sur un tableau 1D.</p>
<p>Cette fonction applique l’algorithme de dithering Floyd-Steinberg à un tableau 1D, simulant l’illusion de profondeur de couleur dans des images avec une palette de couleurs limitée. Le dithering approxime les couleurs qui ne sont pas disponibles dans la palette en diffusant des pixels colorés à partir de la palette disponible. Le résultat est une image en dithering avec une apparence granuleuse ou tachetée caractéristique. Contrairement à <cite>dithering1d</cite>, cette fonction retourne un nouveau tableau avec l’effet de dithering appliqué, plutôt que de modifier le tableau sur place.</p>
<p>Le processus de dithering peut traiter des images 24 bits et 32 bits. Le paramètre <cite>format_32</cite> indique si l’entrée est une image 32 bits (avec transparence) ou une image 24 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>

<span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>w</cite> (int) : La largeur du tableau d’image.</p></li>
<li><p><cite>h</cite> (int) : La hauteur du tableau d’image.</p></li>
<li><p><cite>rgb_array</cite> (numpy.ndarray) : Un tableau 1D avec la forme <cite>(w, h, 3)</cite> pour les images 24 bits (RGB) ou <cite>(w, h, 4)</cite> pour les images 32 bits (RGBA).</p></li>
<li><p><cite>format_32</cite> (booléen, optionnel) : Un indicateur du format de l’image. Défini sur <cite>True</cite> pour les images 32 bits (RGBA), ou <cite>False</cite> pour les images 24 bits (RGB). Par défaut, il est <cite>False</cite>.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>numpy.ndarray</cite> : Un nouveau tableau 1D avec l’effet de dithering appliqué. La forme du tableau est <cite>(w, h, 3)</cite> pour les images 24 bits ou <cite>(w, h, 4)</cite> pour les images 32 bits.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Atkinson (copie)</p>
<p>Le dithering Atkinson est une variante du dithering Floyd-Steinberg, développé par Bill Atkinson chez Apple Computer et utilisé dans l’ordinateur Macintosh original. Cette technique de dithering est utilisée pour créer l’illusion de « profondeur de couleur » dans des images avec une palette de couleurs limitée, également connue sous le nom de quantification des couleurs. Les couleurs qui ne sont pas disponibles dans la palette sont approximées en diffusant des pixels colorés à partir de la palette disponible. L’œil humain perçoit cette diffusion comme un mélange des couleurs, ce qui entraîne souvent une apparence granuleuse ou tachetée caractéristique.</p>
<p>Cette fonction applique le dithering Atkinson à une image représentée par une surface Pygame. L’image est convertie en un format de tableau 3D avec la forme <cite>(w, h, 3)</cite> et le type <cite>float32</cite> (précision simple). Puisque l’image est convertie en un type de données différent (de <cite>uint8</cite> à <cite>float32</cite>), la transformation ne peut pas être appliquée sur place.</p>
<p>La fonction retourne une nouvelle image avec l’effet de dithering appliqué.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering_atkinson</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>  <span class="c1"># for 24 or 32-bit image format</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame au format 24 bits ou 32 bits qui subira le dithering Atkinson.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface Pygame au format 24 bits avec l’effet de dithering appliqué (sans le canal alpha).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Dithering Atkinson pour un tableau 1D (sur place)</p>
<p>Le dithering Atkinson est une variante du dithering Floyd-Steinberg, développé par Bill Atkinson chez Apple Computer, et utilisé dans l’ordinateur Macintosh original. Cette technique de dithering est utilisée pour créer l’illusion de « profondeur de couleur » dans des images avec une palette de couleurs limitée, un processus également connu sous le nom de quantification des couleurs. Dans une image en dithering, les couleurs non disponibles dans la palette sont approximées en diffusant des pixels colorés à partir de la palette disponible. L’œil humain perçoit cette diffusion comme un mélange des couleurs, ce qui entraîne souvent une apparence granuleuse ou tachetée caractéristique.</p>
<p>Cette fonction applique le dithering Atkinson à une image représentée par un tableau 1D en mémoire. Elle fonctionne directement sur le tableau (sur place), modifiant les valeurs des pixels pour obtenir l’effet de dithering.</p>
<p>La fonction est compatible avec les images 24 bits et 32 bits. Si le processus de dithering n’est pas appliqué à l’image, vérifiez le flag <cite>format_32</cite>. Le flag doit être défini sur <cite>True</cite> pour les images contenant de la transparence par pixel ou des formes de tableau équivalentes (w, h, 4). Pour les images 24 bits, définissez <cite>format_32</cite> sur <cite>False</cite> (forme du tableau (w, h, 3)).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>w</cite> (int) : La largeur du tableau.</p></li>
<li><p><cite>h</cite> (int) : La hauteur du tableau.</p></li>
<li><p><cite>c_buffer</cite> (C-Buffer ou memoryviewslice ou 1d numpy.ndarray) : Le tableau 1D ou la vue mémoire contenant des pixels BGR ou tout autre format de pixel (type de données uint8).</p></li>
<li><p><cite>format_32</cite> (bool, optionnel) : - <cite>True</cite> si le tableau représente une image 32 bits (format BGRA avec transparence). - <cite>False</cite> pour une image 24 bits (format BGR). La valeur par défaut est <cite>False</cite>.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>None</cite> : Cette fonction modifie le tableau sur place. Elle ne retourne pas un nouveau tableau.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixelation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocksize_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixelation" title="Lien vers cette définition">¶</a></dt>
<dd><p>Pixelisation d’une surface Pygame</p>
<p>La pixelisation en graphisme informatique désigne l’effet causé par l’affichage d’un bitmap ou d’une section de bitmap à une taille si grande que les pixels individuels deviennent visibles. Lorsqu’elle est appliquée à une image, la pixelisation réduit la résolution de l’image en augmentant la taille des pixels individuels, créant ainsi une apparence de blocs ou de pixels.</p>
<p>Cette fonction pixelise une surface Pygame en divisant l’image en blocs carrés, chaque bloc représentant la couleur moyenne des pixels à l’intérieur. La taille des blocs est spécifiée par le paramètre <cite>blocksize_</cite> (par défaut, 64).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">pix_image</span> <span class="o">=</span> <span class="n">pixelation</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface Pygame à pixeliser.</p></li>
<li><p><cite>blocksize_</cite> (int non signé, optionnel) : La taille des blocs utilisée pour le processus de pixelisation, la valeur par défaut est 64. Cette valeur détermine la taille de chaque bloc pixelisé (par exemple, des blocs de 64x64 pixels).</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface avec l’effet de pixelisation appliqué.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend" title="Lien vers cette définition">¶</a></dt>
<dd><p>Mélange alpha</p>
<p>Fusionner deux images à l’aide du mélange alpha, où une image est superposée sur une autre avec un niveau de transparence spécifié. La fonction permet de fusionner l’image <cite>source</cite> sur l’image <cite>destination</cite> en fonction d’une valeur de pourcentage, où 0% signifie aucune fusion et 100% signifie une fusion complète de l’image source sur l’image de destination.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">transition</span> <span class="o">=</span> <span class="n">blend</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">image1</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">image2</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface) : L’image source (compatible avec les formats 24 ou 32 bits).</p></li>
<li><p><cite>destination</cite> (pygame.Surface) : L’image de destination (compatible avec les formats 24 ou 32 bits).</p></li>
<li><p><cite>percentage</cite> (float) : La valeur du pourcentage entre 0,0 et 100,0 qui détermine le niveau de fusion. 0,0 signifie que l’image source est complètement transparente, et 100,0 signifie que l’image source remplace complètement l’image de destination.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface (24 bits) représentant le résultat fusionné des images <cite>source</cite> et <cite>destination</cite>.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Mélange alpha (tableau 1D)</p>
<p>Fusionner deux tampons d’image 1D à l’aide du mélange alpha. Cette méthode vous permet de fusionner deux images en fournissant les tampons d’images comme source et destination. L’argument <cite>percentage</cite> permet de contrôler l’impact de chaque image sur le résultat final. Par exemple, si <cite>percentage</cite> est défini sur 25%, l’image source contribuera à hauteur de 25% tandis que l’image de destination contribuera à hauteur de 75%.</p>
<p>L’argument <cite>modes</cite> spécifie le format des pixels des tampons source et destination, qui peuvent être soit “RGB(X)” ou “BGR(X)”, où “X” fait référence au canal alpha si présent. L’argument <cite>format_32</cite> doit être défini sur <cite>True</cite> si les tampons source et destination contiennent de la transparence alpha (format RGBA).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit images with alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit images without alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>w</cite> (int) : Largeur du tableau source.</p></li>
<li><p><cite>h</cite> (int) : Hauteur du tableau source.</p></li>
<li><p><cite>source</cite> (numpy.ndarray) : Tableau 1D de type uint8 représentant l’image source en format RGB(A) ou BGR(A).</p></li>
<li><p><cite>destination</cite> (numpy.ndarray) : Tableau 1D de type uint8 représentant l’image de destination dans le même format que <cite>source</cite>.</p></li>
<li><p><cite>percentage</cite> (float) : Valeur du pourcentage de fusion entre 0 et 100. Une valeur de 0 signifie que seule l’image de destination est visible, tandis que 100 signifie que seule l’image source est visible.</p></li>
<li><p><cite>modes</cite> (str) : Une chaîne représentant le format des pixels des tableaux source et destination. Utilisez “RGB(X)” pour le format RGB ou RGBA et “BGR(X)” pour le format BGR ou BGRA.</p></li>
<li><p><cite>format_32</cite> (bool) : Si <cite>True</cite>, les tableaux source et destination contiennent une transparence alpha (format RGBA ou BGRA). Par défaut, <cite>False</cite>.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface avec l’effet de fusion appliqué, qui peut être soit en format 24 bits, soit en format 32 bits, selon les formats des tableaux source et destination.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Mélange alpha (en place)</p>
<p>Cette fonction fusionne l’image <cite>source</cite> dans l’image <cite>destination</cite>, modifiant directement l’image de destination. Les textures <cite>source</cite> et <cite>destination</cite> doivent être de la même taille. L’argument <cite>percentage</cite> contrôle la contribution de chaque image au résultat final. Par exemple, si <cite>percentage</cite> est défini sur 25%, l’image source contribuera à hauteur de 25% tandis que l’image de destination contribuera à hauteur de 75%.</p>
<p>La fonction est compatible avec les surfaces 24 bits et 32 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">blend_inplace</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>destination</cite> (pygame.Surface) : La surface qui sera modifiée, compatible avec les surfaces 24 bits ou 32 bits.</p></li>
<li><p><cite>source</cite> (pygame.Surface) : La surface à fusionner dans la destination, compatible avec les surfaces 24 bits ou 32 bits.</p></li>
<li><p><cite>percentage</cite> (float) : Une valeur entre 0,0 et 100,0 indiquant le pourcentage de fusion. Une valeur de 0,0 signifie aucun effet de la source, et 100,0 signifie que la source remplace complètement la destination.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : L’opération est effectuée en place, ce qui signifie que la surface de destination est modifiée directement.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.cartoon">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">cartoon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.cartoon" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet cartoon à une image.</p>
<p>Cette fonction applique un effet de type cartoon à une surface donnée. Elle utilise un filtre Sobel pour la détection des contours et le combine avec un filtrage médian et une réduction des couleurs pour créer un effet cartoon simplifié et stylisé. La fonction est compatible avec les images 24 bits et 32 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cartoon_image</span> <span class="o">=</span> <span class="n">cartoon</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface à laquelle l’effet cartoon sera appliqué. Elle peut être soit en 24 bits, soit en 32 bits.</p></li>
<li><p><cite>sobel_threshold</cite> (unsigned int, optionnel) : Le seuil du filtre Sobel pour la détection des contours. Par défaut, 128.</p></li>
<li><p><cite>median_kernel</cite> (unsigned int, optionnel) : La taille du noyau utilisé pour le filtrage médian. Par défaut, 2.</p></li>
<li><p><cite>color</cite> (unsigned int, optionnel) : Le niveau maximal de réduction des couleurs (c’est-à-dire, le nombre de couleurs dans l’image après réduction). Par défaut, 8.</p></li>
<li><p><cite>flag</cite> (unsigned int, optionnel) : Le drapeau de fusion pour fusionner l’image cartoon finale. Par défaut, <cite>BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : La surface d’entrée avec l’effet cartoon appliqué.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.convert_27">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">convert_27</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.convert_27" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertir une image en une palette de couleurs réduite de 27 couleurs (en place).</p>
<p>Cette fonction réduit la profondeur de couleur d’une image en appliquant un algorithme qui la convertit en seulement 27 couleurs distinctes. L’opération est effectuée en place, ce qui signifie que la surface originale est modifiée directement.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">convert_27</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface (image) qui sera convertie en une palette de couleurs réduite. Elle est compatible avec les formats d’images 24 bits et 32 bits.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : La fonction modifie la surface en place et ne retourne pas une nouvelle surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilateral">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilateral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilateral" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un filtrage bilatéral à une image et retourner une copie filtrée.</p>
<p>Le filtrage bilatéral est un filtre de lissage non linéaire, préservant les contours et réduisant le bruit. Il remplace l’intensité de chaque pixel par une moyenne pondérée des intensités des pixels voisins, avec des poids basés à la fois sur la proximité spatiale et la similarité d’intensité. Cela permet au filtre de flouter les régions lisses tout en préservant les bords nets.</p>
<p>Le filtre repose sur deux paramètres clés :</p>
<ul class="simple">
<li><p><strong>sigma_s</strong> : Étendue spatiale du noyau. Il définit la taille du voisinage autour de chaque pixel qui influence l’opération du filtre.</p></li>
<li><p><strong>sigma_i</strong> : Noyau de gamme d’intensité. Il contrôle la sensibilité du filtre aux différences d’intensité. Une valeur plus petite de <cite>sigma_i</cite> préserve mieux les contours, tandis qu’une valeur plus grande permet un flou plus uniforme.</p></li>
</ul>
<p>À mesure que <cite>sigma_i</cite> augmente, le filtre se rapproche d’un flou gaussien (qui est appliqué uniformément sur l’image). Une valeur plus petite de <cite>sigma_i</cite> conserve plus de détails locaux en réduisant la contribution des pixels avec des intensités différentes.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>image</cite> (pygame.Surface) : La surface (image) à laquelle le filtrage bilatéral sera appliqué. L’image doit être au format RGB 24-32 bits, et le canal alpha sera ignoré. L’image est convertie en un tableau 3D pour le traitement.</p></li>
<li><p><cite>sigma_s</cite> (float) : L’étendue spatiale du noyau. Ce paramètre contrôle la taille du voisinage utilisé pour calculer la moyenne pondérée.</p></li>
<li><p><cite>sigma_i</cite> (float) : Sensibilité à l’intensité. Définit la différence d’intensité maximale qui contribue au flou. Des valeurs plus petites préserveront les bords.</p></li>
<li><p><cite>kernel_size</cite> (int, optionnel) : La taille du noyau (la valeur par défaut est 3). Ce paramètre contrôle jusqu’où le filtre s’étend à partir de chaque pixel.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface Pygame avec le filtre bilatéral appliqué.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un filtre d’estampillage à une image ou une surface, produisant un effet d’estampillage.</p>
<p>Le filtre d’estampillage crée un effet visuel qui fait apparaître l’image comme étant en relief, similaire à un estampillage sur papier ou métal de l’image originale, ce qui peut être utilisé pour mettre en valeur les bords ou créer des effets artistiques.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec les formats d’image 24 bits ou 32 bits.</p></li>
<li><p><cite>flag_</cite> (int, optionnel) : Un drapeau de fusion spécial Pygame (la valeur par défaut est 0). Ce drapeau peut être l’un des modes de fusion tels que <cite>BLEND_RGB_ADD</cite>, <cite>BLEND_RGB_MULT</cite>, etc. Il modifie le comportement de fusion de l’image et affectera le résultat final.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une surface contenant l’image estampillée. Si <cite>flag_</cite> est réglé sur 0, le résultat est au format 24 bits ; sinon, un format 32 bits est retourné.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Estampiller une surface (en place)</p>
<p>Cette fonction applique un filtre d’estampillage à une image en place, ce qui signifie que l’image elle-même est modifiée plutôt que de créer une nouvelle image. L’effet d’estampillage produit un effet de relief, semblable à un estampillage sur papier ou métal. Il peut mettre en valeur les bords et créer des effets artistiques dans l’image.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame qui sera estampillée. La surface sera modifiée en place une fois le processus terminé.</p></li>
<li><p><cite>copy</cite> (numpy.ndarray, optionnel) : Un tableau numpy de forme <cite>(w, h, 3)</cite> de type <cite>uint8</cite> contenant les pixels RGB. Il doit avoir la même taille que la surface d’entrée. Ce tableau est utilisé comme une copie du tableau source pour améliorer légèrement les performances.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : La surface est modifiée en place et aucune nouvelle surface n’est retournée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss1d" title="Lien vers cette définition">¶</a></dt>
<dd><p>Estampiller directement un type C-buffer (en place)</p>
<p>Cette fonction applique un filtre d’estampillage à une image en place, en modifiant directement le tableau C-buffer fourni (<cite>bgr_array</cite>). L’effet d’estampillage produit une texture en relief, semblable à un estampillage sur papier ou métal, rendant les bords plus prononcés et créant des effets artistiques.</p>
<p>Si le <cite>tmp_array</cite> est fourni, il est utilisé pour améliorer les performances, mais il doit avoir la même forme et la même taille que le tableau source (<cite>bgr_array</cite>).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>w</cite> (int) : La largeur de la surface (image).</p></li>
<li><p><cite>h</cite> (int) : La hauteur de la surface (image).</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray ou memoryviewslice) : Un tableau 1D de type <cite>uint8</cite> contenant des données de pixels BGR ou tout autre format de pixels. Ce tableau représente les données source qui seront modifiées en place.</p></li>
<li><p><cite>tmp_array</cite> (numpy.ndarray ou memoryviewslice, optionnel) : Un tableau 1D de type <cite>uint8</cite> contenant des données de pixels BGR ou tout autre format de pixels. Ce tableau doit être une copie du tableau source pour améliorer les performances.</p></li>
<li><p><cite>format_32</cite> (bool, par défaut False) : Défini sur <cite>True</cite> si le tableau source contient une transparence alpha (format 32 bits).</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : La fonction modifie le <cite>bgr_array</cite> en place et ne retourne pas un nouveau tableau.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_gray">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_gray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_gray" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un filtre d’estampillage en niveaux de gris à une image ou surface et retourner une copie modifiée.</p>
<p>Cette fonction applique un effet d’estampillage à l’image ou la surface donnée en niveaux de gris. L’effet d’estampillage crée une texture en relief qui imite un estampillage sur papier ou métal. Le résultat est un effet stylisé où les bords et les contours sont accentués, mais dans une palette monochromatique en niveaux de gris.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss_gray</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface d’entrée (image) sur laquelle l’effet d’estampillage en niveaux de gris sera appliqué. Cette surface doit être compatible avec les formats 24 bits ou 32 bits.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface Pygame avec l’image estampillée en niveaux de gris. L’image résultante est toujours en format 24 bits.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilinear">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilinear" title="Lien vers cette définition">¶</a></dt>
<dd><p>Redimensionner une image en utilisant l’algorithme de filtre bilinéaire (retourne une copie).</p>
<p>Cette fonction applique le filtre bilinéaire pour redimensionner une image. Le filtrage bilinéaire lisse l’image et est couramment utilisé dans les tâches de redimensionnement d’images. La fonction prend en charge les images d’entrée en 32 bits, mais le résultat est toujours retourné en format 24 bits (sans le canal alpha).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Resize image to 600x600</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Resize with specific scaling factors</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface d’entrée (image) à redimensionner. Elle doit être compatible avec les formats 24 bits ou 32 bits.</p></li>
<li><p><cite>size_</cite> (tuple) : Un tuple <cite>(largeur, hauteur)</cite> spécifiant les nouvelles dimensions de la surface redimensionnée.</p></li>
<li><p><cite>fx</cite> (float, optionnel) : Un facteur d’échelle pour l’axe x (largeur). Si fourni, il remplacera la largeur spécifiée dans <cite>size_</cite>. La valeur par défaut est None.</p></li>
<li><p><cite>fy</cite> (float, optionnel) : Un facteur d’échelle pour l’axe y (hauteur). Si fourni, il remplacera la hauteur spécifiée dans <cite>size_</cite>. La valeur par défaut est None.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface Pygame de type 24 bits (sans le canal alpha), redimensionnée en fonction des paramètres d’entrée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling24" title="Lien vers cette définition">¶</a></dt>
<dd><p>Modélisation de tunnel en 24 bits : Cette méthode produira des données de rendu 24 bits pour simuler un effet de tunnel.</p>
<p>L’algorithme utilise une texture 256x256, mais la redimensionne à 512x512 pixels pour un meilleur rendu. Il génère un effet de tunnel en manipulant les distances, les angles, les ombres et les données de rendu.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling24</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int) : La largeur de l’affichage ou la largeur de l’effet de tunnel.</p></li>
<li><p><cite>screen_height</cite> (int) : La hauteur de l’affichage ou la hauteur de l’effet de tunnel.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface) : L’effet de texture du tunnel, compatible avec les formats 24 bits ou 32 bits.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> : Un tuple contenant quatre tampons : - <cite>distances</cite> : Tampon contenant les données de distance. - <cite>angles</cite> : Tampon contenant les données d’angle. - <cite>shades</cite> : Tampon contenant les données d’ombrage. - <cite>scr_data</cite> : Tampon contenant les données de rendu de l’écran.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render24" title="Lien vers cette définition">¶</a></dt>
<dd><p>Rendu de l’effet de tunnel</p>
<p>Cette fonction rend l’effet de tunnel basé sur des données pré-calculées, créant une surface de sortie en 24 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render24</span><span class="p">(</span><span class="n">FRAME</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>t</cite> (int) : Chronomètre ou nombre d’images. Contrôle la vitesse de l’effet de tunnel.</p></li>
<li><p><cite>screen_width</cite> (int) : La largeur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>screen_height</cite> (int) : La hauteur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>screen_w2</cite> (int) : La largeur de l’écran divisée par 2.</p></li>
<li><p><cite>screen_h2</cite> (int) : La hauteur de l’écran divisée par 2.</p></li>
<li><p><cite>distances</cite> (numpy.ndarray) : Un tampon C 1D contenant les distances. Ce tampon est obtenu à partir de la fonction <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray) : Un tampon C 1D contenant les angles. Ce tampon est obtenu à partir de la fonction <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray) : Un tampon C 1D contenant les ombres. Ce tampon est obtenu à partir de la fonction <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray) : Un tampon C 1D contenant les pixels de fond. Ce tampon est obtenu à partir de la fonction <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray) : Un tampon C 1D, généralement vide. Il doit avoir la même taille que l’image de sortie (largeur * hauteur * 4 pour RGBA). Ce tampon est utilisé pour construire l’effet de texture final.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une surface 24 bits avec l’effet de tunnel rendu.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling32" title="Lien vers cette définition">¶</a></dt>
<dd><p>Générer un effet de modélisation de tunnel en 32 bits.</p>
<p>Cette fonction simule un effet de tunnel et génère des données de rendu en 32 bits basées sur la texture de surface fournie. Elle utilise une texture 256x256, qui est redimensionnée à une résolution 512x512 pour une meilleure qualité de rendu. L’algorithme calcule divers paramètres tels que les distances, les angles, les ombres et les données de rendu, qui peuvent être utilisés pour visualiser l’effet de tunnel.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling32</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int) : La largeur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>screen_height</cite> (int) : La hauteur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface) : La surface de texture utilisée pour l’effet de tunnel. La surface doit être compatible avec les formats 24 ou 32 bits.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> : Un tuple contenant quatre tampons : - <cite>distances</cite> : Un tampon représentant les distances calculées pour l’effet. - <cite>angles</cite> : Un tampon représentant les angles calculés pour l’effet. - <cite>shades</cite> : Un tampon représentant les ombres (luminosité) calculées pour l’effet. - <cite>scr_data</cite> : Un tampon contenant les données de texture de la surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render32" title="Lien vers cette définition">¶</a></dt>
<dd><p>Rendu de l’effet de tunnel.</p>
<p>Cette fonction rend l’effet de tunnel en utilisant les données de rendu 32 bits. Elle prend les paramètres calculés par la fonction <cite>tunnel_modeling32</cite> et les applique pour générer l’effet de tunnel final. Le résultat est une surface 32 bits qui peut être utilisée dans le rendu Pygame.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render32</span><span class="p">(</span><span class="n">FRAME</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>t</cite> (int) : Le chronomètre ou le nombre d’images. Cela contrôle la vitesse de l’effet.</p></li>
<li><p><cite>screen_width</cite> (int) : La largeur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>screen_height</cite> (int) : La hauteur de l’affichage ou de l’effet de tunnel.</p></li>
<li><p><cite>screen_w2</cite> (int) : C’est la moitié de la largeur de l’écran (<cite>screen_width // 2</cite>).</p></li>
<li><p><cite>screen_h2</cite> (int) : C’est la moitié de la hauteur de l’écran (<cite>screen_height // 2</cite>).</p></li>
<li><p><cite>distances</cite> (numpy.ndarray) : Un tampon C des distances, généré à partir de la fonction <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray) : Un tampon C des angles, généré à partir de la fonction <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray) : Un tampon C des ombres (luminosité), généré à partir de la fonction <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray) : Un tampon C des données de pixels de fond, généré à partir de la fonction <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray) : Un tampon C vide, typiquement un tampon vide de longueur <cite>width * height * 4</cite> (RGBA). Ce tampon sera utilisé pour construire l’image finale de l’effet de tunnel.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une surface contenant l’image 32 bits de l’effet de tunnel rendu.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de bloom rapide à une surface d’entrée.</p>
<p>L’effet de bloom éclaircit les pixels dans l’image au-dessus d’un seuil spécifié, puis applique un flou pour créer un effet lumineux. Cette fonction effectue une série d’opérations de réduction d’échelle et de flous, qui sont ensuite combinées pour produire l’effet de bloom final. L’algorithme peut être optimisé pour la vitesse, au prix d’une certaine qualité visuelle.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">shader_bloom_fast</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame contenant des données de pixels RGB (format couleur 32 bits ou 24 bits).</p></li>
<li><p><cite>threshold</cite> (int) : Le seuil de luminosité pour l’effet de bloom. Les pixels ayant des valeurs supérieures à ce seuil contribueront à l’effet de bloom. Une valeur plus petite entraînera un bloom plus fort.</p></li>
<li><p><cite>fast</cite> (bint, optionnel) : Si True, l’algorithme privilégiera la vitesse au détriment de la qualité visuelle en appliquant uniquement le flou à la surface la plus réduite (S16). La valeur par défaut est False.</p></li>
<li><p><cite>factor</cite> (int, optionnel) : Une valeur entre 0 et 4 qui contrôle le niveau de réduction d’échelle des textures utilisées dans le bloom. Des valeurs plus élevées entraînent une réduction d’échelle plus agressive. La valeur par défaut est 2, ce qui correspond à une division par 4.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une surface Pygame avec l’effet de bloom appliqué, en format couleur 24 bits.</p></li>
</ul>
<p><strong>Lève</strong> :</p>
<ul class="simple">
<li><p><cite>ValueError</cite> : Si la surface est trop petite pour être traitée (par exemple, après réduction d’échelle).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast1">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast1" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effet de bloom appliqué sur place (version simplifiée pour de meilleures performances).</p>
<p>La fonction <cite>shader_bloom_fast1</cite> applique un effet de bloom optimisé pour les objets en mouvement dans l’affichage. Contrairement à d’autres méthodes de bloom, cette version n’entraîne pas de décalage du halo lumineux par rapport aux objets en mouvement, car elle évite la technique de réduction d’échelle. Cela la rend mieux adaptée aux scènes dynamiques où les objets sont en mouvement.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame avec un format de couleur compatible 32 bits ou 24 bits (RGB).</p></li>
<li><p><cite>smooth_</cite> (int, optionnel) : Le facteur de lissage pour étendre le halo de lumière. La valeur par défaut est 3. Des valeurs plus élevées étendent le bloom sur l’ensemble de la scène mais diminuent l’effet, tandis que des valeurs plus petites créent un halo plus pixelisé mais intensifient l’effet sur les objets. Si smooth est inférieur à 3, le halo devient pixelisé.</p></li>
<li><p><cite>threshold_</cite> (int, optionnel) : Le seuil d’intensité du bloom. Un seuil de 0 correspond au bloom maximum. La valeur par défaut est 0, ce qui signifie qu’aucun seuil n’est appliqué.</p></li>
<li><p><cite>flag_</cite> (int, optionnel) : Un indicateur de mélange Pygame pour des effets de mélange spéciaux avec la lumière dans l’affichage. La valeur par défaut est <cite>pygame.BLEND_RGB_ADD</cite>. D’autres options incluent <cite>BLEND_RGB_MAX</cite>, <cite>BLEND_RGB_SUB</cite>, et d’autres attributs de mélange Pygame.</p></li>
<li><p><cite>saturation_</cite> (bool, optionnel) : Si True, l’effet de bloom inclura un effet de saturation au halo. La valeur par défaut est False.</p></li>
<li><p><cite>mask_</cite> (numpy.ndarray ou memoryviewslice, optionnel) : Un tableau numpy ou une vue mémoire représentant l’alpha du masque. Il doit avoir la forme (w, h) et le type <cite>float32</cite>, avec des valeurs dans la plage (0..255). Un masque rempli de 255 rendra et fera fleurir l’ensemble de l’image, tandis qu’un masque rempli de 0 désactivera l’effet de bloom. Des valeurs comprises entre 0 et 255 créent un effet de bloom sélectif. Le masque est optionnel.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : Cet effet est appliqué directement, modifiant la surface d’entrée en place.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shader_bloom_fast1</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effet de séparation RGB (retourne une copie).</p>
<p>Cette fonction applique un effet de séparation RGB à une image en décalant les canaux en fonction du décalage fourni. Le résultat est une image avec les canaux rouge, vert et bleu décalés par rapport à leurs positions d’origine. La valeur du décalage contrôle la direction et l’ampleur du décalage.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec un format de couleur 24 bits ou 32 bits (RGB). L’image d’entrée sur laquelle l’effet de séparation RGB sera appliqué.</p></li>
<li><p><cite>offset_</cite> (char) : Une valeur entière qui spécifie le décalage à appliquer entre les canaux RGB. Le décalage doit être compris entre [-128, 127]. Si le décalage est positif, les canaux sont affichés dans l’ordre BGR. Si le  décalage est négatif, les canaux sont affichés dans l’ordre RGB.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, optionnel) : Un tableau numpy ayant la forme (w, h, 3) et de type <cite>uint8</cite>. Si fourni, ce tableau accélérera le processus en appliquant directement la transformation dessus. Ce paramètre est optionnel.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface (copie) avec l’effet de séparation RGB appliqué, où les canaux RGB sont décalés selon la valeur spécifiée.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">split_channels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effet de séparation RGB (en place).</p>
<p>Cette fonction applique un effet de séparation RGB directement à une image, modifiant l’image d’origine sans créer de nouvelle copie. La fonction décale les canaux rouge, vert et bleu en fonction de la valeur de décalage fournie, réorganisant les canaux ou appliquant le décalage spécifié.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec un format de couleur 24 bits ou 32 bits (RGB). L’image d’entrée sur laquelle l’effet de séparation RGB sera appliqué, et les modifications seront appliquées directement à cette surface.</p></li>
<li><p><cite>offset_</cite> (char) : Une valeur entière qui spécifie le décalage à appliquer entre les canaux RGB. Le décalage doit être compris entre [-128, 127]. Si le décalage est positif, les canaux sont affichés dans l’ordre BGR. Si le  décalage est négatif, les canaux sont affichés dans l’ordre RGB.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, optionnel) : Un tableau numpy avec la forme (w, h, 3) et le type <cite>uint8</cite>. Si fourni, ce tableau sera utilisé pour accélérer le processus en appliquant directement la transformation dessus. Ce paramètre est optionnel.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : Les modifications sont appliquées directement à la surface d’entrée, aucune nouvelle surface n’est retournée.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">split_channels_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wavelength2rgb">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wavelength2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wavelength2rgb" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertir une longueur d’onde en couleur RGB.</p>
<p>Cette fonction associe une longueur d’onde donnée (en nanomètres) à une couleur RGB. La longueur d’onde est interprétée dans le spectre visible (380–750 nm), et la couleur correspondante est retournée dans le modèle de couleur RGB. La fonction permet optionnellement d’appliquer une correction gamma, qui ajuste la luminosité de la couleur.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int) : La longueur d’onde de la lumière en nanomètres (nm), généralement dans la plage du spectre visible de 380 à 750 nm. La fonction utilise cette valeur pour déterminer la couleur correspondante.</p></li>
<li><p><cite>gamma</cite> (float, optionnel) : Un facteur de correction gamma appliqué à la couleur. La valeur par défaut est <cite>1.0</cite>, ce qui signifie qu’aucune correction n’est appliquée. Les valeurs supérieures à <cite>1.0</cite> augmentent la luminosité de la couleur, tandis que les valeurs inférieures à <cite>1.0</cite> l’assombrissent.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> : Un tuple de trois entiers représentant les composants RGB de la couleur, chaque valeur étant dans la plage de 0 à 255.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns RGB values for orange (255, 137, 0)</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>

<span class="c1"># Returns RGB values for red with gamma correction</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">620</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.custom_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">custom_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.custom_map" title="Lien vers cette définition">¶</a></dt>
<dd><p>Associer une longueur d’onde à une couleur RGB personnalisée en fonction d’un domaine de longueurs d’onde défini par l’utilisateur.</p>
<p>Contrairement à la fonction <cite>wavelength2rgb</cite> qui retourne des valeurs RGB correspondant à une longueur d’onde dans le spectre visible standard (380–750 nm), cette fonction permet à l’utilisateur de définir un domaine de longueurs d’onde personnalisé et retourne la couleur RGB correspondante pour une longueur d’onde dans ce domaine.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int) : La longueur d’onde de la lumière en nanomètres (nm). Cette valeur est associée au domaine de longueurs d’onde personnalisé défini dans <cite>color_array</cite>.</p></li>
<li><p><cite>color_array</cite> (numpy.ndarray) : Un tableau 1D d’entiers représentant les bornes de longueurs d’onde de différentes couleurs. Le tableau doit contenir des paires de valeurs pour chaque couleur (par exemple, des plages [min, max] pour des couleurs comme le jaune, l’orange, le rouge, etc.). Ces plages définissent le domaine dans lequel les couleurs seront appliquées.</p></li>
<li><p><cite>gamma</cite> (float, optionnel) : Un facteur de correction gamma appliqué à la couleur RGB résultante. La valeur par défaut est <cite>1.0</cite>, ce qui signifie qu’aucune correction gamma n’est appliquée. Les valeurs supérieures à <cite>1.0</cite> éclairciront la couleur, tandis que les valeurs inférieures à <cite>1.0</cite> l’assombriront.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> : Un tuple contenant les valeurs RGB (0-255) pour la couleur correspondant à la longueur d’onde donnée dans le domaine personnalisé.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a custom wavelength domain with different color gradients</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Violet not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Blue not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Green not used</span>
     <span class="mi">570</span><span class="p">,</span> <span class="mi">619</span><span class="p">,</span>   <span class="c1"># Yellow gradient from 2 to 619 nm</span>
     <span class="mi">620</span><span class="p">,</span> <span class="mi">650</span><span class="p">,</span>   <span class="c1"># Orange gradient from 620 to 650 nm</span>
     <span class="mi">651</span><span class="p">,</span> <span class="mi">660</span>    <span class="c1"># Red gradient from 651 to 660 nm</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Get RGB color for a wavelength of 600 nm</span>
<span class="n">rgb_color</span> <span class="o">=</span> <span class="n">custom_map</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

<span class="c1"># Generate a heatmap of colors for wavelengths from 380 nm to 799 nm</span>
<span class="n">heatmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">custom_map</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">20</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">380</span><span class="p">,</span> <span class="mi">800</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blue_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blue_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blue_map" title="Lien vers cette définition">¶</a></dt>
<dd><p>Associer une longueur d’onde spécifique à une couleur RGB à tonalité bleue.</p>
<p>Cette fonction prend une longueur d’onde (en nanomètres) et retourne les valeurs RGB correspondantes en mettant l’accent sur la génération d’une couleur bleue. Elle utilise un mappage simple basé sur la longueur d’onde fournie et applique une correction gamma pour des ajustements de couleur plus précis.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int) : La longueur d’onde de la lumière en nanomètres (nm). Cette valeur est associée à la valeur RGB à tonalité bleue.</p></li>
<li><p><cite>gamma</cite> (float, optionnel) : Un facteur de correction gamma appliqué à la couleur RGB résultante. La valeur par défaut est <cite>1.0</cite>, ce qui signifie qu’aucune correction gamma n’est appliquée. Les valeurs supérieures à <cite>1.0</cite> éclairciront la couleur, tandis que les valeurs inférieures à <cite>1.0</cite> l’assombriront.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> : Un tuple contenant les valeurs RGB (0-255) pour la couleur à tonalité bleue correspondant à la longueur d’onde donnée.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the blue RGB color correspondi</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bluescale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bluescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bluescale" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un filtre de couleur bleue à une image, la transformant en une version à tonalité bleue.</p>
<p>Cette fonction utilise la plage de longueurs d’onde de 450 à 495 nm, qui correspond à la lumière bleue dans le spectre visible, pour convertir l’image en différentes nuances de bleu.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface Pygame (image) qui sera transformée en nuances de bleu.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : Cette fonction modifie la surface fournie en place, il n’y a pas de valeur de retour.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transform an image into shades of blue</span>
<span class="n">bluescale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.red_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">red_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.red_map" title="Lien vers cette définition">¶</a></dt>
<dd><p>Retourner les composants RGB correspondant à une longueur d’onde spécifique dans le spectre rouge.</p>
<p>Cette fonction associe une longueur d’onde donnée (en nm) aux valeurs RGB appropriées pour la partie rouge du spectre visible. Elle peut être utilisée pour générer des couleurs basées sur le rouge à partir d’une longueur d’onde donnée.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int) : La longueur d’onde en nanomètres (nm) pour laquelle les valeurs RGB correspondantes sont calculées.</p></li>
<li><p><cite>gamma</cite> (float, optionnel) : Une valeur de correction gamma pour ajuster la luminosité des couleurs. La valeur par défaut est <cite>1.0</cite> (aucune correction).</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>tuple</cite> (int, int, int) : Un tuple de composants RGB en tant qu’entiers dans la plage (0 … 255), correspondant à la longueur d’onde spécifiée.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the RGB color for a wavelength of 610 nm (Red color)</span>
<span class="n">rgb</span> <span class="o">=</span> <span class="n">red_map</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.redscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">redscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.redscale" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet redscale à une image.</p>
<p>Cet algorithme associe l’image d’entrée à des nuances de rouge en ajustant les canaux de couleurs en fonction des longueurs d’onde généralement associées à la partie rouge du spectre lumineux visible, allant de 620 à 750 nm. L’effet redscale conserve les variations d’intensité de la couleur rouge tout en réduisant ou supprimant l’influence des autres canaux de couleur.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame représentant l’image à transformer en redscale. La surface doit contenir des données valides de pixels RGB.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>void</cite> : Cette fonction modifie directement la surface d’entrée et ne retourne pas une nouvelle surface.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply redscale effect to an image</span>
<span class="n">redscale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dampening" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet d’amortissement à une surface.</p>
<p>Cet effet simule un redimensionnement ou une réduction progressive de la surface basée sur une fonction d’oscillation amortie. La durée de l’effet est déterminée par le produit de la durée et de la fréquence. La position de la surface est ajustée en fonction de sa nouvelle taille pour maintenir sa position centrée sur l’affichage.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible avec une profondeur de couleur de 24 à 32 bits.</p></li>
<li><p><cite>frame</cite> (int) : Le numéro de la frame actuelle dans la séquence d’animation. Il doit être incrémenté à chaque mise à jour de la frame.</p></li>
<li><p><cite>display_width</cite> (int) : La largeur de la fenêtre d’affichage du jeu.</p></li>
<li><p><cite>display_height</cite> (int) : La hauteur de la fenêtre d’affichage du jeu.</p></li>
<li><p><cite>amplitude</cite> (float, optionnel) : L’amplitude de l’effet d’amortissement, qui détermine l’ampleur maximale du redimensionnement. La valeur par défaut est 50.0.</p></li>
<li><p><cite>duration</cite> (int, optionnel) : La durée de l’effet, qui contrôle combien de frames dure l’effet. La valeur par défaut est 30.</p></li>
<li><p><cite>freq</cite> (float, optionnel) : La fréquence de l’effet d’amortissement, qui affecte la rapidité avec laquelle l’oscillation de redimensionnement se produit. Une valeur plus petite prolongera l’effet, tandis qu’une valeur plus grande le réduira. La valeur par défaut est 20.0.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul>
<li><p>tuple : Un tuple contenant :</p>
<blockquote>
<div><ul class="simple">
<li><p>Une nouvelle surface Pygame avec l’effet d’amortissement appliqué.</p></li>
<li><p>La coordonnée x de la nouvelle position de la surface (coin supérieur gauche).</p></li>
<li><p>La coordonnée y de la nouvelle position de la surface (coin supérieur gauche).</p></li>
</ul>
<p>La surface est centrée dans la zone d’affichage.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply dampening effect to a surface</span>
<span class="n">surf</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">dampening</span><span class="p">(</span><span class="n">BCK</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.lateral_dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">lateral_dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.lateral_dampening" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet d’amortissement latéral pour produire un déplacement horizontal.</p>
<p>Cette méthode calcule le déplacement latéral (coordonnée x) basé sur une fonction d’oscillation amortie. La valeur du déplacement oscille entre des valeurs positives et négatives, diminuant progressivement selon les paramètres d’amplitude, de fréquence et de durée.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>frame</cite> (int) : Le numéro de la frame actuelle dans la séquence d’animation. Cette valeur doit être incrémentée à chaque frame pour produire une animation fluide.</p></li>
<li><p><cite>amplitude</cite> (float, optionnel) : L’amplitude de l’effet d’amortissement latéral. Cette valeur contrôle le déplacement maximal de la surface. Une valeur plus élevée entraîne un mouvement horizontal plus important. La valeur par défaut est 50.0.</p></li>
<li><p><cite>duration</cite> (int, optionnel) : La durée totale de l’effet, en termes de frames. Elle définit combien de temps durera l’oscillation. La valeur par défaut est 30 frames.</p></li>
<li><p><cite>freq</cite> (float, optionnel) : La fréquence de l’oscillation amortie. Cela contrôle la rapidité des oscillations. Une valeur plus faible fait durer plus longtemps l’effet (oscillation plus lente), tandis qu’une valeur plus élevée accélère l’oscillation. La valeur par défaut est 20.0.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p>float : La valeur de déplacement latéral (x) qui peut être utilisée pour déplacer l’objet horizontalement à l’écran (par exemple, lors du dessin d’une image). La valeur oscillera dans une plage déterminée par l’amplitude.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> : .. code-block:: python</p>
<blockquote>
<div><p># Appliquer un effet d’amortissement latéral à une surface tm = lateral_dampening(frame, amplitude=50.0, duration=35, freq=5.0) SCREEN.blit(BCK, (tm, 0), special_flags=0)</p>
</div></blockquote>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>Le déplacement suit un modèle d’oscillation amortie, où la valeur décroît au fil du temps en fonction des paramètres de fréquence et de durée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectuer un mélange alpha de deux images 32 bits.</p>
<p>Cette fonction mélange deux images 32 bits ensemble, en tenant compte de leurs canaux alpha (transparence). L’image <cite>source</cite> est dessinée par-dessus l’image <cite>destination</cite>. Le mélange utilise le canal alpha pour déterminer la transparence de chaque pixel de l’image source.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface) : L’image source à mélanger avec l’image destination. Elle doit être une image 32 bits avec un canal alpha.</p></li>
<li><p><cite>destination</cite> (pygame.Surface) : L’image de destination sur laquelle l’image source sera mélangée. Elle doit également être une image 32 bits avec un canal alpha.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p>pygame.Surface : Une nouvelle surface Pygame 32 bits avec les deux images mélangées ensemble, basée sur leurs valeurs alpha.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together using alpha blending</span>
<span class="n">new_image</span> <span class="o">=</span> <span class="n">alpha_blending</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>Cette fonction retourne une nouvelle surface et ne modifie pas les images <cite>source</cite> ou <cite>destination</cite> originales.</p></li>
<li><p>Les deux images doivent avoir un canal alpha pour garantir un mélange correct de la transparence.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectuer un mélange alpha sur deux images directement.</p>
<p>Cette fonction mélange deux images de mêmes dimensions, en modifiant la première image (<cite>image1</cite>). Le mélange est effectué en fonction du canal alpha, où la deuxième image (<cite>image2</cite>) est mélangée dans la première image.</p>
<p>Les deux images doivent être 32 bits avec un canal alpha et doivent avoir les mêmes dimensions. Le processus de mélange utilise les valeurs alpha des deux images pour calculer la transparence des pixels.</p>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>image1</cite> (pygame.Surface) : La première image à mélanger avec la deuxième image. Elle doit être une image 32 bits avec un canal alpha. Cette image est modifiée directement.</p></li>
<li><p><cite>image2</cite> (pygame.Surface) : La deuxième image à mélanger dans la première image. Elle doit également être une image 32 bits avec un canal alpha.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p>None : Cette fonction modifie la première image (<cite>image1</cite>) directement et ne retourne pas une nouvelle surface.</p></li>
</ul>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together in-place</span>
<span class="n">alpha_blending_inplace</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>Cette fonction effectue le mélange directement, en modifiant la surface <cite>image1</cite>.</p></li>
<li><p>Les images <cite>image1</cite> et <cite>image2</cite> doivent avoir les mêmes dimensions et inclure un canal alpha.</p></li>
<li><p>Si l’une des images n’a pas de canal alpha ou si les dimensions ne correspondent pas, une exception sera levée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.render_light_effect24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">render_light_effect24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">110</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.render_light_effect24" title="Lien vers cette définition">¶</a></dt>
<dd><p>Génère un effet lumineux réaliste sur une surface ou une texture Pygame.</p>
<p>Cette fonction simule un effet lumineux qui peut être mélangé sur une surface en utilisant le mélange additif (<cite>BLEND_RGBA_ADD</cite> dans Pygame). L’effet est généré à partir d’une texture de masque et peut inclure des améliorations optionnelles telles que le bloom, des vagues de chaleur et des ajustements de saturation.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">render_light_effect24</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">background_rgb</span><span class="p">,</span>
    <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
    <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
    <span class="n">heat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">frequency</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>x</cite> (int) : La coordonnée X de la source lumineuse. Elle doit être dans la largeur de l’écran.</p></li>
<li><p><cite>y</cite> (int) : La coordonnée Y de la source lumineuse. Elle doit être dans la hauteur de l’écran.</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, forme (w, h, 3), dtype uint8) : Un tableau NumPy 3D représentant les valeurs RGB de la surface de fond.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, forme (w, h), dtype uint8) : Un tableau NumPy 2D contenant les valeurs alpha (transparence) du masque lumineux. L’utilisation d’un masque de gradient radial avec une intensité maximale au centre est recommandée.</p></li>
<li><p><cite>intensity</cite> (float, optionnel, défaut=1.0) : Intensité de la lumière dans la plage [0.0, 20.0]. Des valeurs plus élevées produisent un effet plus fort.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, optionnel, défaut=[128.0, 128.0, 128.0]) : Un tableau NumPy à 3 éléments représentant la couleur RGB de la lumière au format float (valeurs dans la plage [0.0, 255.0]).</p></li>
<li><p><cite>smooth</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, applique un effet de flou pour lisser l’éclairage.</p></li>
<li><p><cite>saturation</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, applique un effet de saturation pour améliorer la vivacité des couleurs.</p></li>
<li><p><cite>sat_value</cite> (float, optionnel, défaut=0.2) : Ajuste le niveau de saturation. Le range valide est [-1.0, 1.0].</p></li>
<li><p><cite>bloom</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, active un effet de bloom, qui améliore la luminosité des zones intenses.</p></li>
<li><p><cite>threshold</cite> (int, optionnel, défaut=110) : Le seuil de luminosité utilisé pour l’effet de bloom. Les pixels au-dessus de cette valeur contribuent au bloom.</p></li>
<li><p><cite>heat</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, applique un effet de vagues de chaleur qui déforme dynamiquement l’éclairage.</p></li>
<li><p><cite>frequency</cite> (float, optionnel, défaut=1) : Détermine la fréquence de l’effet des vagues de chaleur. Cela doit être une valeur croissante.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul>
<li><p><cite>tuple</cite> : Un tuple contenant :</p>
<blockquote>
<div><ul class="simple">
<li><p>Une surface Pygame 24 bits représentant l’effet lumineux généré.</p></li>
<li><p>La largeur de la surface (<cite>sw</cite>).</p></li>
<li><p>La hauteur de la surface (<cite>sh</cite>).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La surface de sortie ne contient pas d’informations alpha par pixel.</p></li>
<li><p>Utilisez <cite>BLEND_RGBA_ADD</cite> lors du blitting de la surface pour obtenir un effet de lumière additive.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom_effect_array24_c2">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom_effect_array24_c2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom_effect_array24_c2" title="Lien vers cette définition">¶</a></dt>
<dd><p>Crée un effet de bloom sur une surface Pygame (surface 24 bits compatible).</p>
<p><strong>Définition</strong> :</p>
<p>Le bloom est un effet de graphisme informatique utilisé dans les jeux vidéo, les démonstrations et le rendu à plage dynamique élevée pour reproduire un artefact d’image des caméras du monde réel. L’effet simule les zones lumineuses d’une image qui brillent et se propagent vers les zones adjacentes, améliorant l’éclairage et la qualité visuelle de la scène.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/alpha.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="c1"># In the main loop</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bloom_effect_array24_c2</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame au format 24 bits sur laquelle l’effet de bloom sera appliqué.</p></li>
<li><p><cite>threshold_</cite> (char non signé) : Valeur de seuil utilisée par l’algorithme de passage lumineux. Par défaut, la valeur est 128, et elle détermine quels pixels sont considérés comme « assez lumineux » pour contribuer à l’effet de bloom.</p></li>
<li><p><cite>smooth_</cite> (int, optionnel, défaut=1) : Le nombre d’itérations de flou gaussien (5x5) à appliquer aux images réduites. Augmenter cette valeur créera un effet de lissage plus fort.</p></li>
<li><p><cite>mask_</cite> (pygame.Surface, optionnel, défaut=None) : Une surface Pygame représentant le masque alpha. Les valeurs alpha de ce masque déterminent combien de la surface doit être affectée par l’effet de bloom. Les valeurs alpha de 255 rendent complètement l’image et provoquent un effet de bloom, tandis que zéro masque les pixels correspondants.</p></li>
<li><p><cite>fast_</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, accélère le processus de bloom en utilisant une surface 16x et un filtre de passage lumineux optimisé, ce qui implique une réduction de la taille de la texture par un facteur de 4 avant le traitement.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite> : Une nouvelle surface Pygame avec l’effet de bloom appliqué (surface 24 bits).</p></li>
</ul>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La fonction applique un effet de bloom en effectuant d’abord un passage lumineux sur l’image, puis en appliquant un flou gaussien et en mélangeant le résultat avec la surface originale.</p></li>
<li><p>Le paramètre <cite>mask_</cite> peut être utilisé pour contrôler quelles parties de l’image vont rayonner en fonction des valeurs alpha.</p></li>
<li><p>Le paramètre <cite>fast_</cite> permet d’obtenir une version plus rapide, bien que de qualité inférieure, de l’effet de bloom.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.area24_cc">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">area24_cc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.area24_cc" title="Lien vers cette définition">¶</a></dt>
<dd><p>Génère un effet lumineux réaliste sur une surface ou une texture Pygame.</p>
<p>Cette fonction simule un effet lumineux qui peut être mélangé sur une surface en utilisant le mélange additif (<cite>BLEND_RGBA_ADD</cite> dans Pygame). Elle prend en charge des améliorations optionnelles telles que le bloom, le lissage et des ajustements de saturation.</p>
<p><strong>Modes d’éclairage</strong> : – - <strong>Lisse</strong> : Applique un flou gaussien avec un noyau 5x5 pour adoucir l’effet lumineux. - <strong>Saturation</strong> : Ajuste l’intensité des couleurs en utilisant la conversion des couleurs HSL. Une plage de valeurs de [-1.0, 1.0] est prise en charge, avec des valeurs plus élevées augmentant la vivacité et des valeurs inférieures à zéro désaturant le résultat. - <strong>Bloom</strong> : Améliore la luminosité en appliquant un effet de bloom, rendant les zones lumineuses plus intenses.</p>
<p><strong>Paramètres d’éclairage</strong> : - - <strong>Intensité</strong> : Définit la luminosité de la lumière. Si elle est réglée sur zéro, la fonction renvoie une <cite>pygame.Surface</cite> vide avec le drapeau <cite>RLEACCEL</cite>. - <strong>Couleur</strong> : Spécifie la couleur RGB de la lumière. Par défaut (128, 128, 128).</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">area24_cc</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">background_rgb</span><span class="p">,</span> <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>x</cite> (int) : Coordonnée X de la source lumineuse (doit être dans la largeur de l’écran).</p></li>
<li><p><cite>y</cite> (int) : Coordonnée Y de la source lumineuse (doit être dans la hauteur de l’écran).</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, forme (w, h, 3), dtype uint8) : Un tableau NumPy 3D représentant les valeurs RGB de la surface de fond.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, forme (w, h), dtype uint8) : Un tableau NumPy 2D contenant les valeurs alpha du masque lumineux. L’utilisation d’un masque de gradient radial avec une intensité maximale au centre est recommandée.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, optionnel, défaut=[128.0, 128.0, 128.0]) : Un tableau NumPy à 3 éléments représentant la couleur RGB de la lumière au format float (valeurs dans la plage [0.0, 255.0]).</p></li>
<li><p><cite>intensity</cite> (float, optionnel, défaut=1.0) : Intensité de la lumière dans la plage [0.0, 20.0]. Des valeurs plus élevées produisent un effet plus fort.</p></li>
<li><p><cite>smooth</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, applique un effet de flou pour adoucir l’éclairage.</p></li>
<li><p><cite>saturation</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, augmente l’intensité des couleurs en utilisant la conversion HSL.</p></li>
<li><p><cite>sat_value</cite> (float, optionnel, défaut=0.2) : Ajuste le niveau de saturation. Le range valide est [-1.0, 1.0]. Des valeurs plus élevées augmentent la vivacité, tandis que des valeurs négatives désaturent l’effet.</p></li>
<li><p><cite>bloom</cite> (bool, optionnel, défaut=False) : Si <cite>True</cite>, active un effet de bloom, améliorant la luminosité.</p></li>
<li><p><cite>bloom_threshold</cite> (char non signé, optionnel, défaut=64) : Le seuil de luminosité pour l’effet de bloom, dans la plage [0, 255]. Des valeurs plus basses créent un effet de bloom plus fort.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>tuple :</dt><dd><p>Un tuple contenant : - Une surface Pygame 24 bits représentant l’effet lumineux généré. - La largeur de la surface (<cite>sw</cite>). - La hauteur de la surface (<cite>sh</cite>).</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La surface de sortie ne contient pas d’informations alpha par pixel.</p></li>
<li><p>Utilisez <cite>BLEND_RGBA_ADD</cite> lors du blitting de la surface pour obtenir un effet de lumière additive.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic" title="Lien vers cette définition">¶</a></dt>
<dd><p>Abération chromatique (renvoie une nouvelle surface).</p>
<p>Cette fonction applique un effet d’abération chromatique à une surface donnée. L’amplitude de l’effet est proportionnelle à la distance par rapport au centre de l’effet, créant une distorsion des canaux de couleur RVB. L’effet d’abération chromatique simule le décalage de couleur qui se produit en raison des imperfections optique dans les lentilles.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">chromatic</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible 24 bits ou 32 bits sur laquelle l’effet d’abération chromatique sera appliqué.</p></li>
<li><p><cite>delta_x</cite> (int non signé) : La coordonnée X du centre de l’effet chromatique. Cette valeur doit être dans la plage [0, largeur de la surface].</p></li>
<li><p><cite>delta_y</cite> (int non signé) : La coordonnée Y du centre de l’effet chromatique. Cette valeur doit être dans la plage [0, hauteur de la surface].</p></li>
<li><p><cite>zoom</cite> (float, optionnel, défaut=0.9999) : Le facteur de zoom pour l’effet. Une valeur de 0.9999 signifie aucun zoom (image complète), tandis qu’une valeur inférieure à 1.0 effectuera un zoom avant. Elle doit être dans la plage [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, optionnel, défaut=0.02) : Le décalage appliqué aux canaux RGB. Cette valeur détermine l’intensité de l’effet d’abération chromatique et doit être dans la plage [0.0, 0.2].</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>pygame.Surface :</dt><dd><p>Une nouvelle surface Pygame avec l’effet d’abération chromatique appliqué.</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La fonction renvoie une nouvelle surface avec l’effet d’abération chromatique appliqué.</p></li>
<li><p>Les paramètres <cite>delta_x</cite> et <cite>delta_y</cite> définissent le point où l’effet chromatique est centré, et la distorsion devient plus prononcée à mesure que la distance par rapport à ce point augmente.</p></li>
<li><p>Les paramètres <cite>zoom</cite> et <cite>fx</cite> contrôlent respectivement l’étendue et l’intensité de l’effet.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Abération chromatique (sur place).</p>
<p>Cette fonction applique un effet d’abération chromatique à une surface donnée sur place. L’amplitude de l’effet est proportionnelle à la distance par rapport au centre de l’effet. Contrairement à la fonction <cite>chromatic</cite>, cette fonction modifie la surface originale plutôt que de renvoyer une nouvelle surface. Elle simule l’effet optique de distorsion des couleurs généralement observé en raison des imperfections des lentilles.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">chromatic_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : Une surface Pygame compatible 24 bits ou 32 bits sur laquelle l’effet d’abération chromatique sera appliqué sur place.</p></li>
<li><p><cite>delta_x</cite> (int non signé) : La coordonnée X du centre de l’effet chromatique. Cette valeur doit être dans la plage [0, largeur de la surface].</p></li>
<li><p><cite>delta_y</cite> (int non signé) : La coordonnée Y du centre de l’effet chromatique. Cette valeur doit être dans la plage [0, hauteur de la surface].</p></li>
<li><p><cite>zoom</cite> (float, optionnel, défaut=0.9999) : Le facteur de zoom pour l’effet. Une valeur de 0.9999 signifie aucun zoom (image complète), tandis qu’une valeur inférieure à 1.0 effectuera un zoom avant. Elle doit être dans la plage [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, optionnel, défaut=0.02) : Le décalage appliqué aux canaux RGB. Cette valeur détermine l’intensité de l’effet d’abération chromatique et doit être dans la plage [0.0, 0.2].</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>pygame.Surface :</dt><dd><p>La même surface Pygame avec l’effet d’abération chromatique appliqué sur place.</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La fonction modifie la surface originale plutôt que de renvoyer une nouvelle surface.</p></li>
<li><p>Les paramètres <cite>delta_x</cite> et <cite>delta_y</cite> définissent le point où l’effet chromatique est centré. L’effet devient plus prononcé à mesure que le pixel s’éloigne de ce point central.</p></li>
<li><p>Les paramètres <cite>zoom</cite> et <cite>fx</cite> contrôlent respectivement l’étendue et l’intensité de l’effet d’abération chromatique.</p></li>
<li><p>Cette fonction est utile lorsque vous souhaitez appliquer l’effet d’abération chromatique directement à une surface sans avoir à créer une nouvelle surface.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom" title="Lien vers cette définition">¶</a></dt>
<dd><p>Zoom dans une image (renvoie une copie).</p>
<p>Cette fonction effectue un zoom avant ou arrière sur une image vers un point central spécifié (delta_x, delta_y) en utilisant un facteur de zoom (zx). La fonction prend en charge les formats d’image 24 bits et 32 bits, et l’image de sortie aura le même format que l’entrée. L’effet de zoom est plus performant sur les images 24 bits.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface Pygame sur laquelle appliquer l’effet de zoom. Cela peut être une surface compatible 24 bits ou 32 bits.</p></li>
<li><p><cite>delta_x</cite> (entier non signé) : La coordonnée X du centre du zoom. Cette valeur doit être dans la plage [0, largeur de la surface].</p></li>
<li><p><cite>delta_y</cite> (entier non signé) : La coordonnée Y du centre du zoom. Cette valeur doit être dans la plage [0, hauteur de la surface].</p></li>
<li><p><cite>zx</cite> (flottant, optionnel, par défaut 0.9999) : Le facteur de zoom. Cette valeur doit être dans la plage (0.0, 1.0). Une valeur de 1.0 n’effectue pas de zoom (image entière), tandis que les valeurs proches de 0.0 effectuent un zoom avant. L’intensité du zoom est atténuée autour de 1.0, l’effet de zoom maximal se produisant lorsque zx approche 0.0.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>pygame.Surface :</dt><dd><p>Une nouvelle surface Pygame avec l’effet de zoom appliqué. L’image de sortie aura le même format (24 bits ou 32 bits) que l’image d’entrée.</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>L’effet de zoom est centré autour du point spécifié par <cite>delta_x</cite> et <cite>delta_y</cite>. Les pixels plus proches de ce centre apparaîtront moins zoomés, tandis que ceux plus éloignés subiront un zoom plus prononcé.</p></li>
<li><p>Cette fonction renvoie une nouvelle surface avec l’effet de zoom appliqué, laissant la surface originale inchangée.</p></li>
<li><p>Les performances sont généralement meilleures avec les images 24 bits en raison de moins de canaux de données à traiter.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Zoom dans une image (sur place).</p>
<p>Cette fonction effectue un zoom avant ou arrière sur une image vers un point central spécifié (delta_x, delta_y) en utilisant un facteur de zoom (zx), modifiant l’image sur place. La fonction prend en charge les formats d’image 24 bits et 32 bits, et le format de l’image d’entrée reste inchangé pendant le processus.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">zoom_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface Pygame sur laquelle appliquer l’effet de zoom. Cela peut être une surface compatible 24 bits ou 32 bits.</p></li>
<li><p><cite>delta_x</cite> (entier non signé) : La coordonnée X du centre du zoom. Cette valeur doit être dans la plage [0, largeur de la surface].</p></li>
<li><p><cite>delta_y</cite> (entier non signé) : La coordonnée Y du centre du zoom. Cette valeur doit être dans la plage [0, hauteur de la surface].</p></li>
<li><p><cite>zx</cite> (flottant, optionnel, par défaut 0.9999) : Le facteur de zoom. Cette valeur doit être dans la plage (0.0, 1.0). Une valeur de 1.0 n’effectue pas de zoom (image entière), tandis que les valeurs proches de 0.0 effectuent un zoom avant. L’effet de zoom est atténué autour de 1.0, l’effet de zoom maximal se produisant lorsque zx approche 0.0.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>None :</dt><dd><p>Cette fonction modifie <cite>surface_</cite> sur place. Elle ne renvoie pas une nouvelle surface.</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>L’effet de zoom est centré autour du point spécifié par <cite>delta_x</cite> et <cite>delta_y</cite>. Les pixels plus proches de ce centre apparaîtront moins zoomés, tandis que ceux plus éloignés subiront un zoom plus prononcé.</p></li>
<li><p>Cette fonction modifie directement la surface d’entrée, sans créer de nouvelle surface.</p></li>
<li><p>Les performances sont généralement meilleures avec les images 24 bits en raison de moins de canaux de données à traiter.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.Luma_GreyScale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">Luma_GreyScale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.Luma_GreyScale" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertir l’image en niveaux de gris en utilisant YIQ (information de luminance).</p>
<p>Cette fonction convertit l’image fournie en une image en niveaux de gris en utilisant le modèle de couleurs YIQ, qui se concentre sur l’information de luminance (luminosité). La fonction modifie l’image d’entrée sur place.</p>
<p><strong>Exemple d’utilisation</strong> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Luma_GreyScale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Paramètres</strong> :</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface) : La surface Pygame à convertir en niveaux de gris. Cette surface peut être dans n’importe quel format de couleur pris en charge par Pygame.</p></li>
</ul>
<p><strong>Retour</strong> :</p>
<dl class="simple">
<dt>None :</dt><dd><p>La fonction modifie la surface d’entrée <cite>surface_</cite> sur place, la convertissant en niveaux de gris. Elle ne renvoie pas une nouvelle surface.</p>
</dd>
</dl>
<p><strong>Notes</strong> :</p>
<ul class="simple">
<li><p>La conversion utilise le modèle de couleurs YIQ, en particulier la composante luma (Y), qui représente la luminosité de l’image.</p></li>
<li><p>La surface d’entrée est modifiée directement et aucune nouvelle surface n’est renvoyée.</p></li>
</ul>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader</a><ul>
<li><a class="reference internal" href="#high-performance-image-processing-library">1. Bibliothèque de traitement d’image haute performance</a></li>
<li><a class="reference internal" href="#key-features">2. Fonctionnalités principales</a></li>
<li><a class="reference internal" href="#library-functional-overview">3. Aperçu fonctionnel de la bibliothèque</a></li>
<li><a class="reference internal" href="#target-applications">4. Applications ciblées</a></li>
<li><a class="reference internal" href="#summary">5. Résumé</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Méthodes de liste en Cython</a><ul>
<li><a class="reference internal" href="#Shader.bgr"><code class="docutils literal notranslate"><span class="pre">bgr()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_copy"><code class="docutils literal notranslate"><span class="pre">bgr_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_3d"><code class="docutils literal notranslate"><span class="pre">bgr_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d"><code class="docutils literal notranslate"><span class="pre">bgr_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d_cp"><code class="docutils literal notranslate"><span class="pre">bgr_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg"><code class="docutils literal notranslate"><span class="pre">brg()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_copy"><code class="docutils literal notranslate"><span class="pre">brg_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_3d"><code class="docutils literal notranslate"><span class="pre">brg_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d"><code class="docutils literal notranslate"><span class="pre">brg_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d_cp"><code class="docutils literal notranslate"><span class="pre">brg_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey"><code class="docutils literal notranslate"><span class="pre">grey()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_copy"><code class="docutils literal notranslate"><span class="pre">grey_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_2d"><code class="docutils literal notranslate"><span class="pre">grey_2d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_3d"><code class="docutils literal notranslate"><span class="pre">grey_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d"><code class="docutils literal notranslate"><span class="pre">grey_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d_cp"><code class="docutils literal notranslate"><span class="pre">grey_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia"><code class="docutils literal notranslate"><span class="pre">sepia()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_copy"><code class="docutils literal notranslate"><span class="pre">sepia_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_3d"><code class="docutils literal notranslate"><span class="pre">sepia_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_1d"><code class="docutils literal notranslate"><span class="pre">sepia_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median"><code class="docutils literal notranslate"><span class="pre">median()</span></code></a></li>
<li><a class="reference internal" href="#Shader.painting"><code class="docutils literal notranslate"><span class="pre">painting()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixels"><code class="docutils literal notranslate"><span class="pre">pixels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median_grayscale"><code class="docutils literal notranslate"><span class="pre">median_grayscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.posterize_surface"><code class="docutils literal notranslate"><span class="pre">posterize_surface()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel"><code class="docutils literal notranslate"><span class="pre">sobel()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_1d"><code class="docutils literal notranslate"><span class="pre">sobel_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_fast"><code class="docutils literal notranslate"><span class="pre">sobel_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert"><code class="docutils literal notranslate"><span class="pre">invert()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert_copy"><code class="docutils literal notranslate"><span class="pre">invert_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert3d"><code class="docutils literal notranslate"><span class="pre">invert3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d"><code class="docutils literal notranslate"><span class="pre">invert1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d_cp"><code class="docutils literal notranslate"><span class="pre">invert1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl_effect"><code class="docutils literal notranslate"><span class="pre">hsl_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl3d"><code class="docutils literal notranslate"><span class="pre">hsl3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d"><code class="docutils literal notranslate"><span class="pre">hsl1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d_cp"><code class="docutils literal notranslate"><span class="pre">hsl1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv_effect"><code class="docutils literal notranslate"><span class="pre">hsv_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv3d"><code class="docutils literal notranslate"><span class="pre">hsv3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d"><code class="docutils literal notranslate"><span class="pre">hsv1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d_cp"><code class="docutils literal notranslate"><span class="pre">hsv1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave"><code class="docutils literal notranslate"><span class="pre">wave()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave32"><code class="docutils literal notranslate"><span class="pre">wave32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave_static"><code class="docutils literal notranslate"><span class="pre">wave_static()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl"><code class="docutils literal notranslate"><span class="pre">swirl()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl32"><code class="docutils literal notranslate"><span class="pre">swirl32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirlf"><code class="docutils literal notranslate"><span class="pre">swirlf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma_config"><code class="docutils literal notranslate"><span class="pre">plasma_config()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma"><code class="docutils literal notranslate"><span class="pre">plasma()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness"><code class="docutils literal notranslate"><span class="pre">brightness()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness3d"><code class="docutils literal notranslate"><span class="pre">brightness3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d"><code class="docutils literal notranslate"><span class="pre">brightness1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d_copy"><code class="docutils literal notranslate"><span class="pre">brightness1d_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_copy"><code class="docutils literal notranslate"><span class="pre">brightness_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_exclude"><code class="docutils literal notranslate"><span class="pre">brightness_exclude()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_bpf"><code class="docutils literal notranslate"><span class="pre">brightness_bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation"><code class="docutils literal notranslate"><span class="pre">saturation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation3d"><code class="docutils literal notranslate"><span class="pre">saturation3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d"><code class="docutils literal notranslate"><span class="pre">saturation1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d_cp"><code class="docutils literal notranslate"><span class="pre">saturation1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatconvection"><code class="docutils literal notranslate"><span class="pre">heatconvection()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_glitch"><code class="docutils literal notranslate"><span class="pre">horizontal_glitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_sglitch"><code class="docutils literal notranslate"><span class="pre">horizontal_sglitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bpf"><code class="docutils literal notranslate"><span class="pre">bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom"><code class="docutils literal notranslate"><span class="pre">bloom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint_param"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint_param()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye"><code class="docutils literal notranslate"><span class="pre">fisheye()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tv_scan"><code class="docutils literal notranslate"><span class="pre">tv_scan()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple"><code class="docutils literal notranslate"><span class="pre">ripple()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple_seabed"><code class="docutils literal notranslate"><span class="pre">ripple_seabed()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatmap"><code class="docutils literal notranslate"><span class="pre">heatmap()</span></code></a></li>
<li><a class="reference internal" href="#Shader.predator_vision"><code class="docutils literal notranslate"><span class="pre">predator_vision()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blood"><code class="docutils literal notranslate"><span class="pre">blood()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring_array"><code class="docutils literal notranslate"><span class="pre">mirroring_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring"><code class="docutils literal notranslate"><span class="pre">mirroring()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen"><code class="docutils literal notranslate"><span class="pre">sharpen()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d"><code class="docutils literal notranslate"><span class="pre">sharpen_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d_cp"><code class="docutils literal notranslate"><span class="pre">sharpen_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen32"><code class="docutils literal notranslate"><span class="pre">sharpen32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dirt_lens"><code class="docutils literal notranslate"><span class="pre">dirt_lens()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering"><code class="docutils literal notranslate"><span class="pre">dithering()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_inplace"><code class="docutils literal notranslate"><span class="pre">dithering_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d"><code class="docutils literal notranslate"><span class="pre">dithering1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d_cp"><code class="docutils literal notranslate"><span class="pre">dithering1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson1d"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixelation"><code class="docutils literal notranslate"><span class="pre">pixelation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend"><code class="docutils literal notranslate"><span class="pre">blend()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend1d"><code class="docutils literal notranslate"><span class="pre">blend1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend_inplace"><code class="docutils literal notranslate"><span class="pre">blend_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.cartoon"><code class="docutils literal notranslate"><span class="pre">cartoon()</span></code></a></li>
<li><a class="reference internal" href="#Shader.convert_27"><code class="docutils literal notranslate"><span class="pre">convert_27()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilateral"><code class="docutils literal notranslate"><span class="pre">bilateral()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss"><code class="docutils literal notranslate"><span class="pre">emboss()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_inplace"><code class="docutils literal notranslate"><span class="pre">emboss_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss1d"><code class="docutils literal notranslate"><span class="pre">emboss1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_gray"><code class="docutils literal notranslate"><span class="pre">emboss_gray()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilinear"><code class="docutils literal notranslate"><span class="pre">bilinear()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling24"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render24"><code class="docutils literal notranslate"><span class="pre">tunnel_render24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling32"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render32"><code class="docutils literal notranslate"><span class="pre">tunnel_render32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast1"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast1()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels"><code class="docutils literal notranslate"><span class="pre">split_channels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels_inplace"><code class="docutils literal notranslate"><span class="pre">split_channels_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wavelength2rgb"><code class="docutils literal notranslate"><span class="pre">wavelength2rgb()</span></code></a></li>
<li><a class="reference internal" href="#Shader.custom_map"><code class="docutils literal notranslate"><span class="pre">custom_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blue_map"><code class="docutils literal notranslate"><span class="pre">blue_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bluescale"><code class="docutils literal notranslate"><span class="pre">bluescale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.red_map"><code class="docutils literal notranslate"><span class="pre">red_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.redscale"><code class="docutils literal notranslate"><span class="pre">redscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dampening"><code class="docutils literal notranslate"><span class="pre">dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.lateral_dampening"><code class="docutils literal notranslate"><span class="pre">lateral_dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending"><code class="docutils literal notranslate"><span class="pre">alpha_blending()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending_inplace"><code class="docutils literal notranslate"><span class="pre">alpha_blending_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.render_light_effect24"><code class="docutils literal notranslate"><span class="pre">render_light_effect24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom_effect_array24_c2"><code class="docutils literal notranslate"><span class="pre">bloom_effect_array24_c2()</span></code></a></li>
<li><a class="reference internal" href="#Shader.area24_cc"><code class="docutils literal notranslate"><span class="pre">area24_cc()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic"><code class="docutils literal notranslate"><span class="pre">chromatic()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic_inplace"><code class="docutils literal notranslate"><span class="pre">chromatic_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom"><code class="docutils literal notranslate"><span class="pre">zoom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom_inplace"><code class="docutils literal notranslate"><span class="pre">zoom_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.Luma_GreyScale"><code class="docutils literal notranslate"><span class="pre">Luma_GreyScale()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="index.html"
                          title="Chapitre précédent">Bienvenue dans la documentation de PygameShader !</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="Shader_gpu.html"
                          title="Chapitre suivant">Shader_gpu</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             >suivant</a> |</li>
        <li class="right" >
          <a href="index.html" title="Bienvenue dans la documentation de PygameShader !"
             >précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>