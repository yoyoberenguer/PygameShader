
<!DOCTYPE html>

<html lang="fr" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader_gpu &#8212; Documentation PygameShader 1.0.11</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=1b8a1eab"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=e6b791cb"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="PygameTools" href="PygameTools.html" />
    <link rel="prev" title="Shader" href="Shader.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             accesskey="N">suivant</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Shader"
             accesskey="P">précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader-gpu">
<h1>Shader_gpu<a class="headerlink" href="#shader-gpu" title="Lien vers cette rubrique">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader_gpu.pyx</span></code></p>
<hr class="docutils" />
<section id="gpu-accelerated-image-processing-library">
<span id="gpu-image-processing-summary"></span><h2>1. Bibliothèque de traitement d’images accélérée par GPU<a class="headerlink" href="#gpu-accelerated-image-processing-library" title="Lien vers cette rubrique">¶</a></h2>
<p>Cette bibliothèque offre des fonctionnalités de traitement d’images accélérées par GPU en exploitant <strong>CUDA</strong> (via <strong>CuPy</strong>) pour exécuter efficacement diverses transformations et filtres d’images sur les <strong>GPU NVIDIA</strong>. Son objectif principal est d’accélérer les opérations de traitement d’images coûteuses en calcul, qui seraient autrement lentes sur un CPU.</p>
</section>
<section id="key-features-use-cases">
<h2>2. Principales fonctionnalités et cas d’utilisation<a class="headerlink" href="#key-features-use-cases" title="Lien vers cette rubrique">¶</a></h2>
<p><strong>Mémoire GPU et informations matérielles</strong> Récupérer des détails sur la mémoire GPU disponible, l’identifiant du bus PCI et la capacité de calcul. <strong>Cas d’utilisation</strong> : Utile pour gérer dynamiquement l’allocation de mémoire et optimiser les tâches de traitement parallèle.</p>
<dl class="simple">
<dt><strong>Traitement d’images et filtres</strong></dt><dd><p>Exécuter efficacement des filtres d’image courants sur le GPU, notamment :</p>
</dd>
</dl>
<ul class="simple">
<li><p><strong>Inversion</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">invert_gpu()</span></code></p></li>
<li><p><strong>Niveaux de gris et sépia</strong> : <code class="xref py py-func docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></p></li>
<li><p><strong>Détection des contours</strong> : Sobel, Prewitt, Canny</p></li>
<li><p><strong>Filtres de flou et de lissage</strong> : Gaussien, Médian, Bilatéral</p></li>
<li><p><strong>Relief et netteté</strong></p></li>
</ul>
</section>
<section id="use-case">
<h2>3. Cas d’utilisation<a class="headerlink" href="#use-case" title="Lien vers cette rubrique">¶</a></h2>
<blockquote>
<div><p>Optimisé pour le traitement en temps réel de vidéos et d’images en exécutant ces opérations en parallèle sur le GPU.</p>
</div></blockquote>
<p><strong>Manipulation et amélioration des couleurs</strong> Ajuster les propriétés de l’image telles que la luminosité, le contraste, la saturation et les valeurs HSL/HSV.</p>
<p><strong>Cas d’utilisation</strong> : Idéal pour l’amélioration des images, les applications de réalité augmentée (AR) et les logiciels de retouche photo.</p>
<p><strong>Effets spéciaux et transformations</strong> Appliquer des transformations et effets artistiques, notamment :</p>
<ul class="simple">
<li><p><strong>Effets tourbillon, fisheye, onde, ondulation</strong></p></li>
<li><p><strong>Aberration chromatique et séparation des canaux RGB</strong></p></li>
<li><p><strong>Effet bande dessinée et filtres d’éclat (bloom)</strong></p></li>
<li><p><strong>Effets de tramage et de carte thermique</strong></p></li>
</ul>
<p><strong>Cas d’utilisation</strong> : Utile pour le développement de jeux, les effets visuels (VFX) et les applications en infographie.</p>
<p><strong>Transformations géométriques</strong> Prise en charge des transformations géométriques telles que :</p>
<ul class="simple">
<li><p><strong>Miroir</strong></p></li>
<li><p><strong>Zoom</strong></p></li>
<li><p><strong>Réduction d’échelle</strong></p></li>
<li><p><strong>Fusion</strong></p></li>
</ul>
<p><strong>Cas d’utilisation</strong> : Peut être utilisé pour la compression d’images, le mappage de textures et le rendu en temps réel.</p>
<p><strong>Traitement vidéo en temps réel</strong> Les effets vidéo en temps réel sont pris en charge par des fonctions telles que <code class="xref py py-func docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">predator_gpu()</span></code>, et <code class="xref py py-func docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code>.</p>
<p><strong>Cas d’utilisation</strong> : Idéal pour une intégration dans des logiciels de streaming, des filtres vidéo ou des systèmes de surveillance.</p>
</section>
<section id="potential-applications">
<h2>4. Applications potentielles<a class="headerlink" href="#potential-applications" title="Lien vers cette rubrique">¶</a></h2>
<ul class="simple">
<li><p><strong>Traitement d’images et de vidéos en temps réel</strong> : Améliorer les flux vidéo en temps réel.</p></li>
<li><p><strong>Vision par ordinateur et prétraitement pour l’IA</strong> : Appliquer des filtres rapides avant de transmettre les images aux modèles d’apprentissage automatique.</p></li>
<li><p><strong>Développement de jeux et graphismes</strong> : Ajouter des effets spéciaux pour les jeux et les environnements de simulation.</p></li>
<li><p><strong>Réalité augmentée et virtuelle (AR/VR)</strong> : Optimiser les visuels pour des expériences immersives.</p></li>
<li><p><strong>Outils de photographie haute performance</strong> : Modifier de grandes images efficacement grâce au GPU.</p></li>
</ul>
</section>
<section id="summary">
<h2>5. Résumé<a class="headerlink" href="#summary" title="Lien vers cette rubrique">¶</a></h2>
<p>Cette bibliothèque décharge les tâches complexes de traitement d’images du CPU vers le GPU, rendant les opérations beaucoup plus rapides et efficaces. Elle est idéale pour les applications nécessitant des performances en temps réel, telles que les jeux, l’AR/VR, le streaming vidéo et le traitement d’images basé sur l’IA.</p>
</section>
<section id="cython-list-methods">
<h2>6. Méthodes de liste en Cython<a class="headerlink" href="#cython-list-methods" title="Lien vers cette rubrique">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_free_mem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_free_mem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_free_mem" title="Lien vers cette définition">¶</a></dt>
<dd><p>Récupérer la mémoire libre disponible sur le GPU.</p>
<p>Cette fonction interroge le GPU pour connaître la mémoire actuellement disponible et retourne la quantité en octets. Elle est utile pour surveiller l’utilisation de la mémoire lors de calculs accélérés par GPU, garantissant que les opérations ne dépassent pas la mémoire disponible.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>int</strong> : La quantité de mémoire libre du GPU en octets.</p></li>
</ul>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">free_mem</span> <span class="o">=</span> <span class="n">get_gpu_free_mem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available GPU Memory: </span><span class="si">{</span><span class="n">free_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_maxmem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_maxmem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_maxmem" title="Lien vers cette définition">¶</a></dt>
<dd><p>Récupérer la capacité mémoire totale du GPU.</p>
<p>Cette fonction interroge le GPU pour déterminer sa mémoire totale disponible, ce qui représente la capacité totale de la VRAM du GPU.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>int</strong> : La mémoire totale du GPU en octets.</p></li>
</ul>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_mem</span> <span class="o">=</span> <span class="n">get_gpu_maxmem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total GPU Memory: </span><span class="si">{</span><span class="n">total_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_pci_bus_id">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_pci_bus_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_pci_bus_id" title="Lien vers cette définition">¶</a></dt>
<dd><p>Récupérer l’identifiant du bus PCI du GPU.</p>
<p>Cette fonction interroge le GPU et retourne son identifiant de bus PCI, qui permet d’identifier de manière unique le GPU dans le système. L’identifiant PCI est utile pour les configurations multi-GPU, le débogage et la gestion des périphériques.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>str</strong> : L’identifiant du bus PCI du GPU au format « Domaine:Bus:Périphérique.Fonction » (ex. : « 0000:01:00.0 »).</p></li>
</ul>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pci_id</span> <span class="o">=</span> <span class="n">get_gpu_pci_bus_id</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU PCI Bus ID: </span><span class="si">{</span><span class="n">pci_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_compute_capability">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_compute_capability</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_compute_capability" title="Lien vers cette définition">¶</a></dt>
<dd><p>Récupérer la capacité de calcul du GPU.</p>
<p>La capacité de calcul représente la version de l’architecture du GPU et détermine sa compatibilité avec différentes fonctionnalités CUDA. Des valeurs plus élevées indiquent la prise en charge de fonctionnalités et d’optimisations plus avancées.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>str</strong> : La capacité de calcul du GPU sous forme de chaîne de caractères au format « majeur.mineur » (ex. : « 7.5 » pour les GPU NVIDIA Turing).</p></li>
</ul>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">capability</span> <span class="o">=</span> <span class="n">get_compute_capability</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU Compute Capability: </span><span class="si">{</span><span class="n">capability</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_max_grid_per_block">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_max_grid_per_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_max_grid_per_block" title="Lien vers cette définition">¶</a></dt>
<dd><p>Récupérer le nombre maximal de blocs de grille par multiprocesseur.</p>
<p>Cette fonction retourne le nombre maximal de blocs de grille pouvant être actifs par multiprocesseur sur le GPU. Cette valeur est essentielle pour optimiser les charges de travail parallèles et garantir une utilisation efficace des ressources.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>unsigned int</strong> : Le nombre maximal de blocs de grille par multiprocesseur.</p></li>
</ul>
<p><strong>Exemple d’utilisation :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_grid_blocks</span> <span class="o">=</span> <span class="n">get_max_grid_per_block</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max grid blocks per multiprocessor: </span><span class="si">{</span><span class="n">max_grid_blocks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La valeur retournée dépend de la capacité de calcul du GPU.</p></li>
<li><p>For instance, GPUs with Compute Capability 2.x support up to
8 active blocks per multiprocessor, while Compute Capability 3.x
and higher can support up to 16 or more active blocks per multiprocessor.
Refer to NVIDIA’s CUDA programming guide for specific values per architecture.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_grid">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_grid" title="Lien vers cette définition">¶</a></dt>
<dd><p>Automatically computes optimal grid and block sizes for GPU execution.</p>
<p>This function determines the best grid and block configuration for GPU execution based on
the dimensions of the display (or computational domain). It ensures that the computed grid
and block sizes are valid and compatible with the given width (<cite>w</cite>) and height (<cite>h</cite>).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>): The width of the display or computational domain. Must be greater than 0.</p></li>
<li><p><strong>h</strong> (<em>int</em>): The height of the display or computational domain. Must be greater than 0.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong>: A tuple containing:
- <cite>grid</cite>: (<em>y, x</em>) - The computed grid size (number of blocks in each dimension).
- <cite>block</cite>: (<em>yy, xx</em>) - The computed block size (number of threads per block in each dimension).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>:
- If <cite>w</cite> or <cite>h</cite> is less than or equal to 0.
- If the computed grid and block sizes are not valid (i.e., they do not exactly cover the input dimensions).</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>The function first determines possible divisors of <cite>w</cite> and <cite>h</cite>, then selects block sizes that
do not exceed 32 (a common maximum block size for GPU execution).</p></li>
<li><p>The final grid size is determined by dividing the input dimensions by the selected block sizes.</p></li>
<li><p>If the computed configuration is invalid (i.e., <cite>yy * y != h</cite> or <cite>xx * x != w</cite>), an assertion
error is raised, suggesting that manual configuration might be necessary.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="n">block_grid</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>  <span class="c1"># Output: (4, 4) (16, 16)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.conv">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">conv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.conv" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une valeur en un format lisible par l’homme, en la mettant à l’échelle par puissances de 1024 (par exemple, KB, MB, GB).</p>
<p>Cette fonction divise la valeur d’entrée <cite>v</cite> par 1024 de manière répétée jusqu’à ce qu’elle soit inférieure ou égale à 1024. Elle retourne ensuite la valeur avec l’unité appropriée (par exemple, KB, MB, GB) en fonction du nombre de divisions effectuées.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>v</strong> (<em>float</em> ou <em>int</em>) : La valeur à convertir (représentant généralement des octets ou une taille de données).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>str</strong> : Une chaîne de caractères lisible par l’homme représentant la valeur avec une unité appropriée, arrondie à 3 décimales.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise les unités suivantes : - 1024 octets = 1 KB - 1024 KB = 1 MB - 1024 MB = 1 GB - et ainsi de suite…</p></li>
<li><p>Si la valeur d’entrée <cite>v</cite> est inférieure à 1024, elle sera retournée telle quelle avec la première unité.</p></li>
<li><p>La fonction garantit que l’unité appropriée est sélectionnée en fonction de l’échelle de <cite>v</cite>.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">conv</span><span class="p">(</span><span class="mi">1048576</span><span class="p">)</span>  <span class="c1"># Returns &#39;1.0 MB&#39;</span>
<span class="n">conv</span><span class="p">(</span><span class="mi">123456789</span><span class="p">)</span>  <span class="c1"># Returns &#39;117.74 MB&#39;</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_and_grid_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_and_grid_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_and_grid_info" title="Lien vers cette définition">¶</a></dt>
<dd><p>Calcule et affiche les dimensions optimales des blocs et de la grille GPU pour une taille d’image donnée.</p>
<p>Cette fonction détermine les tailles de grille et de bloc requises pour une parallélisation optimale sur le GPU. Elle utilise la fonction <cite>block_grid</cite> pour obtenir les meilleures tailles de bloc et de grille en fonction de la largeur (<cite>w</cite>) et de la hauteur (<cite>h</cite>) de l’image ou de l’affichage fournis.</p>
<p>Les tailles de bloc et de grille sont ensuite validées pour s’assurer qu’elles couvrent correctement toute la surface. Si la validation échoue, des assertions sont levées. Ensuite, la fonction affiche les tailles de grille et de bloc résultantes.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>) : La largeur de l’image ou de l’affichage (doit être supérieure à 0).</p></li>
<li><p><strong>h</strong> (<em>int</em>) : La hauteur de l’image ou de l’affichage (doit être supérieure à 0).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong> : - Si <cite>w</cite> ou <cite>h</cite> est négatif ou nul. - Si les tailles calculées de grille et de bloc ne couvrent pas correctement l’image.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : Cette fonction affiche uniquement les informations relatives à la grille et aux blocs GPU. Elle ne retourne aucune valeur.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">block_and_grid_info</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">)</span>
<span class="c1"># Output:</span>
<span class="c1"># GPU GRID        : (grid_y=34.000000, grid_x=60.000000)</span>
<span class="c1"># GPU BLOCK       : (block_y=32.000000, block_x=32.000000)</span>
</pre></div>
</div>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La grille est déterminée par le nombre de blocs nécessaires pour couvrir la hauteur et la largeur de l’image.</p></li>
<li><p>La taille du bloc fait référence à la taille de chaque bloc individuel de threads dans le GPU.</p></li>
<li><p>Cette fonction suppose que le traitement GPU sera optimisé pour les tailles de grille et de bloc calculées.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_info" title="Lien vers cette définition">¶</a></dt>
<dd><p>Affiche des informations détaillées sur le GPU, y compris la mémoire, la capacité de calcul et l’identifiant du bus PCI.</p>
<p>Cette fonction récupère et affiche divers détails sur le GPU, notamment : - La version de CuPy installée. - La taille maximale de grille par bloc prise en charge par le GPU. - La mémoire GPU disponible et totale, en octets et en formats lisibles par l’homme. - L’identifiant du bus PCI du GPU. - La capacité de calcul du GPU.</p>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : Cette fonction affiche les informations relatives au GPU dans la console.</p></li>
</ul>
<p><strong>Exemple de sortie :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_gpu_info</span><span class="p">()</span>
<span class="c1"># Output:</span>
<span class="c1"># CUPY VERSION           : 11.2.0</span>
<span class="c1"># GPU MAX GRID PER BLOCK : 65535</span>
<span class="c1"># GPU FREE MEMORY        : (mem=8388608000.000000, (8.0 GB))</span>
<span class="c1"># GPU MAX MEMORY         : (mem=17179869184.000000, (16.0 GB))</span>
<span class="c1"># GPU PCI BUS ID         : (bus=0000:01:00.0)</span>
<span class="c1"># GPU CAPABILITY         : (capa=7.5)</span>
</pre></div>
</div>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction repose sur CuPy pour obtenir des informations sur la mémoire GPU.</p></li>
<li><p>La fonction <cite>conv</cite> est utilisée pour convertir les valeurs brutes de mémoire en un format plus lisible (par exemple, GB).</p></li>
<li><p>Cette fonction est utile pour le débogage et la vérification de la disponibilité des ressources GPU avant de lancer des opérations basées sur CUDA.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectue une inversion des couleurs accélérée par GPU sur une surface Pygame (retourne une copie).</p>
<p>Cette fonction transfère les données d’image d’un <cite>pygame.Surface</cite> vers le GPU, inverse les valeurs de couleur à l’aide de CuPy, puis reconstruit une nouvelle surface avec les pixels modifiés.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Un objet Pygame Surface (24 bits ou 32 bits) contenant l’image à inverser.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame avec les couleurs inversées, conservant le format original (BGR ou BGRA).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong> : Si la surface ne peut pas être référencée comme un tampon 1D ou a une longueur nulle.</p></li>
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas un objet <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Utilise CuPy pour effectuer l’inversion directement sur le GPU afin d’optimiser les performances.</p></li>
<li><p>Détecte automatiquement si la surface est en 24 bits (BGR) ou 32 bits (BGRA).</p></li>
<li><p>Synchronise le GPU pour garantir la fin du traitement avant de retourner l’image modifiée.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">inverted_surface</span> <span class="o">=</span> <span class="n">invert_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">inverted_surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectuer une inversion des couleurs en place accélérée par GPU sur une surface Pygame.</p>
<p>Cette fonction modifie directement les données des pixels de la <cite>pygame.Surface</cite> donnée en inversant ses valeurs de couleur via un traitement GPU avec CuPy. L’inversion est effectuée en place, ce qui signifie que la surface d’origine est modifiée sans en créer une nouvelle.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface Pygame dont les couleurs des pixels seront inversées. Doit être une surface valide en 24 bits (BGR) ou en 32 bits (BGRA).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si le tampon de la surface ne peut pas être accédé ou a une longueur nulle.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction transfère les données des pixels vers le GPU, effectue l’inversion, puis copie les pixels modifiés dans la surface d’origine.</p></li>
<li><p>Utilise CuPy pour un calcul efficace sur GPU.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">invert_gpu_inplace</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_buffer_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectuer une inversion en place d’un tampon de pixels BGR à l’aide du GPU.</p>
<p>Cette fonction prend un tampon BGR contigu 1D (sous forme de tableau NumPy ou de memoryview), le transfère vers le GPU, inverse les valeurs des pixels (255 - valeur du pixel), puis réécrit le résultat dans le tampon d’origine.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> ou <em>memoryview</em>) : Un tableau 1D contigu représentant le tampon de pixels BGR. Le tampon doit être modifiable et non vide.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>bgr_array</cite> n’est pas un tableau NumPy ou un memoryview.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>bgr_array</cite> est vide (longueur nulle).</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction modifie <cite>bgr_array</cite> en place.</p></li>
<li><p>Utilise CuPy avec prise en charge CUDA pour l’accélération GPU.</p></li>
<li><p>Convient au traitement d’images haute performance nécessitant une modification en place.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Example BGR array</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to CuPy array</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Invert colors in place</span>
<span class="n">invert_buffer_gpu</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to NumPy array</span>
<span class="n">inverted_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inverted_bgr_array</span><span class="p">)</span>  <span class="c1"># Output: [  0 255 255 255   0 255 255 255   0]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_rgb_array_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_rgb_array_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_rgb_array_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Inverse les valeurs RGB d’une image (tableau NumPy 3D ou memoryview) en place à l’aide du GPU.</p>
<p>Cette fonction effectue une inversion en place des canaux RGB dans le tableau d’entrée. Elle suppose que <cite>rgb_array</cite> est un tableau NumPy 3D ou un memoryview avec la forme (hauteur, largeur, 3), où la dernière dimension représente les canaux de couleur RGB.</p>
<p><strong>Remarque</strong> : Cette opération est effectuée sur GPU pour accélérer le calcul.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em> ou <em>memoryview</em>) : Un tableau 3D ou un memoryview de forme (hauteur, largeur, 3) contenant les valeurs RGB de l’image. Le dtype doit être <em>numpy.uint8</em>. Si <cite>rgb_array</cite> est un memoryview, il doit être d’un type compatible.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>rgb_array</cite> n’est pas un <em>numpy.ndarray</em> ou <em>memoryview</em>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>rgb_array</cite> n’est pas du dtype <em>numpy.uint8</em> ou n’a pas 3 dimensions. Si la largeur ou la hauteur du tableau est nulle.</p></li>
</ul>
<p><strong>Description :</strong></p>
<p>Cette fonction modifie directement le tableau d’entrée <cite>rgb_array</cite> en inversant les canaux RGB à l’aide d’opérations accélérées par GPU. L’inversion se fait en place, ce qui signifie que le tableau d’origine sera mis à jour. Le GPU est utilisé pour effectuer l’inversion de manière efficace.</p>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a white image of shape (100, 100, 3)</span>
<span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

<span class="c1"># Invert the image colors in place</span>
<span class="n">invert_rgb_array_inplace</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">)</span>

<span class="c1"># Print the color of the first pixel, should be black [0, 0, 0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un shader Sepia à une surface Pygame et retourne une nouvelle surface avec l’effet Sepia appliqué.</p>
<p>Cette fonction fonctionne avec des surfaces Pygame de profondeur de couleur 32 bits et 24 bits. Elle utilise des calculs basés sur le GPU pour transformer les couleurs des pixels en appliquant un filtre Sepia.</p>
<p>La fonction vérifie d’abord le type de la surface fournie pour s’assurer qu’il s’agit d’une surface Pygame valide. Ensuite, elle extrait les données des pixels de la surface, applique le filtre Sepia en utilisant un noyau basé sur le GPU, puis retourne une nouvelle surface Pygame avec l’image transformée.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Un objet Surface Pygame contenant l’image à laquelle le filtre Sepia sera appliqué. La surface doit être en format 32 bits ou 24 bits.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Un nouvel objet Surface Pygame avec les mêmes dimensions et le filtre Sepia appliqué, au format « RGB ».</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer l’effet Sepia de manière efficace.</p></li>
<li><p>La surface d’entrée n’est pas modifiée ; une nouvelle surface avec l’effet Sepia est retournée.</p></li>
<li><p>Assurez-vous que la surface Pygame soit dans un format compatible (24 bits ou 32 bits) avant d’appliquer le filtre.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sepia filter</span>
<span class="n">sepia_surface</span> <span class="o">=</span> <span class="n">sepia_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sepia_surface</span><span class="p">,</span> <span class="s2">&quot;sepia_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_rgb_array_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_rgb_array_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_rgb_array_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre Sepia en place à un tableau d’image RGB en utilisant l’accélération GPU.</p>
<p>Cette fonction traite une image 32 bits ou 24 bits en place en modifiant le <cite>numpy.ndarray</cite> fourni de forme (w, h, 3) contenant les valeurs RGB en uint8. L’effet Sepia est appliqué directement au tableau d’entrée sans créer un nouveau tableau.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em>) : Un tableau 3D numpy de forme (w, h, 3), représentant une image avec des valeurs de pixels RGB en type de données uint8. La forme doit représenter la largeur (w), la hauteur (h), et les trois canaux (Rouge, Vert, Bleu).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : Cette fonction modifie <cite>rgb_array</cite> en place et ne retourne rien.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer l’effet Sepia de manière efficace.</p></li>
<li><p>Le tableau d’entrée est modifié directement ; aucun nouveau tableau n’est créé.</p></li>
<li><p>Assurez-vous que le tableau d’entrée soit du dtype <cite>numpy.uint8</cite> et ait trois dimensions représentant les canaux RGB.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample RGB image (100x100 pixels)</span>
<span class="n">rgb_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">rgb_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_rgb_array_gpu</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_rgb_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_buffer_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre Sepia à un tampon d’image BGR ou BGRA sur le GPU (en place).</p>
<p>Cette fonction utilise un noyau GPU pour appliquer un effet Sepia à une image stockée soit au format BGR, soit BGRA. L’opération est effectuée sur le tampon d’image d’entrée (<cite>bgr_array</cite>), qui est un tableau 1D ou un memoryview représentant les données des pixels au format BGR ou BGRA.</p>
<p>La fonction suppose que le tampon est disposé sous forme de tableau 1D, où chaque pixel consiste en 3 ou 4 octets (selon qu’il soit en format BGR ou BGRA). L’effet Sepia est appliqué en parallèle sur le GPU à l’aide d’un noyau CUDA, et le résultat est stocké directement dans le tampon d’entrée.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid_</strong> (<em>tuple</em>) : Les dimensions de la grille de blocs à utiliser pour le lancement du noyau, généralement obtenues à partir d’une fonction d’assistance telle que <cite>block_grid()</cite>.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Les dimensions du bloc à utiliser pour le lancement du noyau, généralement obtenues à partir d’une fonction d’assistance telle que <cite>block_grid()</cite>.</p></li>
<li><p><strong>w</strong> (<em>Py_ssize_t</em>) : La largeur de l’image, en pixels. Doit être supérieure à 0.</p></li>
<li><p><strong>h</strong> (<em>Py_ssize_t</em>) : La hauteur de l’image, en pixels. Doit être supérieure à 0.</p></li>
<li><p><strong>bgr_array</strong> (<em>unsigned char [::1]</em>) : Un tableau 1D ou un memoryview contenant les données des pixels de l’image. Ce tableau représente l’image en format BGR (3 canaux) ou BGRA (4 canaux), chaque pixel occupant 3 ou 4 octets consécutifs.</p></li>
<li><p><strong>format_32</strong> (<em>bint</em>, optionnel) : Un indicateur booléen indiquant si le tableau d’entrée est au format BGRA (True) ou BGR (False). Par défaut, c’est False (format BGR).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : Cette fonction modifie le <cite>bgr_array</cite> en place et ne retourne rien.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>bgr_array</cite> n’est pas un numpy.ndarray ou memoryview valide.</p></li>
<li><p><strong>ValueError</strong> : Si les dimensions de l’image d’entrée ou la longueur du tampon ne correspondent pas aux valeurs attendues en fonction de la largeur, de la hauteur et du format des pixels.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer l’effet Sepia de manière efficace.</p></li>
<li><p>Le tableau d’entrée est modifié directement ; aucun nouveau tableau n’est créé.</p></li>
<li><p>Assurez-vous que le tableau d’entrée soit de type <cite>numpy.uint8</cite> et ait trois ou quatre dimensions représentant les canaux RGB ou RGBA.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre Bright Pass (BPF) à une surface Pygame en utilisant l’accélération GPU.</p>
<p>Cette fonction applique un filtre Bright Pass à une image représentée par une pygame.Surface. Le filtre conserve les pixels dont les valeurs de luminosité sont supérieures à un seuil spécifié et met les autres à noir. L’opération est effectuée sur le GPU pour améliorer les performances.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’entrée (image) sur laquelle l’effet Bright Pass Filter sera appliqué.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optionnel) : Le seuil de luminosité dans la plage [0, 255]. Les pixels dont la valeur de luminosité est supérieure ou égale au seuil conserveront leur couleur, tandis que ceux en dessous seront mis à noir. Par défaut, il est de 128.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle Pygame.Surface avec l’effet Bright Pass Filter appliqué, au format RGB, avec la même largeur et hauteur que la surface d’entrée.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas de type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : S’il y a un problème pour référencer les pixels de la surface dans un tableau 3D, ou si les dimensions de la surface sont invalides.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer efficacement l’effet Bright Pass Filter.</p></li>
<li><p>La surface d’entrée n’est pas modifiée ; une nouvelle surface avec l’effet Bright Pass Filter est retournée.</p></li>
<li><p>Assurez-vous que la surface Pygame soit dans un format compatible (24 bits ou 32 bits) avant d’appliquer le filtre.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_surface</span> <span class="o">=</span> <span class="n">bpf_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bpf_surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_inplace_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_inplace_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_inplace_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre Bright Pass (BPF) à une surface Pygame en place en utilisant l’accélération GPU.</p>
<p>Cette fonction applique un effet Bright Pass Filter à une image sur le GPU. Le filtre conserve les pixels dont la luminosité est supérieure ou égale à un seuil spécifié et met les autres à noir. L’opération est effectuée en place, modifiant directement la surface d’entrée.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’entrée (image) sur laquelle l’effet Bright Pass Filter sera appliqué. La surface doit être au format RGB.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>) : Spécifie la configuration de la grille pour le noyau GPU. Cela détermine la répartition du travail entre plusieurs threads sur le GPU. Les dimensions de la grille doivent correspondre aux tailles de la texture et du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Spécifie la configuration des blocs pour le noyau GPU. Cela définit le nombre de threads par bloc. Le nombre maximal de threads par bloc est de 1024. La taille des blocs doit être choisie pour optimiser les performances du matériel.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optionnel) : Le seuil de luminosité (dans la plage [0, 255]) qui détermine quels pixels sont conservés. Les pixels dont la valeur de luminosité est supérieure ou égale au seuil restent inchangés, tandis que ceux en dessous sont mis à noir. Par défaut, il est de 128.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : La fonction modifie <cite>surface_</cite> en place et ne retourne rien.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas de type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : S’il y a un problème pour référencer les pixels de la surface dans un tableau 3D, ou si les dimensions de la surface sont invalides.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer efficacement l’effet Bright Pass Filter.</p></li>
<li><p>La surface d’entrée est modifiée directement ; aucune nouvelle surface n’est créée.</p></li>
<li><p>Assurez-vous que la surface Pygame soit dans un format compatible (24 bits ou 32 bits) avant d’appliquer le filtre.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_inplace_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_buffer_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un filtre passe-bande (BPF) à un tampon d’image en utilisant l’accélération GPU.</p>
<p>Cette fonction traite un tampon d’image représenté par un tableau 1D ou un memoryview au format BGR ou BGRA. Le filtre BPF conserve les pixels dont la luminosité est comprise dans une plage spécifiée et met les autres à noir. L’opération est effectuée sur le GPU pour améliorer les performances.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>) : Taille de la grille pour l’exécution du noyau GPU (blocs par grille).</p></li>
<li><p><strong>block</strong> (<em>tuple</em>) : Taille des blocs pour l’exécution du noyau GPU (threads par bloc).</p></li>
<li><p><strong>w</strong> (<em>int</em>) : Largeur de l’image en pixels.</p></li>
<li><p><strong>h</strong> (<em>int</em>) : Hauteur de l’image en pixels.</p></li>
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> ou <em>memoryview</em>) : Tampon d’image d’entrée au format BGR ou BGRA.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optionnel) : Valeur seuil utilisée pour le filtrage (par défaut : 128).</p></li>
<li><p><strong>format_32</strong> (<em>bool</em>, optionnel) : Si True, considère le tampon d’entrée comme BGRA (4 octets par pixel). Si False, le considère comme BGR (3 octets par pixel).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>None</strong> : La fonction modifie <cite>bgr_array</cite> en place avec l’image filtrée.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>bgr_array</cite> n’est pas un numpy.ndarray ou un memoryview.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>bgr_array</cite> est vide ou ne correspond pas à la taille attendue.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour appliquer efficacement le filtre BPF.</p></li>
<li><p>Le tableau d’entrée est modifié directement ; aucun nouveau tableau n’est créé.</p></li>
<li><p>Assurez-vous que le tableau d’entrée soit de type <cite>numpy.uint8</cite> et ait trois ou quatre dimensions représentant les canaux RGB ou RGBA.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the BPF with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">filtered_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Convertit une surface Pygame en niveaux de gris en utilisant l’accélération GPU.</p>
<p>Cette fonction prend une surface Pygame au format 24 bits ou 32 bits, la traite sur le GPU pour la convertir en niveaux de gris, et retourne une nouvelle surface 24 bits en niveaux de gris.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Une surface Pygame avec un format de couleur 24 bits ou 32 bits.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame en niveaux de gris 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a Pygame surface.</p></li>
<li><p><strong>ValueError</strong>: If the surface cannot be converted into a 3D array view, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to perform the grayscale conversion efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the grayscale effect is returned.</p></li>
<li><p>Assurez-vous que la surface Pygame soit dans un format compatible (24 bits ou 32 bits) avant d’appliquer le filtre.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_lum_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_lum_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_lum_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Converts a Pygame surface to grayscale using GPU acceleration with a luminance-based method.</p>
<p>This function takes a Pygame surface in 24-bit or 32-bit format, processes
it on the GPU using a luminance-based grayscale conversion, and returns
a new 24-bit grayscale Pygame surface.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Une surface Pygame avec un format de couleur 24 bits ou 32 bits.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame en niveaux de gris 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a Pygame surface.</p></li>
<li><p><strong>ValueError</strong>: If the surface cannot be converted into a 3D array view, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>The function utilizes GPU acceleration to perform the grayscale conversion efficiently.</p></li>
<li><p>The input surface is not modified; a new surface with the grayscale effect is returned.</p></li>
<li><p>Assurez-vous que la surface Pygame soit dans un format compatible (24 bits ou 32 bits) avant d’appliquer le filtre.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_lum_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_generic_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_generic_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_generic_filter_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Apply a median filter to a Pygame surface using GPU acceleration.</p>
<p>This function utilizes a generic median filter, which processes each
pixel based on neighboring values. The filter operates on 24-bit and
32-bit surfaces by applying a kernel function.</p>
<p><strong>Performance Consideration:</strong>
The median filter uses a kernel with a buffer of type <cite>double</cite>, which
may result in lower performance compared to specialized GPU-based median
filtering methods.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input Pygame surface, expected to be in 24-bit or 32-bit format.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, optional): The size of the neighborhood window used for the median filter. Must be greater than zero. Default is 5.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the median filter applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: If <cite>size_</cite> is less than or equal to zero, or if the input surface has zero width or height.</p></li>
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>This function leverages CuPy (<cite>cp.asarray</cite>) for GPU-accelerated computation.</p></li>
<li><p>The filter operates on each color channel (R, G, B) separately.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_generic_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_filter_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Apply a median filter to a Pygame surface using GPU acceleration.</p>
<p>The median filter is a non-linear filter that reduces noise by replacing
each pixel with the median value of its surrounding neighbors.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): The input Pygame surface to be processed.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, optional): The size of the neighborhood considered for median filtering. Must be greater than zero. Default is 5.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new Pygame surface with the median filter applied.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>: If <cite>size_</cite> is not greater than zero.</p></li>
<li><p><strong>ValueError</strong>: If <cite>surface_</cite> is not a valid Pygame surface, or if the surface cannot be referenced as a 3D array, or if the surface width or height is zero.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>This function leverages CuPy (<cite>cp.asarray</cite>) for GPU-accelerated computation.</p></li>
<li><p>The filter operates on each color channel (R, G, B) separately.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_5x5_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un flou gaussien 5x5 à une image en utilisant le traitement accéléré par GPU.</p>
<p>Cette fonction applique une convolution sur chaque canal RGB de la surface donnée avec un noyau de flou gaussien 5x5 pour créer un effet de lissage tout en préservant les contours.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Une surface Pygame 24 bits ou 32 bits à flouter.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame avec le flou gaussien appliqué au format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une surface Pygame valide.</p></li>
<li><p><strong>ValueError</strong> : Si les dimensions de la surface sont invalides ou si les données des pixels ne peuvent pas être accessibles.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise <cite>pixels3d(surface_)</cite> pour extraire le tableau de pixels.</p></li>
<li><p>Le calcul est effectué sur le GPU pour optimiser les performances.</p></li>
<li><p><cite>gaussian_5x5_cupy</cite> est appelé pour appliquer l’effet de flou.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 5x5 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_5x5_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_3x3_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_3x3_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_3x3_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un flou gaussien 3x3 à une surface Pygame en utilisant l’accélération GPU.</p>
<p>Cette fonction convertit une <cite>pygame.Surface</cite> donnée en un tableau compatible avec le GPU, applique un filtre de flou gaussien 3x3 à chaque canal de couleur (R, G, B) et retourne une nouvelle <cite>pygame.Surface</cite> floutée.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Une <cite>pygame.Surface</cite> 24 bits ou 32 bits représentant l’image d’entrée.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle <cite>pygame.Surface</cite> avec l’effet de flou gaussien appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la surface a des dimensions invalides ou ne peut pas être convertie en tableau.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction suppose que <cite>gaussian_kernel_3x3</cite> est prédéfini.</p></li>
<li><p><cite>cp.cuda.Stream.null.synchronize()</cite> garantit que les opérations GPU sont terminées avant de retourner le résultat.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 3x3 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_3x3_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sobel_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sobel_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sobel_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique le filtre de détection de contours de Sobel à une image en niveaux de gris en utilisant l’accélération GPU.</p>
<p>Cette fonction suppose que l’image d’entrée est en niveaux de gris, ce qui signifie que la même intensité est présente dans les trois canaux RGB. Elle applique le filtre de Sobel en utilisant uniquement le canal rouge (<cite>R</cite>), bien que les canaux vert (<cite>G</cite>) ou bleu (<cite>B</cite>) puissent également être utilisés.</p>
<p>Si l’image d’entrée n’est pas réellement en niveaux de gris, l’effet de Sobel peut légèrement varier car les canaux RGB peuvent avoir des intensités différentes.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Une <cite>pygame.Surface</cite> 24 bits ou 32 bits représentant l’image d’entrée.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle <cite>pygame.Surface</cite> avec l’effet de détection de contours de Sobel appliqué en format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la surface a des dimensions invalides ou ne peut pas être convertie en tableau.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction suppose que <cite>sobel_cupy()</cite> est implémentée pour traiter le tableau GPU.</p></li>
<li><p>L’image finale conserve le format <cite>RGB</cite>, mais seul le canal rouge est modifié.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sobel edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">sobel_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.prewitt_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">prewitt_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.prewitt_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique l’algorithme de détection de contours de Prewitt à une image en niveaux de gris en utilisant l’accélération GPU.</p>
<p>Cette fonction suppose que l’image d’entrée est en niveaux de gris, ce qui signifie que la même intensité est présente dans les trois canaux RGB. Elle applique le filtre de Prewitt en utilisant uniquement le canal rouge (<cite>R</cite>), bien que les canaux vert (<cite>G</cite>) ou bleu (<cite>B</cite>) puissent également être utilisés.</p>
<p>Si l’image d’entrée n’est pas réellement en niveaux de gris, l’effet de Prewitt peut légèrement varier car les canaux RGB peuvent avoir des intensités différentes.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Une <cite>pygame.Surface</cite> 24 bits ou 32 bits représentant l’image d’entrée.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle <cite>pygame.Surface</cite> avec l’effet de détection de contours de Prewitt appliqué en format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la surface a des dimensions invalides ou ne peut pas être convertie en tableau.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction suppose que <cite>prewitt_cupy()</cite> est implémentée pour traiter le tableau GPU.</p></li>
<li><p>L’image finale conserve le format <cite>RGB</cite>, mais seul le canal rouge est modifié.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Prewitt edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">prewitt_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.canny_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">canny_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.canny_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique l’algorithme de détection de contours de Canny à une image en niveaux de gris en utilisant l’accélération GPU.</p>
<p>Cette fonction suppose que l’image d’entrée est en niveaux de gris, ce qui signifie que la même intensité est présente dans les trois canaux RGB. Elle applique l’algorithme de détection de contours de Canny en utilisant uniquement le canal rouge (<cite>R</cite>), bien que les canaux vert (<cite>G</cite>) ou bleu (<cite>B</cite>) puissent également être utilisés. Si l’image d’entrée n’est pas réellement en niveaux de gris, l’effet de Canny peut légèrement varier car les canaux RGB peuvent avoir des intensités différentes.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Une <cite>pygame.Surface</cite> 24 bits ou 32 bits représentant l’image d’entrée.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle <cite>pygame.Surface</cite> avec l’effet de détection de contours de Canny appliqué en format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la surface a des dimensions invalides ou ne peut pas être convertie en tableau.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction suppose que <cite>canny_cupy()</cite> est implémentée pour traiter le tableau GPU.</p></li>
<li><p>L’image finale conserve le format <cite>RGB</cite>, mais seul le canal rouge est modifié.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Canny edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">canny_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.color_reduction_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">color_reduction_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.color_reduction_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de réduction des couleurs à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction réduit le nombre de couleurs uniques dans l’image en quantifiant chaque canal RGB. Par exemple, si <cite>color_number=8</cite>, chaque canal aura 8 niveaux distincts (0, 32, 64, …, 255), ce qui donne un total de 8^3 couleurs possibles.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée (image) sur laquelle l’effet de réduction des couleurs sera appliqué.</p></li>
<li><p><strong>color_number</strong> (<em>int</em>, optionnel) : Le nombre de niveaux de couleur auxquels chaque canal RGB sera réduit. La valeur par défaut est 8. Le nombre total de couleurs dans la palette sera <cite>color_number^3</cite>.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface avec l’effet de réduction des couleurs appliqué, au format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si l’argument <cite>surface_</cite> n’est pas une instance valide de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>color_number</cite> est inférieur ou égal à 0 ou si la surface a des dimensions invalides.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>La réduction des couleurs est obtenue par quantification de chaque canal RGB.</p></li>
<li><p>La fonction fonctionne avec des images 32 bits et 24 bits (format Pygame Surface).</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the color reduction with a palette size of 8</span>
<span class="n">reduced_surface</span> <span class="o">=</span> <span class="n">color_reduction_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">color_number</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">reduced_surface</span><span class="p">,</span> <span class="s2">&quot;reduced_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsv_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsv_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsv_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de rotation de la teinte à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction modifie la teinte de chaque pixel de l’image tout en préservant sa saturation et sa luminosité, décalant ainsi les couleurs tout en conservant la structure globale de l’image.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée (image) sur laquelle l’effet de rotation de la teinte sera appliqué.</p></li>
<li><p><strong>val_</strong> (<em>float</em>): La valeur de décalage de la teinte, qui doit être comprise dans l’intervalle [0.0, 1.0]. - <cite>0.0</cite> correspond à un décalage de -180° (rotation complète vers l’arrière). - <cite>0.5</cite> représente un décalage de 0° (aucun changement). - <cite>1.0</cite> correspond à un décalage de +180° (rotation complète vers l’avant).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Spécifie les dimensions de la grille CUDA pour l’exécution du noyau. - Exemple : <cite>(grid_y, grid_x)</cite>, e.g., <cite>(25, 25)</cite>. - La taille de la grille doit être ajustée en fonction de la texture et des dimensions du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Specifies the CUDA block dimensions for kernel execution.
- Example: <cite>(block_y, block_x)</cite>, e.g., <cite>(32, 32)</cite>.
- The total number of threads (<cite>block_x * block_y</cite>) must not exceed 1024 due to GPU hardware limitations.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: A new surface containing the hue-modified image, returned in 24-bit RGB format.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une instance valide de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la surface d’entrée a une largeur ou une hauteur nulle, si <cite>val_</cite> est en dehors de l’intervalle valide [0.0, 1.0], ou si les pixels de la surface ne peuvent pas être référencés sous forme de tableau 3D.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>L’image d’entrée doit être au format RGB avant d’appliquer cette transformation.</p></li>
<li><p>La fonction effectue une rotation de teinte en utilisant l’accélération GPU avec CuPy pour des performances optimisées.</p></li>
<li><p>La transformation fonctionne en convertissant le RGB en HSV, en modifiant le canal H (teinte), puis en le reconvertissant en RGB.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the hue rotation with a shift value of 0.5 (no change)</span>
<span class="n">rotated_surface</span> <span class="o">=</span> <span class="n">hsv_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">val_</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">grid_</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">block_</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rotated_surface</span><span class="p">,</span> <span class="s2">&quot;rotated_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mult_downscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mult_downscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mult_downscale_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Effectuer un downscaling de l’effet bloom en réduisant progressivement la résolution de l’image.</p>
<p>Cette fonction réduit l’échelle d’une image basée sur le GPU en quatre sous-tableaux progressivement plus petits avec des résolutions réduites par des facteurs de 2, 4, 8 et 16. Elle est compatible avec les images 24 bits et 32 bits (format RGB, uint8).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array</strong> (<em>cupy.ndarray</em>) : Un tableau 3D CuPy de forme (hauteur, largeur, 3) et de type uint8, représentant une image RGB stockée sur le GPU.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>tuple de cupy.ndarray</strong> : Un tuple contenant quatre versions réduites de l’image d’entrée avec des formes (H/2, W/2, 3), (H/4, W/4, 3), (H/8, W/8, 3) et (H/16, W/16, 3).</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction effectue le downscaling en utilisant <cite>cupyx.scipy.ndimage.zoom</cite>, en appliquant une interpolation du plus proche voisin (<cite>order=0</cite>) pour préserver les contours nets.</p></li>
<li><p>Les pixels en dehors des limites sont remplis avec zéro (<cite>mode=”constant”, cval=0.0</cite>).</p></li>
<li><p>La synchronisation du GPU est effectuée pour s’assurer que toutes les opérations CUDA se terminent avant le retour.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">downscaled_images</span> <span class="o">=</span> <span class="n">mult_downscale_gpu</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">)</span>

<span class="c1"># Access the downscaled images</span>
<span class="n">image_2x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">image_4x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_8x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">image_16x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.upscale_c">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">upscale_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.upscale_c" title="Lien vers cette définition">¶</a></dt>
<dd><p>Agrandir une image sur le GPU en utilisant l’interpolation.</p>
<p>Cette fonction redimensionne une image basée sur le GPU aux dimensions spécifiées <cite>new_width</cite> et <cite>new_height</cite> en utilisant l’ordre d’interpolation indiqué. Le redimensionnement est réalisé avec <cite>cupyx.scipy.ndimage.zoom</cite>, qui prend en charge différentes méthodes d’interpolation.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>) : Un tableau GPU 3D (hauteur x largeur x 3) représentant une image RGB au format <cite>uint8</cite>.</p></li>
<li><p><strong>new_width</strong> (<em>int</em>) : La largeur souhaitée de l’image agrandie.</p></li>
<li><p><strong>new_height</strong> (<em>int</em>) : La hauteur souhaitée de l’image agrandie.</p></li>
<li><p><strong>order_</strong> (<em>int</em>, optionnel, valeur par défaut = 0) : L’ordre d’interpolation pour le redimensionnement : - <cite>0</cite> : Interpolation du plus proche voisin. - <cite>1</cite> : Interpolation bilinéaire. - <cite>3</cite> : Interpolation bicubique. Les ordres supérieurs offrent des résultats plus lisses mais augmentent le temps de calcul.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>cupy.ndarray</strong> : L’image agrandie sous forme de tableau basé sur le GPU avec une forme (<cite>new_height</cite>, <cite>new_width</cite>, 3).</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction garantit que le tableau d’entrée est de type <cite>uint8</cite> avant le traitement.</p></li>
<li><p>Le paramètre <cite>mode=”constant”, cval=0.0</cite> garantit que les pixels en dehors des limites sont traités comme des zéros lors de l’interpolation.</p></li>
<li><p>La synchronisation du GPU (<cite>cp.cuda.Stream.null.synchronize()</cite>) est effectuée pour s’assurer que toutes les opérations sont terminées avant de retourner le résultat.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">upscaled_image</span> <span class="o">=</span> <span class="n">upscale_c</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">new_width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">new_height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">order_</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet Bloom à une surface Pygame en utilisant l’accélération GPU.</p>
<p>Cette fonction améliore les régions lumineuses d’une image pour créer un effet de halo (bloom) en utilisant un processus en plusieurs étapes, comprenant : - Une réduction progressive de l’image en sous-surfaces plus petites. - L’application d’un filtre de luminance pour isoler les zones lumineuses. - Un flou appliqué aux régions lumineuses à l’aide d’un filtre gaussien. - Une mise à l’échelle et un mélange des couches traitées avec la surface originale.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’entrée sur laquelle appliquer l’effet bloom.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optionnel, valeur par défaut = 128) : Le seuil de luminance pour le filtre de luminance. Les pixels ayant une intensité supérieure à cette valeur contribuent à l’effet bloom. Doit être compris dans l’intervalle [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, optionnel, valeur par défaut = True) : Lorsque <cite>True</cite>, seule la réduction d’échelle la plus faible (x16) est utilisée pour l’effet bloom. Lorsque <cite>False</cite>, plusieurs niveaux de réduction d’échelle (x2, x4, x8, x16) sont traités et mélangés pour un effet plus détaillé.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optionnel, valeur par défaut = pygame.BLEND_RGB_ADD) : Le mode de fusion utilisé lors de l’ajout de l’effet bloom à la surface originale. Modes courants : - <cite>pygame.BLEND_RGB_ADD</cite> (par défaut) - <cite>pygame.BLEND_RGB_MULT</cite>, etc.</p></li>
<li><p><strong>factor_</strong> (<em>int</em>, optionnel, valeur par défaut = 2) : Détermine le niveau de réduction de la texture. Doit être compris dans l’intervalle [0, 4], correspondant à : - 1 (pas de réduction) - 2 (moitié de la taille) - 4 (quart de la taille) - 8 (huitième de la taille)</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : La surface d’entrée fusionnée avec l’effet bloom.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong> : Si l’image d’entrée est trop petite pour être traitée.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>L’effet bloom est obtenu grâce à une série d’opérations de réduction d’échelle, de filtrage et de fusion.</p></li>
<li><p>Le drapeau <cite>pygame.BLEND_RGB_ADD</cite> est utilisé pour ajouter l’effet bloom à la surface originale.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surface</span> <span class="o">=</span> <span class="n">bloom_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">factor_</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_surface</span><span class="p">,</span> <span class="s2">&quot;bloomed_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_array">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_array" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet Bloom à une image représentée sous forme de tableau GPU.</p>
<p>Cette fonction applique un effet bloom sur un <cite>gpu_array_</cite>, qui représente une image sur le GPU. Le processus comprend : - Une réduction progressive de l’image en versions plus petites (x2, x4, x8, x16). - L’application d’un filtre de luminance pour isoler les pixels à forte intensité. - Un flou appliqué aux régions lumineuses pour créer un effet de halo. - Une mise à l’échelle et un mélange des images traitées pour obtenir l’effet bloom final.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>) : Un tableau 3D représentant l’image en mémoire GPU. Doit être de type <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, optionnel, valeur par défaut = 128) : Le seuil de luminance pour le filtre de luminance. Les pixels ayant une intensité supérieure à cette valeur contribuent à l’effet bloom. Doit être compris dans l’intervalle [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, optionnel, valeur par défaut = True) : Lorsque <cite>True</cite>, seule la réduction d’échelle la plus faible (x16) est utilisée, réduisant ainsi le temps de traitement. Lorsque <cite>False</cite>, plusieurs niveaux (x2, x4, x8, x16) sont mélangés pour un effet bloom plus riche.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optionnel, valeur par défaut = pygame.BLEND_RGB_ADD) : Le mode de fusion utilisé lors de la fusion des couches de l’effet bloom.</p></li>
<li><p><strong>mask_</strong> (<em>optionnel</em>, valeur par défaut = None) : Paramètre inutilisé, réservé pour les futures implémentations.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>tuple de pygame.Surface</strong> : Les surfaces traitées de l’effet bloom à différents niveaux de réduction d’échelle (s2, s4, s8, s16). Si <cite>fast_</cite> est activé, seul <cite>s16</cite> est utilisé.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>L’effet bloom est obtenu grâce à une série d’opérations de réduction d’échelle, de filtrage et de fusion.</p></li>
<li><p>Le drapeau <cite>pygame.BLEND_RGB_ADD</cite> est utilisé pour ajouter l’effet bloom à la surface originale.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert Pygame surface to CuPy array</span>
<span class="n">gpu_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surfaces</span> <span class="o">=</span> <span class="n">bloom_array</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Convert back to Pygame surfaces</span>
<span class="n">bloomed_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">make_surface</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bloom</span><span class="p">))</span> <span class="k">for</span> <span class="n">bloom</span> <span class="ow">in</span> <span class="n">bloomed_surfaces</span><span class="p">]</span>

<span class="c1"># Save the new images</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bloomed_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bloomed_images</span><span class="p">):</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_image</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;bloomed_image_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.cartoon_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">cartoon_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.cartoon_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un effet cartoon à une surface donnée en utilisant l’accélération GPU.</p>
<p>Cette fonction traite une image pour générer un effet de type cartoon en appliquant une détection de contours, un filtrage médian et une quantification des couleurs. L’effet peut également inclure un contour des bords si activé.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’image d’entrée à traiter.</p></li>
<li><p><strong>sobel_threshold_</strong> (<em>int</em>, optionnel, valeur par défaut = 128) : La valeur de seuil pour le filtre de détection des contours Sobel.</p></li>
<li><p><strong>median_kernel_</strong> (<em>int</em>, optionnel, valeur par défaut = 2) : Taille du noyau pour le filtrage médian (utilisé pour réduire le bruit tout en préservant les contours).</p></li>
<li><p><strong>color_</strong> (<em>int</em>, optionnel, valeur par défaut = 8) : Nombre maximum de couleurs à utiliser dans l’effet cartoon (réduction des couleurs).</p></li>
<li><p><strong>contour_</strong> (<em>bool</em>, optionnel, valeur par défaut = False) : Indique s’il faut dessiner des contours sur les bords détectés dans l’image.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, optionnel, valeur par défaut = BLEND_RGB_ADD) : Mode de fusion utilisé pour combiner l’effet avec l’image originale.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : La surface transformée avec l’effet cartoon appliqué.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>L’effet cartoon est obtenu grâce à une série d’opérations de détection de contours, de filtrage et de fusion.</p></li>
<li><p>Le drapeau <cite>BLEND_RGB_ADD</cite> est utilisé pour ajouter l’effet cartoon à la surface originale.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the cartoon effect</span>
<span class="n">cartoon_surface</span> <span class="o">=</span> <span class="n">cartoon_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">sobel_threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">median_kernel_</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color_</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">contour_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cartoon_surface</span><span class="p">,</span> <span class="s2">&quot;cartoon_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.blending_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">blending_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.blending_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Fusionner une texture source avec une texture de destination (effet de transition).</p>
<p>Cette fonction fusionne une surface source Pygame avec une surface de destination, créant un effet de transition basé sur le pourcentage spécifié. La fusion est réalisée en utilisant les calculs suivants : - <strong>Alpha</strong> : <cite>outA = SrcA + DstA * (1 - SrcA)</cite> - <strong>RGB</strong> : <cite>outRGB = SrcRGB + DstRGB * (1 - SrcA)</cite></p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>source_</strong> (<em>pygame.Surface</em>) : La surface source à fusionner.</p></li>
<li><p><strong>destination_</strong> (<em>pygame.Surface</em>) : La surface de destination sur laquelle la source sera fusionnée.</p></li>
<li><p><strong>percentage_</strong> (<em>float</em>) : Le pourcentage de fusion, une valeur entre 0,0 et 100,0, représentant la proportion de la source à fusionner avec la destination.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame 24 bits avec le résultat fusionné.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction suppose que les surfaces source et destination sont de la même taille.</p></li>
<li><p>La surface de sortie est convertie pour un rendu rapide à l’aide de la méthode <cite>convert()</cite>.</p></li>
<li><p>Le mode de fusion utilisé est <cite>BLEND_RGB_ADD</cite>, qui ajoute la couleur source à la couleur de destination. Ce mode peut être ajusté en modifiant le paramètre <cite>flag_</cite>.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load source and destination images</span>
<span class="n">source</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;source_image.png&#39;</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;destination_image.png&#39;</span><span class="p">)</span>

<span class="c1"># Apply blending with 50% source</span>
<span class="n">blended_surface</span> <span class="o">=</span> <span class="n">blending_gpu</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">)</span>

<span class="c1"># Save the blended image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blended_surface</span><span class="p">,</span> <span class="s1">&#39;blended_image.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquer un filtre de netteté à l’image pygame.Surface donnée à l’aide d’un noyau de filtre générique.</p>
<p>La fonction aiguise l’image d’entrée en appliquant un noyau de netteté à chaque canal RGB (rouge, vert, bleu) indépendamment. L’image aiguisée est retournée au format pygame.Surface 24 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Un objet surface Pygame représentant l’image d’entrée à aiguiser.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame avec l’image aiguisée au format 24 bits (RGB).</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong> : Si la surface d’entrée n’est pas une pygame.Surface valide ou a des dimensions nulles.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>L’effet de netteté est obtenu par convolution avec un noyau de netteté.</p></li>
<li><p>La surface de sortie est convertie pour un rendu rapide à l’aide de la méthode <cite>convert()</cite>.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.ripple_effect_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">ripple_effect_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.ripple_effect_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquez un effet de goutte d’eau (vague) à une texture en utilisant l’accélération GPU.</p>
<p>Cette fonction utilise un noyau CUDA (<cite>ripple_kernel</cite>) pour calculer l’effet de vague sur la texture. Elle fonctionne en manipulant l’état <cite>précédent</cite> et <cite>actuel</cite> de l’effet de vague et en l’appliquant à la texture. L’effet est calculé en parallèle sur le GPU, ce qui le rend efficace pour le traitement de grandes textures ou simulations.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>): Tuple définissant la taille de la grille pour l’exécution du noyau CUDA, par exemple, (25, 25). La taille de la grille doit correspondre à la taille de la texture pour un traitement parallèle efficace.</p></li>
<li><p><strong>block</strong> (<em>tuple</em>): Tuple définissant la taille du bloc pour l’exécution du noyau CUDA, par exemple, (32, 32). Le nombre maximal de threads est 1024 (block_x * block_y).</p></li>
<li><p><strong>w</strong> (<em>int</em>): La largeur de la texture et des tableaux.</p></li>
<li><p><strong>h</strong> (<em>int</em>): La hauteur de la texture et des tableaux.</p></li>
<li><p><strong>previous</strong> (<em>cupy.ndarray</em>): Un tableau CuPy de forme (w, h), contenant l’état précédent de l’effet de vague (float32).</p></li>
<li><p><strong>current</strong> (<em>cupy.ndarray</em>): Un tableau CuPy de forme (w, h), contenant l’état actuel de l’effet de vague (float32).</p></li>
<li><p><strong>texture_array</strong> (<em>cupy.ndarray</em>): Un tableau CuPy de forme (w, h, 3), contenant la texture source en RGB (uint8).</p></li>
<li><p><strong>background_array</strong> (<em>cupy.ndarray</em>): Un tableau CuPy de forme (w, h, 3), représentant la texture de fond à laquelle appliquer l’effet (uint8).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong> : Un tuple contenant deux tableaux CuPy, les états mis à jour de <cite>previous</cite> et <cite>current</cite> de l’effet de vague.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span>

<span class="c1"># Initialize previous and current ripple states</span>
<span class="n">previous</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">current</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Initialize texture and background arrays</span>
<span class="n">texture_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">background_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Apply ripple effect</span>
<span class="n">updated_previous</span><span class="p">,</span> <span class="n">updated_current</span> <span class="o">=</span> <span class="n">ripple_effect_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">background_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La taille de la grille et du bloc doit être choisie de manière appropriée en fonction de la taille de la texture et des ressources GPU disponibles.</p></li>
<li><p>Le calcul du noyau est effectué sur le GPU à l’aide de CuPy pour une exécution plus rapide.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen1_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen1_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen1_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Aiguisez une image en utilisant un noyau brut.</p>
<p>Cette fonction aiguise l’image d’entrée en appliquant un noyau de netteté à chaque canal RGB (rouge, vert, bleu) indépendamment. Les bords ne sont pas calculés avec le noyau (valeur = 0).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface de l’image d’entrée à aiguiser.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensions de la grille pour l’exécution du noyau CUDA, par exemple, (25, 25). Les valeurs de la grille et du bloc doivent correspondre aux tailles de la texture et des tableaux.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensions du bloc pour l’exécution du noyau CUDA, par exemple, (32, 32). Le nombre maximal de threads est 1024. Threads max = block_x * block_y.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle surface Pygame avec l’image affinée en format 24 bits (RGB).</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement efficace.</p></li>
<li><p>L’effet de netteté est obtenu par convolution avec un noyau de netteté.</p></li>
<li><p>La surface de sortie est convertie pour un rendu rapide à l’aide de la méthode <cite>convert()</cite>.</p></li>
</ul>
<p><strong>Exemple :</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen1_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mirroring_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mirroring_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mirroring_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquez un effet miroir à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction crée une version miroir d’une image représentée sous la forme d’une <cite>pygame.Surface</cite>. Elle prend en charge les formats d’image 32 bits et 24 bits et génère une image au format 24 bits. L’orientation du miroir (horizontale ou verticale) est contrôlée à l’aide du paramètre <cite>format_</cite>.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée sous forme d’un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Définit les dimensions de la grille sous la forme <cite>(grid_y, grid_x)</cite>, par exemple, <cite>(25, 25)</cite>. Les dimensions de la grille et du bloc doivent correspondre aux tailles de la texture et des tableaux.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Spécifie les dimensions du bloc sous la forme <cite>(block_y, block_x)</cite>, par exemple, <cite>(32, 32)</cite>. Le nombre maximal de threads par bloc est 1024, suivant la condition : <cite>Threads max = block_x * block_y</cite>.</p></li>
<li><p><strong>format_</strong> (<em>bool</em>, optionnel, défaut=`False`): Détermine l’orientation du miroir : - <cite>False</cite> (0) → Miroir horizontal (par défaut). - <cite>True</cite> (1) → Miroir vertical.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une <cite>pygame.Surface</cite> 24 bits avec l’effet miroir appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>surface_</cite> a un format ou des dimensions invalides (si <cite>w</cite> ou <cite>h</cite> est 0).</p></li>
<li><p><strong>ValueError</strong> : Si <cite>surface_</cite> ne peut pas être référencé comme un tableau 3D.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction extrait les données des pixels de <cite>surface_</cite> et les convertit en un tableau 3D.</p></li>
<li><p>La fonction <cite>mirroring_cupy</cite> effectue un mirroring accéléré par GPU et renvoie l’image traitée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.saturation_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">saturation_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.saturation_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajuste le niveau de saturation d’une image donnée en utilisant l’accélération GPU.</p>
<p>Cette fonction modifie la saturation d’une image représentée sous la forme d’une <cite>pygame.Surface</cite>. Elle prend en charge les formats d’image 32 bits et 24 bits, produisant une sortie au format 24 bits. La valeur d’ajustement de la saturation doit être comprise dans la plage [-1.0, 1.0].</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée sous forme d’un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Définit les dimensions de la grille sous la forme <cite>(grid_y, grid_x)</cite>, par exemple, <cite>(25, 25)</cite>. Les dimensions de la grille et du bloc doivent correspondre aux tailles de la texture et des tableaux.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Spécifie les dimensions du bloc sous la forme <cite>(block_y, block_x)</cite>, par exemple, <cite>(32, 32)</cite>. Le nombre maximal de threads par bloc est 1024, suivant la condition : <cite>Threads max = block_x * block_y</cite>.</p></li>
<li><p><strong>val_</strong> (<em>float</em>, optionnel, défaut=`1.0`): Niveau d’ajustement de la saturation dans la plage <cite>[-1.0, 1.0]</cite>. - <cite>-1.0</cite> → Complètement désaturé (niveau de gris). - <cite>0.0</cite> → Aucun changement de saturation. - <cite>1.0</cite> → Totalement saturé.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une <cite>pygame.Surface</cite> 24 bits avec le niveau de saturation ajusté.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>surface_</cite> a un format ou des dimensions invalides (si <cite>w</cite> ou <cite>h</cite> est 0).</p></li>
<li><p><strong>ValueError</strong> : Si <cite>val_</cite> est hors de la plage <cite>[-1.0, 1.0]</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction extrait les données des pixels de <cite>surface_</cite> et les convertit en un tableau 3D.</p></li>
<li><p>La fonction <cite>saturation_cupy</cite> effectue un ajustement de saturation accéléré par GPU et renvoie l’image traitée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bilateral_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bilateral_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bilateral_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Appliquez un filtre bilatéral à une image 32 bits ou 24 bits en utilisant le GPU.</p>
<p>Un filtre bilatéral est un filtre non linéaire, préservant les bords et réduisant le bruit. Il remplace l’intensité de chaque pixel par une moyenne pondérée des pixels voisins, où les poids sont déterminés à la fois par la proximité spatiale et les différences d’intensité, suivant une distribution gaussienne.</p>
<p>Les paramètres du filtre (sigma_r &amp; sigma_s) sont prédéfinis dans le noyau GPU. Cette fonction est compatible avec les images 32 bits et 24 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée sous forme d’un objet <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>kernel_size_</strong> (<em>int</em>): La taille du noyau, déterminant le nombre de pixels voisins inclus dans le calcul.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Une nouvelle <cite>pygame.Surface</cite> 24 bits avec l’effet de filtrage bilatéral appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une instance de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si les dimensions de la surface sont nulles ou si <cite>kernel_size_</cite> est négatif.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction extrait les données des pixels de <cite>surface_</cite> et les convertit en un tableau 3D.</p></li>
<li><p>La fonction <cite>bilateral_cupy</cite> effectue un filtrage bilatéral accéléré par GPU et renvoie l’image traitée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.emboss5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">emboss5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.emboss5x5_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Apply an emboss effect to a 32-bit or 24-bit image using a 5x5 convolution kernel.</p>
<dl class="simple">
<dt>Le noyau d’embossage utilisé :</dt><dd><p>[-2.0, -1.0,  0.0,  1.0,  2.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[ 0.0,  2.0,  4.0,  6.0,  8.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[-2.0, -1.0,  0.0,  1.0,  2.0]</p>
</dd>
</dl>
<p>Chaque canal RGB de l’image d’entrée est traité indépendamment à l’aide d’une convolution. L’image d’entrée doit être au format 32 bits ou 24 bits, et l’image de sortie sera en 24 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée sous forme d’un objet <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong> : Un nouveau <cite>pygame.Surface</cite> en 24 bits avec l’effet d’embossage appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une instance de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si les données de pixels de la surface ne peuvent pas être accessibles ou si sa largeur/hauteur est nulle.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction extrait les données des pixels de <cite>surface_</cite> et les convertit en un tableau 3D.</p></li>
<li><p>La fonction <cite>emboss_cupy</cite> applique un embossage accéléré par GPU et renvoie l’image traitée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.area24_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">area24_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cupy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=cupy.float32,</span> <span class="pre">copy=False)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.area24_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique une superposition de couleur à une zone spécifiée d’une image RGB 24 bits en utilisant l’accélération GPU.</p>
<p>Cette fonction modifie la couleur d’une région de <cite>rgb_array</cite> aux coordonnées <cite>(x, y)</cite>, en la mélangeant avec la <cite>color</cite> donnée en fonction des paramètres <cite>mask_alpha</cite> et <cite>intensity</cite>. Elle utilise CuPy pour un calcul rapide sur GPU.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>x</strong> (<em>int</em>) : Coordonnée X du pixel cible dans l’image.</p></li>
<li><p><strong>y</strong> (<em>int</em>) : Coordonnée Y du pixel cible dans l’image.</p></li>
<li><p><strong>rgb_array</strong> (<em>cupy.ndarray</em>) : Un tableau 3D représentant l’image RGB stockée en mémoire GPU. Doit avoir une forme <cite>(hauteur, largeur, 3)</cite>.</p></li>
<li><p><strong>mask_alpha</strong> (<em>cupy.ndarray</em>) : Masque alpha déterminant l’effet de transparence appliqué à la superposition de couleur. Doit correspondre à la forme de <cite>rgb_array</cite>.</p></li>
<li><p><strong>intensity</strong> (<em>float</em>, optionnel, par défaut=`1.0`) : Facteur d’échelle de l’effet de superposition. Détermine à quel point la <cite>color</cite> se mélange avec l’image originale. Doit être dans l’intervalle <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>color</strong> (<em>cupy.ndarray</em>, optionnel, par défaut=`[128.0, 128.0, 128.0]`) : Un tableau de 3 éléments représentant la couleur RGB à mélanger.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>tuple</em>) : Les valeurs RGB modifiées à <cite>(x, y)</cite> après application de l’effet.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong> : Si <cite>x</cite> ou <cite>y</cite> est hors limites.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>intensity</cite> n’est pas compris entre <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>rgb_array</cite> ou <cite>mask_alpha</cite> ont des formes incompatibles.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU avec CuPy pour un traitement rapide.</p></li>
<li><p>L’effet de mélange des couleurs est basé sur le masque alpha et l’intensité, permettant une transparence personnalisable.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.brightness_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">brightness_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brightness_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.brightness_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Ajuste la luminosité d’une image donnée en utilisant l’accélération GPU.</p>
<p>Cette fonction modifie la luminosité d’un <cite>pygame.Surface</cite> en appliquant une transformation accélérée par GPU. Elle traite efficacement les images 24 bits et 32 bits, en exploitant CUDA pour le calcul parallèle.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : L’image d’entrée à traiter. Doit être au format 24 bits ou 32 bits.</p></li>
<li><p><strong>brightness_factor</strong> (<em>float</em>) : Le facteur d’échelle de luminosité. - Les valeurs supérieures à <cite>1.0</cite> augmentent la luminosité. - Les valeurs entre <cite>0.0</cite> et <cite>1.0</cite> réduisent la luminosité. - <cite>1.0</cite> conserve la luminosité d’origine.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>) : Dimensions de la grille <cite>(grid_y, grid_x)</cite>, par ex., <cite>(25, 25)</cite>. Définit comment l’image est divisée pour l’exécution parallèle sur le GPU. Doit correspondre aux tailles de la texture et du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Dimensions du bloc <cite>(block_y, block_x)</cite>, par ex., <cite>(32, 32)</cite>. Détermine le nombre de threads par bloc pour l’exécution CUDA. Le produit <cite>block_x * block_y</cite> ne doit pas dépasser <cite>1024</cite> (la limite maximale de threads par bloc en CUDA).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>) : Une nouvelle surface avec une luminosité modifiée au format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas de type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>brightness_factor</cite> est négatif.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction exploite l’accélération GPU pour traiter efficacement l’image, ce qui la rend adaptée aux grandes images ou aux applications en temps réel.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsl_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique une rotation HSL (Teinte, Saturation, Luminosité) à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction modifie la couleur des pixels d’une image ou texture représentée par un <cite>pygame.Surface</cite> en ajustant la composante teinte du modèle de couleur HSL. Elle prend en charge les formats d’image 24 bits et 32 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’image d’entrée à traiter.</p></li>
<li><p><strong>val_</strong> (<em>float</em>) : Une valeur flottante représentant la rotation de la teinte. La teinte est ajustée en modifiant sa valeur dans l’espace colorimétrique HSL.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>, optionnel) : Dimensions de la grille <cite>(grid_y, grid_x)</cite>, par ex., <cite>(25, 25)</cite>. Définit comment l’image est divisée pour l’exécution parallèle sur le GPU. Les dimensions de la grille et du bloc doivent correspondre aux tailles de la texture et du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>, optionnel) : Dimensions du bloc <cite>(block_y, block_x)</cite>, par ex., <cite>(32, 32)</cite>. Spécifie le nombre de threads par bloc pour l’exécution CUDA. Le nombre maximal de threads par bloc est de 1024, donc <cite>block_x * block_y</cite> ne doit pas dépasser cette limite.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>) : Un nouveau <cite>pygame.Surface</cite> avec la teinte modifiée en fonction de la valeur de rotation donnée.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction applique une opération accélérée par GPU pour modifier la teinte d’une image, permettant un traitement efficace des grandes images ou des applications en temps réel.</p></li>
<li><p>Les paramètres <cite>grid_</cite> et <cite>block_</cite> sont optionnels mais doivent être fournis pour que le traitement parallèle fonctionne de manière optimale sur le GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.dithering_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">dithering_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.dithering_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de dithering à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction applique un effet de dithering à une image RGB en utilisant un noyau CUDA. L’opération est effectuée sur le GPU pour un traitement rapide. L’image est d’abord normalisée, traitée avec le noyau de dithering, puis convertie au format 8 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>) : Un tableau CuPy de forme <cite>(w, h, 3)</cite> contenant les données d’image en format RGB. Doit être de type <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>) : Dimensions de la grille CUDA <cite>(grid_y, grid_x)</cite>. Définit comment le calcul est distribué sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Dimensions du bloc CUDA <cite>(block_y, block_x)</cite>. Le nombre de threads par bloc ne doit pas dépasser 1024.</p></li>
<li><p><strong>factor_</strong> (<em>float</em>, optionnel, par défaut=`1.0`) : Un facteur contrôlant l’intensité du dithering. Une valeur plus élevée accentue l’effet.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>) : Un nouveau <cite>pygame.Surface</cite> contenant l’image traitée en format RGB.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>gpu_array_</cite> n’est pas un tableau CuPy.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>gpu_array_</cite> n’est pas de type <cite>cupy.uint8</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise un noyau CUDA (<cite>dithering_kernel</cite>) pour un traitement haute performance.</p></li>
<li><p>L’image d’entrée est normalisée entre [0, 1] avant traitement, puis convertie en [0, 255].</p></li>
<li><p>Les tailles de grille et de bloc doivent être choisies en fonction des dimensions de l’image et des ressources du GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.fisheye_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">fisheye_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_texture</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.fisheye_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de lentille fisheye à un <cite>pygame.Surface</cite> en utilisant l’accélération GPU.</p>
<p>Cette fonction applique un effet de distorsion fisheye à une surface donnée en utilisant un traitement basé sur CUDA. Elle est optimisée pour le rendu en temps réel et peut être utilisée pour afficher des scènes de jeu avec un effet de lentille.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Surface pygame en entrée au format 24 bits ou 32 bits.</p></li>
<li><p><strong>focal</strong> (<em>float</em>) : Longueur focale de l’effet fisheye, contrôlant l’intensité de la distorsion.</p></li>
<li><p><strong>focal_texture</strong> (<em>float</em>) : Longueur focale de la texture, ajustant davantage l’intensité de l’effet fisheye.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>) : Dimensions de la grille CUDA <cite>(grid_y, grid_x)</cite>. Définit comment le calcul est distribué sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Dimensions du bloc CUDA <cite>(block_y, block_x)</cite>. Le nombre maximum de threads par bloc ne doit pas dépasser 1024.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>) : Un nouveau <cite>pygame.Surface</cite> avec l’effet de lentille fisheye appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une instance de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la fonction ne peut pas accéder aux données des pixels de <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction exploite CUDA pour un traitement d’image haute performance.</p></li>
<li><p>L’effet est appliqué directement à la surface en entrée et retourné sous forme de surface transformée.</p></li>
<li><p>Assurez-vous que les valeurs de grille et de bloc sont choisies de manière à correspondre aux tailles de texture et de tableau pour des performances optimales.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.swirl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">swirl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.swirl_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de distorsion en spirale à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction crée un effet de spirale sur un <cite>pygame.Surface</cite> donné en appliquant une transformation basée sur CUDA. L’effet déforme les pixels de manière radiale autour d’un point central spécifié.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : Surface en entrée, doit être au format 24 bits ou 32 bits.</p></li>
<li><p><strong>rad</strong> (<em>float</em>) : Angle de rotation en radians, contrôlant l’intensité de l’effet de spirale.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>) : Taille de la grille CUDA, typiquement <cite>(grid_y, grid_x)</cite>. Définit comment le calcul est distribué sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>) : Taille du bloc CUDA, typiquement <cite>(block_y, block_x)</cite>. Le nombre de threads par bloc ne doit pas dépasser 1024.</p></li>
<li><p><strong>centre_x</strong> (<em>int</em>) : Coordonnée X du centre de la spirale (doit être supérieure à 0).</p></li>
<li><p><strong>centre_y</strong> (<em>int</em>) : Coordonnée Y du centre de la spirale (doit être supérieure à 0).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>) : Un nouveau <cite>pygame.Surface</cite> avec l’effet de spirale appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong> : Si la surface d’entrée ne peut pas être référencée comme un tableau 3D.</p></li>
<li><p><strong>TypeError</strong>: If <cite>surface_</cite> is not a valid <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction s’exécute directement sur le GPU en utilisant CuPy pour des performances élevées.</p></li>
<li><p>Assurez-vous que <cite>grid_</cite> et <cite>block_</cite> sont correctement configurés pour une exécution optimale.</p></li>
<li><p>La fonction appelle <cite>swirl_cupy</cite>, qui prend en charge le traitement réel basé sur le GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wave_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wave_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wave_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Crée un effet de vague sur une image en utilisant l’accélération GPU.</p>
<p>Cette fonction applique un effet de distorsion en vague à un <cite>pygame.Surface</cite> en utilisant une transformation basée sur CUDA. L’effet crée un mouvement de vague réaliste sur l’image en fonction de l’angle et de la taille du bloc spécifiés.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>) : La surface d’image en entrée, qui doit être au format 24 bits ou 32 bits.</p></li>
<li><p><strong>rad_</strong> (<em>float</em>): Un angle variable en radians qui contrôle l’effet de vague.</p></li>
<li><p><strong>size_</strong> (<em>int</em>): La taille du bloc pour l’effet de vague. Pour un effet réaliste, il est recommandé de garder la taille inférieure à 15.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Taille de la grille CUDA, typiquement <cite>(grid_y, grid_x)</cite>, définissant comment le calcul est réparti sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Taille du bloc CUDA, typiquement <cite>(block_y, block_x)</cite>. Le nombre de threads par bloc ne doit pas dépasser 1024.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nouveau <cite>pygame.Surface</cite> avec l’effet de vague appliqué. Il est recommandé de redimensionner l’image pour masquer toute distorsion visible sur les bords gauche et inférieur, en particulier si un effet de bouclage de texture est perceptible.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Exemple d’utilisation : <cite>IMAGE = wave_gpu(IMAGE, 8 * math.pi/180.0 + FRAME/10, 8, grid, block)</cite> <cite>IMAGE = scale(IMAGE, (WIDTH + 16, HEIGHT + 16))</cite> pour masquer l’effet de bouclage.</p></li>
<li><p>La fonction s’exécute directement sur le GPU en utilisant CuPy pour des performances élevées.</p></li>
<li><p>Assurez-vous que les configurations de grille et de bloc sont correctement sélectionnées pour des performances optimales.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.chromatic_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">chromatic_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.chromatic_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de déplacement chromatique à une surface donnée en utilisant l’accélération GPU.</p>
<p>Cet effet crée une séparation des couleurs en décalant les canaux RGB en fonction des valeurs de déplacement horizontal et vertical spécifiées. La fonction est optimisée pour les formats d’image 24 bits et 32 bits.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée à traiter. Doit être au format 24 bits ou 32 bits.</p></li>
<li><p><strong>delta_x</strong> (<em>int</em>): Déplacement horizontal pour le décalage chromatique. Affecte les canaux rouge et bleu, créant un effet de séparation des couleurs. Une valeur de zéro entraîne l’absence de déplacement horizontal (si <cite>fx</cite> est faible).</p></li>
<li><p><strong>delta_y</strong> (<em>int</em>): Déplacement vertical pour le décalage chromatique. Fonctionne de manière similaire à <cite>delta_x</cite>, mais s’applique au mouvement vertical. Une valeur de zéro entraîne l’absence de déplacement vertical (si <cite>fx</cite> est faible).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant les dimensions de la grille, par exemple <cite>(25, 25)</cite>. Définit la division de l’image pour le traitement GPU et doit correspondre aux tailles de la texture et du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant les dimensions du bloc, par exemple <cite>(32, 32)</cite>. Détermine le nombre de threads par bloc dans le traitement GPU. Le produit <cite>block_x * block_y</cite> ne doit pas dépasser 1024 (la limite CUDA pour les threads par bloc).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, optionnel, défaut=`0.999`): Un facteur de zoom contrôlant l’échelle de l’image après traitement. Doit être dans la plage <cite>(0.0, 1.0)</cite>. La valeur par défaut est <cite>1.0</cite> (aucun zoom).</p></li>
<li><p><strong>fx</strong> (<em>float</em>, optionnel, défaut=`0.05`): Intensité de l’effet chromatique, contrôlant la force de séparation des couleurs. Doit être dans la plage <cite>[0.0, 0.2]</cite>. La valeur par défaut est <cite>0.05</cite>.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>cupy.ndarray</em>): Un tableau CuPy représentant l’image traitée avec l’effet de déplacement chromatique appliqué. Le format de sortie est une image 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas de type <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>surface_</cite> a une largeur ou une hauteur de zéro.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>delta_x</cite> ou <cite>delta_y</cite> est négatif.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction exploite l’accélération GPU pour un déplacement chromatique efficace.</p></li>
<li><p>Assurez-vous que les tailles de grille et de bloc sont choisies de manière appropriée en fonction de la taille de l’image et des capacités du GPU.</p></li>
<li><p>Le paramètre <cite>fx</cite> contrôle l’intensité de l’effet de séparation chromatique, et <cite>zoom</cite> permet de redimensionner l’image après la transformation.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.rgb_split_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">rgb_split_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.rgb_split_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de séparation des canaux RGB à une image en utilisant l’accélération GPU.</p>
<p>Cette fonction décale les canaux rouge, vert et bleu d’une image selon <cite>delta_x</cite> et <cite>delta_y</cite> pour créer un effet d’aberration chromatique (glitch). La transformation est entièrement réalisée sur le GPU à l’aide de CuPy.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée au format 24 bits ou 32 bits.</p></li>
<li><p><strong>delta_x</strong> (<em>float</em>): Le décalage horizontal appliqué aux canaux RGB. Une valeur positive déplace les canaux vers la droite, et une valeur négative les déplace vers la gauche.</p></li>
<li><p><strong>delta_y</strong> (<em>float</em>): Le décalage vertical appliqué aux canaux RGB. Une valeur positive déplace les canaux vers le bas, et une valeur négative les déplace vers le haut.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant la taille de la grille pour l’exécution CUDA, définissant la distribution des calculs sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant la taille du bloc, qui détermine le nombre de threads par bloc dans l’exécution sur GPU.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Une nouvelle surface avec l’effet de séparation RGB appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>delta_x</cite> ou <cite>delta_y</cite> sont des valeurs non positives ou si la fonction ne peut pas accéder aux données des pixels de <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>L’effet de séparation RGB crée une distorsion chromatique, couramment utilisé pour les effets de glitch.</p></li>
<li><p><cite>delta_x</cite> et <cite>delta_y</cite> définissent de combien les canaux de couleur sont décalés.</p></li>
<li><p>Assurez-vous que les valeurs <cite>grid_</cite> et <cite>block_</cite> sont optimisées pour l’exécution sur GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.zoom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">zoom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.zoom_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de zoom en utilisant l’accélération GPU.</p>
<p>Cette fonction traite une <cite>pygame.Surface</cite> en mappant ses données de pixels vers la mémoire GPU et en appliquant une transformation de zoom. Elle utilise l’accélération CUDA pour un traitement d’image haute performance.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée à traiter. Elle doit être une image au format 24 bits ou 32 bits.</p></li>
<li><p><strong>centre_x</strong> (<em>unsigned int</em>): La coordonnée x du centre du zoom. Doit être supérieure ou égale à 0.</p></li>
<li><p><strong>centre_y</strong> (<em>unsigned int</em>): La coordonnée y du centre du zoom. Doit être supérieure ou égale à 0.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant les dimensions de la grille. Définit la division de l’image pour le traitement parallèle sur GPU. Les valeurs doivent correspondre aux tailles de texture et de tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant les dimensions du bloc. Détermine le nombre de threads par bloc dans l’exécution sur GPU. Le produit <cite>block_x * block_y</cite> ne doit pas dépasser <cite>1024</cite> (limite CUDA).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, optionnel) : Un facteur de zoom contrôlant l’échelle de l’image. Doit être dans la plage <cite>(0.0, 1.0]</cite>. Par défaut, <cite>1.0</cite> (pas de mise à l’échelle).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>CuPy ndarray</em>): Un tableau CuPy contenant l’image transformée avec le zoom appliqué, en format 24 bits.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : - Si la largeur ou la hauteur de <cite>surface_</cite> est 0. - Si <cite>zoom</cite> n’est pas dans la plage <cite>(0.0, 1.0]</cite>. - Si <cite>centre_x</cite> ou <cite>centre_y</cite> est négatif. - Si <cite>surface_</cite> ne peut pas être mappée vers un tableau 3D.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction effectue l’effet de zoom en mappant les données de pixels vers la mémoire GPU et en utilisant CUDA pour un traitement haute performance.</p></li>
<li><p>Assurez-vous que <cite>grid_</cite> et <cite>block_</cite> sont optimisés pour les capacités de votre GPU et la taille de l’image.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wavelength_map_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wavelength_map_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wavelength_map_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de couleur spécifique au canal (redscale, greenscale ou bluescale) à une image.</p>
<p>Cette fonction applique un effet redscale, greenscale ou bluescale à une image <cite>pygame.Surface</cite> donnée. Elle isole et met en valeur l’un des canaux de couleur (Rouge, Vert ou Bleu) en fonction du paramètre <cite>layer_</cite> fourni. L’opération est effectuée à l’aide de l’accélération GPU pour de meilleures performances.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée à laquelle l’effet sera appliqué.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant la configuration de la grille. Les valeurs de la grille doivent correspondre aux tailles de l’image et du tableau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant la configuration du bloc. Les valeurs du bloc déterminent combien de threads sont lancés par bloc.</p></li>
<li><p><strong>layer_</strong> (<em>unsigned short int</em>, optionnel) : Spécifie quel canal de couleur isoler. La valeur par défaut est <cite>0</cite> (canal rouge). Les valeurs sont : - <cite>0</cite> pour le canal rouge - <cite>1</cite> pour le canal vert - <cite>2</cite> pour le canal bleu</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): L’image avec l’effet de canal sélectionné (redscale, greenscale ou bluescale) appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si la valeur <cite>layer_</cite> n’est pas dans la plage de 0 à 2.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction utilise l’accélération GPU pour un traitement d’image haute performance.</p></li>
<li><p>Le paramètre <cite>layer_</cite> détermine quel canal de couleur est mis en valeur.</p></li>
<li><p>Le résultat est une nouvelle <cite>pygame.Surface</cite> avec l’effet du canal de couleur sélectionné appliqué.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de carte thermique à une image avec inversion optionnelle.</p>
<p>Cette fonction applique un effet de carte thermique à une image en utilisant l’accélération GPU. L’effet de carte thermique est généralement utilisé pour visualiser l’intensité ou la magnitude sur une surface 2D. L’effet peut être inversé en fonction du paramètre <cite>invert_</cite>, modifiant ainsi la représentation des couleurs.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): L’image d’entrée sur laquelle l’effet de carte thermique sera appliqué.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant la configuration de la grille. Les valeurs de la grille doivent correspondre aux tailles de texture et de tableau pour l’exécution parallèle sur le GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant la configuration du bloc. Il définit le nombre de threads par bloc pour l’exécution sur le GPU. Le produit <cite>block_x * block_y</cite> ne doit pas dépasser <cite>1024</cite> (limite des threads par bloc de CUDA).</p></li>
<li><p><strong>invert_</strong> (<em>booléen</em>, optionnel) : Si <cite>True</cite>, la gamme de couleurs de la carte thermique est inversée (inversée). La valeur par défaut est <cite>False</cite>, ce qui signifie qu’il n’y a pas d’inversion.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): L’image avec l’effet de carte thermique appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>invert_</cite> n’est pas un booléen.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement d’image haute performance.</p></li>
<li><p>L’inversion de la carte thermique permet une représentation des couleurs différente.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu_inplace" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique l’effet de carte thermique directement à une pygame.Surface.</p>
<p>Cette fonction applique un effet de carte thermique à la surface d’entrée, modifiant directement les données des pixels sans retourner une nouvelle surface. La visualisation de la carte thermique améliore l’intensité de l’image en fonction d’un mappage des couleurs, avec l’option d’inverser l’effet de couleur.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface sur laquelle l’effet de carte thermique sera appliqué. La surface doit être une <cite>pygame.Surface</cite> valide contenant des données de pixels dans un tableau 3D (canaux RGB).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant la configuration de la grille pour l’exécution parallèle sur le GPU. Les valeurs de la grille doivent correspondre aux tailles du tableau et de la texture.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant la configuration du bloc. Il définit le nombre de threads par bloc pour le calcul sur le GPU. Le produit <cite>block_x * block_y</cite> ne doit pas dépasser <cite>1024</cite> (le nombre maximal de threads par bloc de CUDA).</p></li>
<li><p><strong>invert_</strong> (<em>booléen</em>, optionnel) : Si <cite>True</cite>, l’effet de carte thermique est inversé, inversant la gamme de couleurs. La valeur par défaut est <cite>False</cite> (pas d’inversion).</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>void</em>): Cette fonction modifie directement la <cite>surface_</cite> et ne retourne pas de valeur.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>invert_</cite> n’est pas un booléen.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>La fonction utilise l’accélération GPU pour un traitement d’image haute performance.</p></li>
<li><p>L’effet est appliqué directement, ce qui signifie que la <cite>surface_</cite> d’entrée est modifiée directement.</p></li>
<li><p>L’inversion de la carte thermique permet une représentation des couleurs inversée.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.predator_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">predator_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.predator_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Applique un effet de vision de prédateur à l’aide de l’accélération GPU.</p>
<p>Cette fonction traite la <cite>pygame.Surface</cite> d’entrée pour appliquer un effet de vision de prédateur en utilisant l’accélération GPU. L’effet simule un filtre de vision avec un effet de bloom et des ajustements de carte de couleurs, qui peuvent être personnalisés en fonction des paramètres fournis.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée à traiter.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Un tuple <cite>(grid_y, grid_x)</cite> représentant les dimensions de la grille pour l’exécution du noyau CUDA.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Un tuple <cite>(block_y, block_x)</cite> représentant les dimensions du bloc pour l’exécution du noyau CUDA.</p></li>
<li><p><strong>bloom_smooth</strong> (<em>entier non signé</em>, optionnel) : Le facteur de lissage pour l’effet de bloom. La valeur par défaut est <cite>50</cite>.</p></li>
<li><p><strong>bloom_threshold</strong> (<em>entier non signé</em>, optionnel) : Le seuil d’intensité pour l’effet de bloom. La valeur par défaut est <cite>50</cite>.</p></li>
<li><p><strong>inv_colormap</strong> (<em>booléen</em>, optionnel) : Si la carte de couleurs doit être inversée. La valeur par défaut est <cite>False</cite>.</p></li>
<li><p><strong>blend</strong> (<em>int</em>, optionnel) : Le mode de fusion pour le rendu final. La valeur par défaut est <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
<li><p><strong>bloom_flag</strong> (<em>booléen</em>, optionnel) : Indicateur pour activer l’effet de bloom. La valeur par défaut est <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): La surface traitée avec l’effet de vision de prédateur appliqué.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>bloom_smooth</cite>, <cite>bloom_threshold</cite> ne sont pas des entiers positifs ou si <cite>blend</cite> n’est pas un mode de fusion valide.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction utilise l’accélération GPU pour appliquer un effet de vision de prédateur rapide.</p></li>
<li><p>L’effet de bloom simule des zones brillantes à haute intensité, et la carte de couleurs peut être inversée pour des effets visuels différents.</p></li>
<li><p>Les paramètres <cite>blend</cite> et <cite>bloom_flag</cite> permettent de personnaliser l’effet final de rendu.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.downscale_surface_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">downscale_surface_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.downscale_surface_gpu" title="Lien vers cette définition">¶</a></dt>
<dd><p>Réduire la taille d’une surface pygame en utilisant CUDA sur CuPy.</p>
<p>Cette fonction extrait les données des pixels d’une <cite>pygame.Surface</cite>, les transfère vers le GPU, applique une opération de réduction de taille en utilisant un noyau CUDA, puis retourne l’image traitée dans un tampon d’octets.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La surface d’entrée à réduire.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensions de la grille CUDA pour l’exécution du noyau.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensions du bloc CUDA pour l’exécution du noyau.</p></li>
<li><p><strong>zoom</strong> (<em>flottant</em>): Le facteur de mise à l’échelle pour la réduction de taille. Il doit être dans la plage <cite>[0.0, 0.9999]</cite>.</p></li>
<li><p><strong>w2</strong> (<em>int</em>): La largeur cible de l’image réduite.</p></li>
<li><p><strong>h2</strong> (<em>int</em>): La hauteur cible de l’image réduite.</p></li>
</ul>
<p><strong>Retourne :</strong></p>
<ul class="simple">
<li><p>(<em>bytes</em>): L’image réduite au format RGB sous forme de tampon d’octets.</p></li>
</ul>
<p><strong>Raises:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong> : Si <cite>surface_</cite> n’est pas une <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong> : Si <cite>zoom</cite> n’est pas dans la plage <cite>[0.0, 0.9999]</cite>, ou si <cite>w2</cite> ou <cite>h2</cite> sont des valeurs non positives.</p></li>
</ul>
<p><strong>Remarques :</strong></p>
<ul class="simple">
<li><p>Cette fonction utilise l’accélération GPU avec CuPy pour une réduction de taille efficace.</p></li>
<li><p>L’image réduite est retournée sous forme de tampon d’octets au format RGB.</p></li>
<li><p>Assurez-vous que les valeurs de la grille et du bloc sont optimisées pour les performances du GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table des matières</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader_gpu</a><ul>
<li><a class="reference internal" href="#gpu-accelerated-image-processing-library">1. Bibliothèque de traitement d’images accélérée par GPU</a></li>
<li><a class="reference internal" href="#key-features-use-cases">2. Principales fonctionnalités et cas d’utilisation</a></li>
<li><a class="reference internal" href="#use-case">3. Cas d’utilisation</a></li>
<li><a class="reference internal" href="#potential-applications">4. Applications potentielles</a></li>
<li><a class="reference internal" href="#summary">5. Résumé</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Méthodes de liste en Cython</a><ul>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_free_mem"><code class="docutils literal notranslate"><span class="pre">get_gpu_free_mem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_maxmem"><code class="docutils literal notranslate"><span class="pre">get_gpu_maxmem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_pci_bus_id"><code class="docutils literal notranslate"><span class="pre">get_gpu_pci_bus_id()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_compute_capability"><code class="docutils literal notranslate"><span class="pre">get_compute_capability()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_max_grid_per_block"><code class="docutils literal notranslate"><span class="pre">get_max_grid_per_block()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_grid"><code class="docutils literal notranslate"><span class="pre">block_grid()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.conv"><code class="docutils literal notranslate"><span class="pre">conv()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_and_grid_info"><code class="docutils literal notranslate"><span class="pre">block_and_grid_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_info"><code class="docutils literal notranslate"><span class="pre">get_gpu_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu"><code class="docutils literal notranslate"><span class="pre">invert_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">invert_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">invert_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_rgb_array_inplace"><code class="docutils literal notranslate"><span class="pre">invert_rgb_array_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_rgb_array_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_rgb_array_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_inplace_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_inplace_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_lum_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_lum_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_generic_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_generic_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_5x5_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_3x3_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_3x3_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sobel_gpu"><code class="docutils literal notranslate"><span class="pre">sobel_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.prewitt_gpu"><code class="docutils literal notranslate"><span class="pre">prewitt_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.canny_gpu"><code class="docutils literal notranslate"><span class="pre">canny_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.color_reduction_gpu"><code class="docutils literal notranslate"><span class="pre">color_reduction_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsv_gpu"><code class="docutils literal notranslate"><span class="pre">hsv_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mult_downscale_gpu"><code class="docutils literal notranslate"><span class="pre">mult_downscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.upscale_c"><code class="docutils literal notranslate"><span class="pre">upscale_c()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_gpu"><code class="docutils literal notranslate"><span class="pre">bloom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_array"><code class="docutils literal notranslate"><span class="pre">bloom_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.cartoon_gpu"><code class="docutils literal notranslate"><span class="pre">cartoon_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.blending_gpu"><code class="docutils literal notranslate"><span class="pre">blending_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.ripple_effect_gpu"><code class="docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen1_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen1_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mirroring_gpu"><code class="docutils literal notranslate"><span class="pre">mirroring_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.saturation_gpu"><code class="docutils literal notranslate"><span class="pre">saturation_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bilateral_gpu"><code class="docutils literal notranslate"><span class="pre">bilateral_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.emboss5x5_gpu"><code class="docutils literal notranslate"><span class="pre">emboss5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.area24_gpu"><code class="docutils literal notranslate"><span class="pre">area24_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.brightness_gpu"><code class="docutils literal notranslate"><span class="pre">brightness_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsl_gpu"><code class="docutils literal notranslate"><span class="pre">hsl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.dithering_gpu"><code class="docutils literal notranslate"><span class="pre">dithering_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.fisheye_gpu"><code class="docutils literal notranslate"><span class="pre">fisheye_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.swirl_gpu"><code class="docutils literal notranslate"><span class="pre">swirl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wave_gpu"><code class="docutils literal notranslate"><span class="pre">wave_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.chromatic_gpu"><code class="docutils literal notranslate"><span class="pre">chromatic_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.rgb_split_gpu"><code class="docutils literal notranslate"><span class="pre">rgb_split_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.zoom_gpu"><code class="docutils literal notranslate"><span class="pre">zoom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wavelength_map_gpu"><code class="docutils literal notranslate"><span class="pre">wavelength_map_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.predator_gpu"><code class="docutils literal notranslate"><span class="pre">predator_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.downscale_surface_gpu"><code class="docutils literal notranslate"><span class="pre">downscale_surface_gpu()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Sujet précédent</h4>
    <p class="topless"><a href="Shader.html"
                          title="Chapitre précédent">Shader</a></p>
  </div>
  <div>
    <h4>Sujet suivant</h4>
    <p class="topless"><a href="PygameTools.html"
                          title="Chapitre suivant">PygameTools</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Cette page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader_gpu.rst.txt"
            rel="nofollow">Montrer le code source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Index général"
             >index</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             >suivant</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Shader"
             >précédent</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Documentation PygameShader 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Créé en utilisant <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>