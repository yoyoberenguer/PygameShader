
<!DOCTYPE html>

<html lang="es" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader &#8212; documentación de PygameShader - 1.0.11</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=28946ee5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=f85f4cfb"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Búsqueda" href="search.html" />
    <link rel="next" title="Shader_gpu" href="Shader_gpu.html" />
    <link rel="prev" title="¡Bienvenido a la documentación de PygameShader!" href="index.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="¡Bienvenido a la documentación de PygameShader!"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentación de PygameShader - 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader">
<h1>Shader<a class="headerlink" href="#shader" title="Link to this heading">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader.pyx</span></code></p>
<hr class="docutils" />
<section id="high-performance-image-processing-library">
<h2>1. Biblioteca de Procesamiento de Imágenes de Alto Rendimiento<a class="headerlink" href="#high-performance-image-processing-library" title="Link to this heading">¶</a></h2>
<p>Esta biblioteca es un módulo basado en Cython diseñado para el procesamiento y manipulación de imágenes de alto rendimiento. Aprovechando la capacidad de Cython para combinar la facilidad de uso de Python con un rendimiento similar al de C, está optimizada para tareas computacionalmente intensivas como el procesamiento de imágenes en tiempo real, el desarrollo de juegos, la visión por computadora y los efectos artísticos.</p>
</section>
<section id="key-features">
<h2>2. Características Clave<a class="headerlink" href="#key-features" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Conversiones de espacio de color</strong> (RGB, escala de grises, HSL, HSV)</p></li>
<li><p><strong>Transformaciones de imagen</strong> (espeje, pixelado, cambio de tamaño)</p></li>
<li><p><strong>Efectos visuales</strong> (distorsiones, filtros, efectos artísticos)</p></li>
<li><p><strong>Procesamiento avanzado de imágenes</strong> (detección de bordes, enfoque, mezcla)</p></li>
<li><p><strong>Simulaciones físicas</strong> (efectos de ondas, convección de calor)</p></li>
<li><p><strong>Optimizaciones de rendimiento</strong> (multi-hilos, operaciones eficientes en memoria)</p></li>
</ul>
</section>
<section id="library-functional-overview">
<h2>3. Resumen Funcional de la Biblioteca<a class="headerlink" href="#library-functional-overview" title="Link to this heading">¶</a></h2>
<p><strong>Manipulación de Color</strong></p>
<ul class="simple">
<li><p><strong>Conversiones de Color</strong>: <cite>bgr</cite>, <cite>brg</cite>, <cite>gris</cite>, <cite>sepia</cite>, <cite>efecto_hsl</cite>, <cite>efecto_hsv</cite></p></li>
<li><p><strong>Brillo &amp; Saturación</strong>: <cite>brillo</cite>, <cite>saturación</cite>, <cite>excluir_brillo</cite>, <cite>brillo_bpf</cite></p></li>
<li><p><strong>Inversión de Color</strong>: <cite>invertir</cite></p></li>
</ul>
<p><strong>Efectos Visuales</strong></p>
<ul class="simple">
<li><p><strong>Filtros</strong>: <cite>mediana</cite>, <cite>sobel</cite>, <cite>bloom</cite>, <cite>posterizar_superficie</cite></p></li>
<li><p><strong>Distorsiones</strong>: <cite>ola</cite>, <cite>remolino</cite>, <cite>ojo_de_pez</cite>, <cite>glitch_horizontal</cite>, <cite>glitch_shorizontal</cite></p></li>
<li><p><strong>Efectos Artísticos</strong>: <cite>pintura</cite>, <cite>caricatura</cite>, <cite>dither</cite>, <cite>dither_atkinson</cite></p></li>
</ul>
<p><strong>Procesamiento Avanzado de Imágenes</strong></p>
<ul class="simple">
<li><p><strong>Detección de Bordes y Enfoque</strong>: <cite>sobel</cite>, <cite>sobel_rápido</cite>, <cite>enfoque</cite>, <cite>enfoque32</cite></p></li>
<li><p><strong>Mezcla &amp; Composición</strong>: <cite>mezclar</cite>, <cite>mecla_alpha</cite>, <cite>mecla_alpha_inplace</cite></p></li>
<li><p><strong>Efectos de Mapa de Calor</strong>: <cite>mapacalor</cite>, <cite>visión_predador</cite></p></li>
</ul>
<p><strong>Simulaciones Físicas</strong></p>
<ul class="simple">
<li><p><strong>Efectos de Onda</strong>: <cite>onda</cite>, <cite>onda_fondomarino</cite></p></li>
<li><p><strong>Convección de Calor</strong>: <cite>conveccióncalor</cite></p></li>
<li><p><strong>Efectos de Plasma</strong>: <cite>plasma</cite>, <cite>config_plasma</cite></p></li>
</ul>
<p><strong>Funciones Utilitarias</strong></p>
<ul class="simple">
<li><p><strong>Transformaciones de Imagen</strong>: <cite>espeje</cite>, <cite>pixelado</cite>, <cite>bilineal</cite></p></li>
<li><p><strong>Mapeo de Colores</strong>: <cite>longituddeonda2rgb</cite>, <cite>mapa_personalizado</cite></p></li>
<li><p><strong>Funciones Optimizadas</strong>: <cite>bgr_1d</cite>, <cite>gris_1d</cite>, <cite>invertir1d</cite></p></li>
</ul>
<p><strong>Efectos Especiales</strong></p>
<ul class="simple">
<li><p><strong>Líneas de Escaneo Retro de TV</strong>: <cite>escaneo_tv</cite></p></li>
<li><p><strong>Efectos de Sangre</strong>: <cite>sangre</cite></p></li>
<li><p><strong>Distorsión de Suciedad y Lentes</strong>: <cite>suciedad_lente</cite></p></li>
</ul>
<p><strong>Rendimiento y Optimización</strong></p>
<ul class="simple">
<li><p><strong>Eficiencia de Memoria</strong>: Optimizado para arreglos de píxeles <cite>1D</cite> y <cite>3D</cite></p></li>
<li><p><strong>Procesamiento Paralelo</strong>: Utiliza <cite>nogil</cite> para ejecución multi-hilo</p></li>
</ul>
</section>
<section id="target-applications">
<h2>4. Aplicaciones Objetivo<a class="headerlink" href="#target-applications" title="Link to this heading">¶</a></h2>
<p>Esta biblioteca es ideal para: - <strong>Desarrollo de Juegos</strong>: Efectos visuales en tiempo real, distorsiones, mezcla - <strong>Visión por Computadora</strong>: Preprocesamiento de imágenes para aprendizaje automático y análisis - <strong>Aplicaciones Artísticas</strong>: Efectos creativos para imágenes y videos - <strong>Visualización Científica</strong>: Simulación de fenómenos físicos (calor, ondas)</p>
</section>
<section id="summary">
<h2>5. Resumen<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>Esta biblioteca basada en Cython es un potente conjunto de herramientas para el procesamiento de imágenes, combinando optimizaciones de alto rendimiento con una amplia gama de efectos visuales y transformaciones. Es especialmente adecuada para aplicaciones en tiempo real y de alto rendimiento, lo que la convierte en una herramienta esencial para desarrolladores de juegos, ingenieros de visión por computadora y profesionales creativos.</p>
</section>
<section id="cython-list-methods">
<h2>6. Métodos de listas en Cython<a class="headerlink" href="#cython-list-methods" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convierte una imagen de formato RGB(A) a BGR(A) (en el lugar). Convierte la pantalla del juego, imagen o superficie de RGB(A) a BGR(A). El canal alfa será ignorado en el proceso, pero se mantiene en caso de una superficie de 32 bits.</p>
<p>RGB se usa comúnmente en aplicaciones de edición y visualización de imágenes, donde el orden es rojo, verde y azul. Por otro lado, BGR se usa a menudo en aplicaciones de procesamiento de imágenes, donde el orden es azul, verde y rojo.</p>
<p><strong>Nota</strong>: Esta función opera en el lugar, lo que significa que modifica la superficie original.</p>
<p><strong>Parámetros:</strong></p>
<p><strong>superficie_</strong> (superficie de Pygame) Superficie de Pygame (ya sea de pantalla o imagen) con un formato compatible (24 bits o 32 bits, con o sin canal de transparencia/alfa).</p>
<p><strong>Devuelve:</strong></p>
<p>vacío; modifica la superficie en su lugar.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_copy" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convierte un formato de imagen de RGB(A) a BGR(A) y devuelve una nueva superficie (copia). Esta función convierte los datos de píxeles de una imagen de entrada de RGB(A) a formato BGR(A). El canal Alfa (si está presente) se conservará, pero el orden de los canales de color se cambia de RGB a BGR. Esto es útil cuando se trabaja con bibliotecas de procesamiento de imágenes que esperan el formato BGR (como OpenCV), mientras que el formato RGB es comúnmente usado en aplicaciones de visualización y edición de imágenes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">bgr_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>superficie_</strong> (Pygame Surface) Un objeto Surface de Pygame que representa la imagen. La superficie puede estar en formato de 24 bits o 32 bits (con o sin canal alfa). La función asume que la imagen está en formato RGB(A) y la convertirá a BGR(A).</p>
<p><strong>Devuelve:</strong></p>
<p>Un nuevo objeto Surface de Pygame con el formato de píxel BGR(A) convertido.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_3d" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convierte un arreglo RGB(A) (forma: w, h, n) con tipo de dato uint8 a formato BGR(A) (en su lugar). Esta función procesa directamente un arreglo 3D (como una imagen o superficie) de formato RGB(A) a formato BGR(A). Asume que el arreglo de entrada está en formato RGB o RGBA, y cambia los canales rojo y azul para convertirlo a formato BGR o BGRA, respectivamente. La operación se hace en su lugar, modificando el arreglo original.</p>
<p>RGB es el orden de colores comúnmente utilizado en aplicaciones de visualización y edición de imágenes, donde los canales de color están organizados como rojo, verde, azul. Por otro lado, BGR es comúnmente usado en aplicaciones de procesamiento de imágenes, donde los canales de color están organizados como azul, verde, rojo.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_3d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D de numpy con forma (w, h, n), donde <cite>w</cite> es el ancho, <cite>h</cite> es la altura, y <cite>n</cite> es el número de canales (3 para RGB, 4 para RGBA). El arreglo debe tener tipo de dato uint8 (valores entre 0 y 255), y contener datos de píxeles en formato RGB(A).</p>
<p><strong>Devuelve:</strong></p>
<p>vacío Esta función modifica el arreglo de entrada en su lugar y no devuelve ningún valor.</p>
<p><strong>Lanza:</strong></p>
<p><strong>ValueError</strong> Si la forma del arreglo de entrada no es compatible con RGB(A) (es decir, no tiene la forma (w, h, 3) o (w, h, 4)).</p>
<p><strong>TypeError</strong> Si el arreglo de entrada no tiene el tipo de dato uint8 (byte sin signo).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convierte un arreglo 1D de tipo de dato uint8 de RGB(A) a formato BGR(A) (en su lugar). Esta función procesa directamente un arreglo 1D, convirtiendo los canales de color del formato RGB(A) al formato BGR(A). La conversión se hace en su lugar, modificando el arreglo original. La bandera <cite>format_32</cite> determina si la entrada está en formato RGB (24 bits) o RGBA (32 bits).</p>
<p>RGB es el orden de color estándar utilizado en muchas aplicaciones de edición de imágenes y visualización, donde el orden de los canales de color es rojo, verde y azul. En contraste, BGR es utilizado en procesamiento de imágenes, donde los canales de color están organizados como azul, verde y rojo.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_1d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D (o búfer) de datos de píxeles en formato RGB(A), con tipo de dato uint8 (valores entre 0 y 255). La longitud del arreglo debe ser un múltiplo de 3 (para RGB) o 4 (para RGBA). El arreglo contiene los valores de color de píxeles que se convertirán de RGB(A) a formato BGR(A).</p>
<p><strong>format_32</strong> (bool, opcional) Un indicador booleano que señala el formato del arreglo de entrada. - <cite>True</cite> indica que el arreglo está en “RGB” (24-bit, 3 canales). - <cite>False</cite> (predeterminado) indica que el arreglo está en “RGBA” (32-bit, 4 canales).</p>
<p><strong>Devuelve:</strong></p>
<p>void La función modifica el arreglo de entrada en su lugar y no retorna ningún valor.</p>
<p><strong>Lanza:</strong></p>
<p><strong>TypeError</strong> Si el arreglo de entrada no tiene un tipo de dato <cite>uint8</cite>.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bgr_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bgr_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bgr_1d_cp" title="Link to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Convierte un arreglo 1D de formato RGB(A) a BGR(A) y retorna una nueva copia. Esta función toma un arreglo 1D (o un fragmento de <cite>memoryview</cite>) que contiene datos de píxeles en orden RGB(A) y produce un nuevo arreglo 1D con los canales de color reordenados a BGR(A). Esta conversión es útil cuando se trabaja con bibliotecas o rutinas que esperan píxeles en formato BGR(A) en lugar del más común orden RGB(A).</p>
<p>La función asume que el arreglo de entrada es de tipo uint8, y su longitud debe ser un múltiplo de 3 (para datos RGB) o 4 (para datos RGBA). El indicador <cite>format_32</cite> señala si los píxeles de entrada son de 32 bits (True para RGBA, False para RGB).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_bgr_array</span> <span class="o">=</span> <span class="n">bgr_1d_cp</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray o fragmento de memoryview, forma <cite>(w,)</cite>, tipo <cite>uint8</cite>) Un arreglo 1D o buffer que contiene datos de píxeles en orden RGB(A). Por ejemplo, si la imagen es RGB, la longitud del arreglo debe ser 3 * número_de_píxeles).</p>
<p><strong>format_32</strong> (bool, opcional) Un indicador que señala el formato del píxel: - <cite>False</cite> (predeterminado): se asume que la entrada es de 24 bits (RGB, 3 canales). - <cite>True</cite>: se asume que la entrada es de 32 bits (RGBA, 4 canales).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo arreglo 1D (uint8) con los datos de píxeles convertidos a orden BGR(A).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una superficie de Pygame de RGB(A) a BRG(A) en su lugar. Esta función modifica la superficie dada intercambiando los canales de color rojo y verde, convirtiendo una imagen de orden RGB(A) a orden BRG(A). El canal alfa, si está presente, se conserva pero se ignora durante el proceso de conversión.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame o superficie de pantalla compatible con formatos de píxeles de 24 bits (RGB) o 32 bits (RGBA). La función opera directamente sobre la superficie proporcionada.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> La función modifica la superficie de entrada en su lugar y no retorna una nueva superficie.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_copy" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una imagen de RGB(A) a formato BRG(A) y retorna una nueva copia. Esta función intercambia los canales rojo y verde de una imagen mientras preserva el canal azul. Crea y retorna una nueva superficie con el formato de color modificado, dejando la superficie original sin cambios.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_surface</span> <span class="o">=</span> <span class="n">brg_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame o superficie de pantalla en formato de 24 bits (RGB) o 32 bits (RGBA). El canal alfa (si está presente) será ignorado.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>pygame.Surface</strong> Una nueva superficie con los canales de color convertidos a BRG formato.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">:]</span> <span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_3d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 3D de formato RGB(A) a BRG(A) (in situ). Esta función intercambia los canales rojo y verde mientras preserva los canales azul y alfa (si están presentes). Modifica el arreglo de entrada directamente sin crear una copia.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray, forma (w, h, n), dtype uint8) Un arreglo 3D que representa una imagen, donde los valores de los píxeles varían de 0 a 255. La última dimensión (n) debe ser 3 (RGB) o 4 (RGBA).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> La función opera in situ y no devuelve un nuevo arreglo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 1D de datos de píxeles RGB(A) a formato BRG(A) in situ. Esta función intercambia los canales rojo y azul de un arreglo o búfer de entrada que representa datos de píxeles RGB o RGBA. Funciona tanto en formatos de 24 bits (RGB) como de 32 bits (RGBA).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brg_1d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>  <span class="c1"># Converts an RGB(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D de forma (w,) que contiene datos de píxeles uint8 (valores 0-255). Puede ser un arreglo NumPy o un búfer de bytes crudo.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado = False) - True: Trata la entrada como un búfer RGB (24 bits). - False: Trata la entrada como un búfer RGBA (32 bits).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> La operación se realiza in situ, modificando <cite>rgb_array</cite> directamente.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brg_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brg_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">char</span> <span class="pre">[::1]</span> <span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bint</span> <span class="pre">format_32=False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brg_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 1D de datos de píxeles uint8 BGR(A) a formato BRG(A) y devuelve un nuevo arreglo. A diferencia de la versión in situ (<cite>brg_1d</cite>), esta función crea y devuelve un nuevo arreglo con los canales rojo y azul intercambiados.</p>
<p>BRG significa Azul, Rojo, Verde.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bgr_array</span> <span class="o">=</span> <span class="n">brg_1d_cp</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>  <span class="c1"># Converts an BGR(A) buffer to BRG(A)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D de forma (w,) que contiene datos de píxeles uint8 (valores 0-255). Puede ser un arreglo NumPy o un búfer de bytes crudo.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado = False) - True: Trata la entrada como un búfer BGR (24 bits). - False: Trata la entrada como un búfer BGRA (32 bits).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo arreglo de forma (w,) con el formato de píxeles BRG(A) (copiado).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una imagen a escala de grises preservando la luminosidad (in situ). Una imagen en escala de grises tiene un solo canal que representa la intensidad o el brillo de los píxeles, donde los valores de los píxeles varían de 0 (negro) a 255 (blanco). Esta función calcula los valores de escala de grises basados en la luminosidad, preservando el brillo percibido de la imagen en color original.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grey</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame o un objeto compatible con superficie de visualización, con una imagen en formato de 24 bits o 32 bits. La superficie puede incluir transparencia o un canal alfa.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> La función modifica la superficie de entrada in situ y no devuelve una nueva superficie.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span> <span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_copy" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una imagen a escala de grises preservando la luminosidad y devuelve una nueva superficie. Una imagen en escala de grises tiene un solo canal que representa la intensidad o el brillo de los píxeles, con valores de píxeles que generalmente varían de 0 (negro) a 255 (blanco). Esta función convierte la imagen original a escala de grises basándose en la luminosidad, preservando el brillo percibido de la imagen en color. El canal alfa se preserva en imágenes con transparencia (formato RGBA), pero no se altera.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">grey_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame o un objeto compatible con superficie de visualización, con una imagen en formato de 24 bits o 32 bits. La superficie puede incluir transparencia (canal alfa).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>pygame.Surface</strong> Un nuevo objeto de superficie que contiene la imagen en escala de grises. La superficie original permanece sin cambios.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_2d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_2d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una imagen en un arreglo 2D de escala de grises. Una imagen en escala de grises tiene un solo canal que representa la intensidad o el brillo de los píxeles, con valores de píxeles que generalmente varían de 0 (negro) a 255 (blanco). Esta función convierte la imagen de entrada a escala de grises basándose en la luminosidad, preservando la intensidad de la imagen en color original. El canal alfa, si está presente, se ignorará en la salida.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">gray</span> <span class="o">=</span> <span class="n">grey_2d</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame o un objeto compatible con superficie de visualización, con una imagen en formato de 24 bits o 32 bits. La superficie puede incluir transparencia (canal alfa), que se ignorará durante la conversión.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un arreglo 2D de NumPy que contiene los datos de la imagen en escala de grises. El arreglo tendrá forma (w, h) y dtype uint8, donde cada valor representa la intensidad del píxel.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_3d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 3D (w, h, n) en formato RGB(A) a escala de grises (con alfa) in situ. Esta función procesa un arreglo 3D directamente, convirtiéndolo a escala de grises basándose en la luminosidad mientras preserva el canal alfa (si está presente). Los valores de píxeles en el arreglo de escala de grises resultante representan intensidad o brillo, variando de 0 (negro) a 255 (blanco).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit image/surface</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

<span class="c1"># For a 32-bit image with alpha channel</span>
<span class="n">grey_3d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D de NumPy de forma (w, h, n) con dtype uint8, que contiene datos de píxeles en formato RGB(A). Los valores en el arreglo varían de 0 a 255. Para arreglos de 32 bits (RGBA), el canal alfa se preservará pero se ignorará en la conversión a escala de grises.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> Esta función modifica el arreglo de entrada in situ y no devuelve un nuevo arreglo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 1D de datos uint8 (RGB(A)) a escala de grises (con alfa) in situ. Una imagen en escala de grises tiene un solo canal que representa la intensidad o el brillo de los píxeles, con valores de píxeles que generalmente varían de 0 (negro) a 255 (blanco). Esta función convierte el arreglo RGB(A) de entrada a escala de grises mientras preserva el canal alfa (si está presente). La conversión se realiza in situ, modificando el arreglo original.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For a 24-bit buffer (RGB)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># For a 32-bit buffer (RGBA)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">PIL</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">size</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">getdata</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">grey_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">frombytes</span><span class="p">(</span><span class="s1">&#39;RGBA&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">arr</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Establece <cite>format_32</cite> en <cite>True</cite> si el arreglo es un búfer de 32 bits que contiene valores RGBA.</p>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D o búfer que contiene datos de píxeles en formato RGB(A), con dtype uint8 (valores de carácter sin signo que varían de 0 a 255).</p>
<p><strong>format_32</strong> (bool, opcional) Si es <cite>True</cite>, la función asume que la entrada es un búfer de 32 bits (RGBA). Si es <cite>False</cite>, la función asume un búfer de 24 bits (RGB).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> La función modifica el arreglo de entrada in situ y no devuelve un nuevo arreglo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.grey_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">grey_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.grey_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 1D de datos uint8 BGR(A) a escala de grises (con canal alfa) y devuelve una copia. Esta función verifica que el arreglo de entrada tenga el tipo de datos uint8 esperado, y luego convierte los datos de píxeles de formato BGR o BGRA a escala de grises. La conversión preserva el canal alfa (si está presente). Devuelve un nuevo arreglo 1D de NumPy en formato de escala de grises.</p>
<p>La conversión a escala de grises se basa en la fórmula de luminosidad, que calcula el brillo basándose en los canales rojo, verde y azul.</p>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un arreglo 1D que contiene datos de píxeles en formato BGR(A), con dtype uint8. Los valores de píxeles deben variar de 0 a 255. Si el arreglo representa una imagen BGRA, el canal alfa se preservará.</p>
<p><strong>format_32</strong> (bool, opcional) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato BGRA (32 bits). Si es <cite>False</cite>, se asume que el arreglo está en formato BGR (24 bits).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo arreglo 1D de NumPy de forma (w,) con dtype uint8, que contiene los datos de píxeles en escala de grises. Si la entrada estaba en formato BGRA, el canal alfa se preserva en la salida.</p>
<p><strong>Lanza:</strong></p>
<p><strong>TypeError</strong> Si el arreglo de entrada no tiene dtype uint8, se lanzará un <cite>TypeError</cite>.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de tono sepia a una imagen, superficie o gráficos de videojuegos (in situ). El tono sepia es una técnica utilizada en fotografía e imágenes donde la imagen se tiñe de un tono marrón rojizo, simulando los tonos cálidos de las fotografías antiguas. Crea una estética más suave y onírica en comparación con la escala de grises estándar, añadiendo profundidad y un aspecto vintage.</p>
<p>Esta función transforma la superficie proporcionada en un modelo equivalente con tono sepia, ajustando los colores de los píxeles en consecuencia mientras preserva la estructura original. La transformación se aplica directamente a la superficie (in situ), y no se devuelve una nueva superficie.</p>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sepia</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_copy" title="Link to this definition">¶</a></dt>
<dd><p>Modelo sepia (Nueva superficie)</p>
<p>Transforma tu videojuego/imagen o superficie en un modelo equivalente con tono sepia.</p>
<p>Mientras que las fotografías tradicionales en blanco y negro utilizan una escala de grises estándar para crear luces y sombras, las fotografías en tono sepia utilizan un tono marrón rojizo para crear ese espectro. “El sepia es una manipulación más suave de la luz.” Esto les da una estética más suave y onírica.</p>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">sepia_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_3d" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de tono sepia a un arreglo de imagen 3D RGB(A) (in situ).</p>
<p>Esta función procesa un arreglo 3D de NumPy que representa datos de píxeles en formato RGB(A) y aplica un filtro sepia. El efecto sepia se logra ajustando los canales rojo, verde y azul según coeficientes predefinidos, creando un efecto cálido y vintage. La función modifica el arreglo de entrada directamente y no devuelve nada.</p>
<p>Solo se admiten arreglos con formas (w, h, 3) para RGB o (w, h, 4) para RGBA.</p>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D con forma (w, h, 3) para datos de píxeles RGB o (w, h, 4) para RGBA, donde <cite>w</cite> es el ancho, <cite>h</cite> es la altura, y <cite>3</cite> o <cite>4</cite> corresponde a los canales RGB o RGBA. El arreglo debe tener dtype uint8 (carácter sin signo) con valores de píxeles que varían de 0 a 255.</p>
<p><strong>Lanza:</strong></p>
<p><strong>ValueError</strong> Si el arreglo de entrada no tiene la forma esperada (w, h, 3) o (w, h, 4).</p>
<p><strong>TypeError</strong> Si el arreglo de entrada no tiene dtype uint8.</p>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función modifica el arreglo de entrada <cite>rgb_array</cite> directamente (in situ).</p></li>
<li><p>Si la entrada está en formato RGBA, el canal alfa se preserva.</p></li>
<li><p>El efecto sepia se aplica ajustando la luminosidad de los canales RGB utilizando un conjunto de coeficientes.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assuming rgb_array is a 3D NumPy array with shape (w, h, 3) for RGB or (w, h, 4) for RGBA:</span>
<span class="n">sepia_3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sepia_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sepia_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sepia_1d" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un arreglo 1D de datos uint8 (RGB(A)) a equivalente sepia (in situ).</p>
<p>Mientras que las fotografías tradicionales en blanco y negro utilizan una escala de grises estándar para crear luces y sombras, las fotografías en tono sepia utilizan un tono marrón rojizo para crear ese espectro. «El sepia es una manipulación más suave de la luz,» creando una estética más suave y onírica.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Para una imagen de 24 bits (RGB):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Para una imagen de 32 bits (RGBA):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>o</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
<span class="n">sepia_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="n">buffer</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 1D de forma (w,) que contiene datos de píxeles uint8 (valores que varían de 0 a 255) en formato RGB(A). Puede ser un arreglo NumPy o un búfer de bytes crudo.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, la entrada se trata como un búfer RGB de 24 bits. Si es <cite>False</cite>, la entrada se trata como un búfer RGBA de 32 bits.</p>
<p><strong>Devuelve:</strong></p>
<p>None La función modifica el arreglo de entrada in situ y no devuelve un nuevo arreglo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduce_factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de mediana a una superficie (in situ).</p>
<p>El filtro de mediana es una técnica de filtrado de imágenes no lineal comúnmente utilizada para eliminar ruido de una imagen o señal. Funciona reemplazando cada valor de píxel con la mediana de los valores de píxeles en un vecindario definido por el tamaño del kernel. Esta técnica se utiliza ampliamente para la reducción de ruido en el procesamiento digital de imágenes, especialmente para preservar bordes mientras se elimina el ruido.</p>
<p>La fuerza del efecto se controla mediante el parámetro <cite>kernel_size</cite>, con tamaños de kernel más grandes produciendo efectos de filtrado más fuertes. Sin embargo, los tamaños de kernel más grandes también pueden ralentizar significativamente el proceso.</p>
<p><strong>Nota:</strong> Este filtro no es adecuado para renderizado en tiempo real en juegos o animaciones debido a su costo computacional.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Para una imagen de 24 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Para una imagen de 32 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">median</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Un objeto de superficie de Pygame (24 bits o 32 bits) que contiene la imagen a procesar. Puede tener o carecer de un canal alfa para transparencia.</p>
<p><strong>kernel_size_</strong> (unsigned short int, opcional, predeterminado=2) El tamaño del kernel o vecindario de píxeles utilizado para el cálculo de la mediana. Aumentar el tamaño del kernel mejora el efecto del filtro pero disminuye el rendimiento.</p>
<p><strong>fast_</strong> (bool, opcional, predeterminado=True) Una bandera para habilitar el cálculo rápido. Si es <cite>True</cite>, el filtro utiliza un tamaño de textura más pequeño para mejorar el rendimiento, lo que puede reducir la calidad según el argumento <cite>reduce_factor_</cite>.</p>
<p><strong>reduce_factor_</strong> (unsigned short int, opcional, predeterminado=1) Un factor para reducir el tamaño de la superficie antes del procesamiento. Un valor de 1 divide la superficie por 2, y un valor de 2 reduce la superficie por 4. Valores mayores que 2 pueden degradar la calidad de la imagen. No tiene efecto si <cite>fast_</cite> es <cite>False</cite>.</p>
<p><strong>Devuelve:</strong></p>
<p>None La función modifica la superficie directamente (in situ) y no devuelve un valor.</p>
<p><strong>Lanza:</strong></p>
<p><strong>ValueError</strong> Si <cite>surface_</cite> no es un <cite>pygame.Surface</cite> válido o si <cite>kernel_size_</cite> o <cite>reduce_factor_</cite> están fuera de los rangos válidos.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.painting">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">painting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.painting" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de pintura (in situ) a una superficie de Pygame.</p>
<p>Esta función transforma una imagen para que se asemeje a un estilo artístico pintado a mano. Lo logra utilizando un algoritmo de filtro de mediana rápida (<cite>median_fast</cite>), que suaviza los valores de píxeles mientras mantiene los detalles de los bordes, dando a la imagen una apariencia similar a pinceladas.</p>
<p><strong>Nota:</strong> - Este método <strong>modifica la superficie de entrada in situ</strong>. - <strong>No está optimizado para renderizado en tiempo real</strong> y está destinado al procesamiento fuera de línea de imágenes.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Para una imagen de 24 bits o 32 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">painting</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 bits o 32 bits), con o sin transparencia por píxel (canal alfa).</p>
<p><strong>Devuelve:</strong></p>
<p>None La función modifica la superficie de entrada directamente.</p>
<p><strong>Lanza:</strong></p>
<p>ValueError Si <cite>surface_</cite> no es un <cite>pygame.Surface</cite> válido.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixels" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de pixelación a una imagen (IN SITU).</p>
<p>La pixelación es un efecto visual en el que una imagen se muestra a baja resolución, haciendo que los píxeles individuales (pequeños elementos cuadrados de un solo color) sean claramente visibles. Esta técnica se utiliza a menudo en gráficos digitales para crear estilos artísticos, censurar partes de una imagen o simular gráficos de videojuegos retro de baja resolución.</p>
<p>Esta función modifica la superficie de entrada in situ, reduciendo los detalles finos y enfatizando las estructuras de píxeles cuadriculados.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Para imágenes de 24 bits y 32 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Rescale image</span>
<span class="n">pixels</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c1"># Apply pixelation effect</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (imagen de 24 bits o 32 bits) con o sin transparencia por píxel (canal alfa).</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La superficie de entrada se modifica directamente (in situ).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.median_grayscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">median_grayscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.median_grayscale" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de mediana a una versión en escala de grises de la imagen (IN SITU).</p>
<p>El <strong>filtro de mediana</strong> es una técnica de filtrado digital no lineal comúnmente utilizada para eliminar ruido de las imágenes mientras se preservan los bordes. Se utiliza ampliamente en el procesamiento de imágenes digitales como un paso de preprocesamiento para tareas como la detección de bordes y la segmentación.</p>
<p>Esta función convierte la superficie de entrada a escala de grises y aplica un efecto de filtro de mediana. La fuerza del efecto de filtrado se controla mediante el parámetro <cite>kernel_size_</cite>.</p>
<p>⚠ <strong>Nota</strong>: - Este método <strong>modifica la superficie in situ</strong>. - <strong>No es adecuado para renderizado en tiempo real</strong>. - Compatible con <strong>superficies de 24 y 32 bits</strong>, con o sin canal alfa.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Aplicar filtro de mediana a una imagen de 24 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p>Aplicar filtro de mediana a una imagen de 32 bits (con canal alfa):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">median_grayscale</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 o 32 bits, con o sin alfa).</p>
<p><strong>kernel_size_</strong> (int, opcional, predeterminado=2) El tamaño del kernel (vecindario de píxeles considerados para el filtrado). Debe ser mayor que 0. Aumentar el tamaño del kernel mejora el efecto de filtrado pero impacta significativamente el rendimiento.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica la superficie de entrada directamente (in situ).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.posterize_surface">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">posterize_surface</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.posterize_surface" title="Link to this definition">¶</a></dt>
<dd><p>Reducir el número de colores en una imagen (IN SITU).</p>
<p>Esta función reduce el número de colores únicos en la superficie dada, creando efectivamente un efecto de posterización. Reducir los colores puede ser útil para efectos artísticos, compresión de imágenes o preprocesamiento para gráficos estilizados.</p>
<p>⚠ <strong>Nota</strong>: - <strong>Modifica la superficie in situ</strong>. - <strong>Funciona con superficies de 24 y 32 bits</strong>, con o sin canal alfa. - Si la superficie tiene un <strong>canal alfa de 32 bits por píxel</strong>, la capa alfa se ignorará, lo que significa que el efecto se aplica solo a los valores RGB.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Reducir el número de colores en una superficie de Pygame a 8:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">color_reduction</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 o 32 bits, con o sin alfa).</p>
<p><strong>color_</strong> (int, opcional, predeterminado=8) El número de colores al que se reducirá la imagen. Debe ser mayor que 0. Valores más bajos producen un efecto más dramático.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica la superficie de entrada directamente (in situ).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar detección de bordes Sobel (In situ)</p>
<p>El operador Sobel, también conocido como operador Sobel-Feldman, se utiliza comúnmente en el procesamiento de imágenes para la detección de bordes. Resalta los bordes en una imagen enfatizando áreas con gradientes de alta intensidad.</p>
<p>Esta función aplica la detección de bordes Sobel a una superficie de Pygame, transformando la superficie para enfatizar sus bordes basándose en el gradiente de intensidades de píxeles.</p>
<p>La superficie de entrada debe estar en escala de grises (24 - 32 bits) para obtener los mejores resultados. Si la superficie no está en escala de grises, solo se utilizará el canal rojo para la detección de bordes.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Aplicar detección de bordes Sobel con un umbral de 64:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Un objeto Pygame.Surface (profundidad de 24 - 32 bits), que puede o no tener un canal alfa. La superficie debe estar en escala de grises, aunque las imágenes que no estén en escala de grises utilizarán el canal rojo para la detección de bordes.</p>
<p><strong>threshold_</strong> (int, opcional, predeterminado=64) Un entero que representa el umbral para detectar bordes. El umbral determina la sensibilidad de la detección de bordes, donde valores más altos requieren gradientes más fuertes para ser considerados un borde.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica la superficie de entrada in situ, actualizándola con el resultado de la detección de bordes Sobel.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">greyscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_1d" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar detección de bordes Sobel 1D (In situ)</p>
<p>Esta función aplica el operador Sobel 1D a una imagen (o superficie) dada, enfatizando los bordes en la dirección horizontal o vertical basándose en el gradiente de intensidades de píxeles. Modifica el/los búfer(es) de entrada in situ.</p>
<p><strong>Ejemplo de uso:</strong></p>
<p>Para una imagen de 24 bits:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">grey</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Para una imagen de 32 bits (con alfa):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">sobel_1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>w</strong> (int) Ancho de la superficie de Pygame a la que hace referencia el arreglo fuente (<cite>bgr_array</cite>).</p>
<p><strong>h</strong> (int) Altura de la superficie de Pygame a la que hace referencia el arreglo fuente (<cite>bgr_array</cite>).</p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un búfer C 1D de tipo uint8 que contiene datos de píxeles en formato BGR. Si la imagen no está en escala de grises, el algoritmo procesa los tres canales RGB. Si la escala de grises está habilitada, solo se utiliza el canal azul para la detección de bordes.</p>
<p><strong>tmp_array</strong> (numpy.ndarray, opcional) Un búfer C 1D de tipo uint8 que contiene datos de píxeles en formato BGR. Es una copia del arreglo fuente <cite>bgr_array</cite>. Tanto <cite>bgr_array</cite> como <cite>tmp_array</cite> deben tener el mismo tamaño y formato de datos. Se utiliza como un búfer temporal durante el procesamiento.</p>
<p><strong>threshold</strong> (int, opcional, predeterminado=64) El umbral para la detección de bordes. Los píxeles con valores de gradiente por encima de este umbral serán considerados bordes.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato BGRA de 32 bits. Si es <cite>False</cite>, se asume que el arreglo de entrada está en formato BGR de 24 bits.</p>
<p><strong>greyscale</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, el algoritmo procesa solo el canal azul para la detección de bordes, lo que puede simplificar el cálculo para imágenes en escala de grises. Si es <cite>False</cite>, se utilizan los tres canales RGB en el operador Sobel.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica los búferes de entrada (<cite>bgr_array</cite> y <cite>tmp_array</cite>) in situ.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sobel_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sobel_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sobel_fast" title="Link to this definition">¶</a></dt>
<dd><p>Sobel rápido (in situ)</p>
<p>El operador Sobel, a veces llamado operador Sobel-Feldman o filtro Sobel, se utiliza en el procesamiento de imágenes y la visión por computadora, particularmente en algoritmos de detección de bordes donde crea una imagen que enfatiza los bordes.</p>
<p>Esta función transforma la pantalla del juego o una superficie de Pygame en un modelo equivalente Sobel. Es más rápida que el operador Sobel estándar (<cite>sobel_inplace_c</cite>) ya que reduce la escala del arreglo que contiene todos los píxeles y aplica el algoritmo Sobel a una muestra más pequeña. Después del procesamiento, el arreglo se vuelve a escalar a sus dimensiones originales. Aunque este método es teóricamente más rápido, la reducción y ampliación de escala de un arreglo resulta en una disminución de la calidad general de la imagen (por ejemplo, líneas dentadas, sin anti-aliasing).</p>
<p><strong>Compatible con superficies de 24 y 32 bits</strong>, con o sin capa alfa. La superficie debe estar en escala de grises, pero las imágenes que no estén en escala de grises también funcionarán; sin embargo, solo se utilizará el canal rojo para la detección de bordes Sobel.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sobel_fast</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 o 32 bits) con o sin capa alfa.</p>
<p><strong>threshold_</strong> (int, opcional, predeterminado=64) Un entero que representa el umbral para la detección de bordes. Los píxeles con valores de gradiente por encima de este umbral se consideran bordes.</p>
<p><strong>factor_</strong> (unsigned short int, opcional, predeterminado=1) Un entero que controla el factor de reducción de escala de la imagen. Un valor de 1 significa que no se reduce la escala, y valores más grandes reducen el tamaño de la imagen antes del procesamiento.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno Esta función modifica la superficie de entrada directamente (in situ).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert" title="Link to this definition">¶</a></dt>
<dd><p>Invertir píxeles (in situ)</p>
<p>Invertir una imagen significa invertir los valores de los píxeles. Las imágenes se representan utilizando valores RGB o Rojo-Verde-Azul, donde cada canal puede tomar un valor entero entre 0 y 255 (ambos incluidos). Por ejemplo, el rojo se representa como (255, 0, 0), el blanco como (255, 255, 255), el negro como (0, 0, 0), y así sucesivamente. Invertir una imagen significa invertir los colores. Por ejemplo, el color invertido para el rojo será (0, 255, 255), donde 255 se convierte en 0 y 0 se convierte en 255. Efectivamente, invertir una imagen es equivalente a restar los valores RGB originales de 255.</p>
<p><strong>Compatible con superficies de 24 y 32 bits</strong>, con o sin canal alfa.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">invert</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 o 32 bits) con o sin canal alfa.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno Esta función modifica la superficie de entrada directamente (in situ).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert_copy" title="Link to this definition">¶</a></dt>
<dd><p>Invertir píxeles y devolver una copia</p>
<p>Invertir una imagen significa invertir los valores de los píxeles. Las imágenes se representan utilizando valores RGB o Rojo-Verde-Azul, donde cada canal puede tomar un valor entero entre 0 y 255 (ambos incluidos). Por ejemplo, el rojo se representa como (255, 0, 0), el blanco como (255, 255, 255), el negro como (0, 0, 0), y así sucesivamente. Invertir una imagen significa invertir los colores. Por ejemplo, el color invertido para el rojo será (0, 255, 255), donde 255 se convierte en 0 y 0 se convierte en 255. Efectivamente, invertir una imagen es equivalente a restar los valores RGB originales de 255.</p>
<p><strong>Compatible con superficies de 24 y 32 bits</strong>, con o sin canal alfa.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">inv</span> <span class="o">=</span> <span class="n">invert_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie compatible con Pygame (24 o 32 bits) con o sin canal alfa.</p>
<p><strong>Devuelve:</strong></p>
<p>(pygame.Surface) Una nueva superficie con píxeles invertidos, dejando la superficie original sin cambios.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert3d" title="Link to this definition">¶</a></dt>
<dd><p>Invertir píxeles de un arreglo 3D (in situ)</p>
<p>Invertir una imagen significa invertir los valores de los píxeles. Las imágenes se representan utilizando valores RGB o Rojo-Verde-Azul, donde cada canal puede tomar un valor entero entre 0 y 255 (ambos incluidos). Por ejemplo, el rojo se representa como (255, 0, 0), el blanco como (255, 255, 255), el negro como (0, 0, 0), y así sucesivamente. Invertir una imagen significa invertir los colores. Por ejemplo, el color invertido para el rojo será (0, 255, 255), donde 255 se convierte en 0 y 0 se convierte en 255. Efectivamente, invertir una imagen es equivalente a restar los valores RGB originales de 255.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D con forma (w, h, n), donde <cite>w</cite> y <cite>h</cite> representan el ancho y la altura de la imagen, y <cite>n</cite> es el número de canales (por ejemplo, 3 para RGB, 4 para RGBA). El arreglo contiene datos de píxeles en formato RGB(A) o formatos similares, como BGR, BGRA.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica el arreglo de entrada in situ.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d" title="Link to this definition">¶</a></dt>
<dd><p>Invertir directamente los valores de píxeles de un búfer C</p>
<p>Invertir una imagen significa invertir los valores de los píxeles. Las imágenes se representan utilizando valores RGB o Rojo-Verde-Azul, donde cada canal puede tomar un valor entero entre 0 y 255 (ambos incluidos). Por ejemplo, el rojo se representa como (255, 0, 0), el blanco como (255, 255, 255), el negro como (0, 0, 0), y así sucesivamente. Invertir una imagen significa invertir los colores. Por ejemplo, el color invertido para el rojo será (0, 255, 255), donde 255 se convierte en 0 y 0 se convierte en 255. Efectivamente, invertir una imagen es equivalente a restar los valores RGB originales de 255.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">invert1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 1D (búfer C) con tipo de datos uint8 que contiene datos de píxeles en formato RGB(A). El método funciona con otros formatos como BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo está en formato RGBA (32 bits). Si es <cite>False</cite>, se asume que el arreglo está en formato RGB (24 bits).</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica el arreglo de entrada in situ.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.invert1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">invert1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.invert1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Invertir directamente los valores de píxeles de un búfer C (devolver una copia)</p>
<p>Invertir una imagen significa invertir los valores de los píxeles. Las imágenes se representan utilizando valores RGB o Rojo-Verde-Azul, donde cada canal puede tomar un valor entero entre 0 y 255 (ambos incluidos). Por ejemplo, el rojo se representa como (255, 0, 0), el blanco como (255, 255, 255), el negro como (0, 0, 0), y así sucesivamente. Invertir una imagen significa invertir los colores. Por ejemplo, el color invertido para el rojo será (0, 255, 255), donde 255 se convierte en 0 y 0 se convierte en 255. Efectivamente, invertir una imagen es equivalente a restar los valores RGB originales de 255.</p>
<p>Esta función devuelve una copia del arreglo de entrada con los valores de píxeles invertidos.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># 32-bit image (with alpha channel)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr3d</span> <span class="o">=</span> <span class="n">invert1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr3d</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 1D (búfer C) con tipo de datos uint8 que contiene datos de píxeles en formato RGB(A). El método funciona con otros formatos como BGR, BGRA, etc.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo está en formato RGBA (32 bits). Si es <cite>False</cite>, se asume que el arreglo está en formato RGB (24 bits).</p>
<p><strong>Devuelve:</strong></p>
<p>numpy.ndarray Un arreglo 1D con tipo de datos uint8, que representa una copia del búfer de entrada con los valores de píxeles invertidos.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl_effect" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar rotación de tono a una imagen (espacio de color HSL)</p>
<p>Esta función modifica directamente el tono de una superficie de Pygame utilizando el modelo de color HSL (Tono, Saturación, Luminosidad). La rotación de tono desplaza los colores de la superficie de una manera que corresponde a una rotación en la rueda de colores, permitiéndole alterar el tono general del color.</p>
<p>La superficie debe ser compatible con profundidad de color de 24 o 32 bits, con o sin capa alfa. Si el valor de <cite>shift</cite> es 0.0, la superficie permanece sin cambios.</p>
<p>El valor de desplazamiento de tono debe estar dentro del rango [0.0, 1.0], donde 0.0 representa ninguna rotación y 1.0 representa una rotación de 360 grados.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hsl_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift to the surface.</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de color de 24 o 32 bits (con o sin alfa).</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0], donde 0.0 corresponde a ningún desplazamiento de tono y 1.0 corresponde a una rotación completa de 360 grados del tono.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica la entrada <cite>surface_</cite> in situ, aplicando el efecto de desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl3d" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar rotación de tono a un arreglo 3D (espacio de color HSL)</p>
<p>Esta función aplica la rotación de tono a un arreglo 3D de numpy que representa una imagen en el espacio de color HSL (Tono, Saturación, Luminosidad). El desplazamiento de tono se aplica directamente al arreglo, modificando el tono de color de la imagen.</p>
<p>El arreglo debe tener la forma (w, h, n), donde <cite>w</cite> es el ancho, <cite>h</cite> es la altura y <cite>n</cite> es el número de canales de color (3 para RGB o 4 para RGBA, etc.). El tipo de datos debe ser uint8.</p>
<p>El valor de <cite>shift</cite> debe estar dentro del rango [0.0, 1.0], donde 0.0 representa ninguna rotación de tono y 1.0 representa una rotación completa de 360 grados del tono.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsl3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Apply a 72-degree hue shift</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D de numpy con forma (w, h, n) que contiene datos de píxeles RGB o RGBA. El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0], que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a un desplazamiento de tono completo de 360 grados.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica el arreglo de entrada <cite>rgb_array</cite> in situ, aplicando el desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar rotación de tono a un búfer C (espacio de color HSL)</p>
<p>Esta función realiza la rotación de tono en un búfer C (arreglo 1D) que contiene datos de píxeles en formato RGB(A) utilizando el modelo de color HSL (Tono, Saturación, Luminosidad). Modifica el arreglo in situ.</p>
<p>La función admite formatos de píxeles como RGB, BGR, RGBA y BGRA, ajustando el tono de cada píxel según el <cite>shift</cite> especificado. El valor de <cite>shift</cite> debe estar en el rango [0.0, 1.0], que corresponde a una rotación de 0.0 a 360.0 grados en la rueda de colores de tono.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsl1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un arreglo 1D de numpy (búfer C) de tipo uint8 que contiene datos de píxeles en formato RGB(A). El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0] que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato RGBA de 32 bits. Si es <cite>False</cite>, se asume que el arreglo está en formato RGB de 24 bits.</p>
<p><strong>Devuelve:</strong></p>
<p>Ninguno La función modifica el arreglo de entrada <cite>bgr_array</cite> in situ aplicando el desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsl1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsl1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsl1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Rotar el tono (HSL) directamente en un búfer C (devolver una copia)</p>
<p>Esta función realiza una rotación de tono en el espacio de color HSL (Tono, Saturación, Luminosidad) en un búfer C (arreglo 1D) que contiene datos de píxeles en formato RGB(A), devolviendo una copia modificada del arreglo.</p>
<p>El método funciona con formatos de píxeles como RGB, BGR, RGBA y BGRA. El valor de desplazamiento de tono (<cite>shift</cite>) debe estar en el rango [0.0, 1.0], correspondiendo a una rotación de 0.0 a 360.0 grados.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit RGB image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGR&quot;</span><span class="p">)</span>

<span class="c1"># For 32-bit RGBA image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsl1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un arreglo 1D de numpy (búfer C) de tipo uint8 que contiene datos de píxeles en formato RGB(A). El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0], que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato RGBA de 32 bits. Si es <cite>False</cite>, se asume que el arreglo está en formato RGB de 24 bits.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un arreglo 1D de numpy de tipo uint8 que contiene los datos de píxeles con el tono rotado.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv_effect">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv_effect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv_effect" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar rotación de tono a una superficie (espacio de color HSV)</p>
<p>Esta función aplica una rotación de tono a una superficie de Pygame utilizando el modelo de color HSV (Tono, Saturación, Valor). Modifica la superficie in situ, rotando el tono de los colores en la superficie según el desplazamiento especificado.</p>
<p>La superficie debe ser compatible con formatos de color de 24 o 32 bits, con o sin canal alfa. El desplazamiento de tono se especifica como un valor flotante en el rango [0.0, 1.0], donde 0.0 corresponde a ningún cambio de tono y 1.0 representa una rotación completa de 360 grados del tono.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv_effect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees (0.2 * 360)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de color de 24 o 32 bits (con o sin alfa).</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0], que especifica la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada in situ aplicando el desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv3d" title="Link to this definition">¶</a></dt>
<dd><p>Rotar el tono de un arreglo 3D</p>
<p>Rotar el tono (método de conversión HSV), directamente desde un arreglo 3D</p>
<p>Compatible con 24 - 32 bits con o sin capa alfa</p>
<p>HSV (Tono, Saturación, Valor) es un modelo de color similar a HSL (Tono, Saturación, Luminosidad) pero con algunas diferencias en cómo representa y manipula los colores. A menudo se utiliza en software de gráficos y aplicaciones de visión por computadora por su simplicidad para especificar y ajustar atributos de color.</p>
<p>Nuevo valor de desplazamiento. Debe estar entre [0.0 … 1.0], correspondiendo a 0.0 - 360.0 grados (por ejemplo, 0.5 = 180 grados)</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array3d</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">hsv3d</span><span class="p">(</span><span class="n">array3d</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>  <span class="c1"># Rotate the hue by 72 degrees</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D de numpy con forma (w, h, n) que contiene datos de píxeles RGB o RGBA. El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0] que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica el arreglo de entrada <cite>rgb_array</cite> in situ aplicando el desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d" title="Link to this definition">¶</a></dt>
<dd><p>Rotar el tono de un arreglo 1D</p>
<p>Rotar el tono directamente desde un búfer C (arreglo 1D de tipo de datos uint8 en formato RGB(A)). Los cambios se aplican in situ</p>
<p>Este método funciona con otros formatos de búfer como BGR, BGRA.</p>
<p>HSV (Tono, Saturación, Valor) es un modelo de color similar a HSL (Tono, Saturación, Luminosidad) pero con algunas diferencias en cómo representa y manipula los colores. A menudo se utiliza en software de gráficos y aplicaciones de visión por computadora por su simplicidad para especificar y ajustar atributos de color.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compatible with 32-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Compatible with 24-bit images</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">hsv1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">36.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un arreglo 1D de numpy (búfer C) de tipo uint8 que contiene datos de píxeles en formato BGR(A). El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0] que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato BGRA de 32 bits. Si es <cite>False</cite>, se asume que el arreglo está en formato BGR de 24 bits.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica el arreglo de entrada <cite>bgr_array</cite> in situ aplicando el desplazamiento de tono.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.hsv1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">hsv1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.hsv1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Rotar el tono de un arreglo 1D (devolver una copia)</p>
<p>Arreglo 1D HSV (búfer C) de tipo de datos uint8 en formato RGB(A)</p>
<p>Este método funciona con otros formatos de búfer como BGR, BGRA.</p>
<p>HSV (Tono, Saturación, Valor) es un modelo de color similar a HSL (Tono, Saturación, Luminosidad) pero con algunas diferencias en cómo representa y manipula los colores. A menudo se utiliza en software de gráficos y aplicaciones de visión por computadora por su simplicidad para especificar y ajustar atributos de color.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">),</span> <span class="s2">&quot;BGRA&quot;</span><span class="p">)</span>

<span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">hsv1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">angle</span> <span class="o">/</span> <span class="mf">360.0</span><span class="p">,</span> <span class="n">format_32</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray) Un arreglo 1D de numpy (búfer C) de tipo uint8 que contiene datos de píxeles en formato RGB(A). El arreglo también puede representar otros formatos como BGR, BGRA.</p>
<p><strong>shift</strong> (float) Un valor flotante en el rango [0.0, 1.0] que representa la rotación de tono. Un valor de 0.0 significa ninguna rotación, mientras que 1.0 corresponde a una rotación completa de 360 grados.</p>
<p><strong>format_32</strong> (bool, opcional, predeterminado=False) Si es <cite>True</cite>, se asume que el arreglo de entrada está en formato BGRA de 32 bits. Si es <cite>False</cite>, se asume que el arreglo está en formato BGR de 24 bits.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo arreglo 1D de numpy de tipo uint8 que contiene los píxeles con el tono rotado.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar efecto de onda a una superficie (In situ)</p>
<p>Esta función aplica un efecto de onda a una superficie de Pygame, modificándola in situ. El efecto se aplica a la superficie basándose en un ángulo (en radianes) y el número de sub-superficies. Es compatible con superficies de 24 bits.</p>
<p>El efecto de onda crea una distorsión dinámica similar a una onda, a menudo utilizada para efectos visuales de agua u otros fluidos en juegos.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">+</span> <span class="n">frame_number</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Animate with a changing angle</span>
<span class="n">wave</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave with a fixed angle</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con profundidad de color de 24 bits.</p>
<p><strong>rad</strong> (float) El ángulo en radianes para el efecto de onda. Este valor controla el movimiento de la onda a lo largo del tiempo.</p>
<p><strong>size</strong> (int, opcional, predeterminado=5) El número de sub-superficies utilizadas para crear el efecto de onda. Un número más alto resulta en una onda más compleja.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada in situ, aplicando el efecto de onda.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave32" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar efecto de onda a una superficie de 32 bits (In situ)</p>
<p>Esta función aplica un efecto de onda a una superficie de Pygame de 32 bits, modificándola in situ. El efecto se aplica tanto a los canales RGB como al canal alfa, lo que significa que la onda también desplazará la capa alfa (transparencia) de la superficie. Es totalmente compatible con superficies SDL de 32 bits, incluidas aquellas con un canal alfa.</p>
<p>El efecto de onda crea una distorsión dinámica que simula el movimiento de las olas, a menudo utilizado para efectos como el agua o el movimiento de fluidos en juegos.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">wave32</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># Apply wave effect with a rotating angle</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con profundidad de color de 32 bits y canal alfa (RGBA).</p>
<p><strong>rad</strong> (float) El ángulo en radianes para el efecto de onda, controlando su rotación a lo largo del tiempo.</p>
<p><strong>size</strong> (int, opcional, predeterminado=5) El número de sub-superficies utilizadas para crear el efecto de onda. Un valor más alto resulta en una onda más detallada.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada in situ, aplicando el efecto de onda tanto a los canales de color como al canal alfa.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wave_static">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wave_static</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wave_static" title="Link to this definition">¶</a></dt>
<dd><p>Efecto de onda para fondo estático (in situ)</p>
<p>Esta función es diferente del método <cite>wave</cite>, ya que se pasa una copia del fondo estático o la pantalla del juego a la función como argumento <cite>array_</cite> para mejorar el rendimiento general.</p>
<p>Compatible con superficies de 24 bits.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">wave_static</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background_cp</span><span class="p">),</span> <span class="n">FRAME</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con profundidad de color de 24 bits.</p>
<p><strong>array_</strong> (numpy.ndarray) Un arreglo 3D de numpy con forma (w, h, 3), tipo <cite>uint8</cite>, que representa una copia de la pantalla del juego o la imagen que se va a modificar.</p>
<p><strong>rad</strong> (float) El ángulo en radianes para el efecto de onda, controlando su rotación a lo largo del tiempo.</p>
<p><strong>size</strong> (int, opcional, predeterminado=5) El número de sub-superficies utilizadas para crear el efecto de onda. Un valor más alto resulta en una onda más detallada.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica el arreglo de entrada <cite>array_</cite> in situ, aplicando el efecto de onda.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array_cp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl" title="Link to this definition">¶</a></dt>
<dd><p>Remolinar una imagen (in situ)</p>
<p>El efecto de remolino es una distorsión visual que crea una apariencia de espiral en una imagen o gráfico. Este efecto puede llamar la atención sobre áreas específicas de un diseño y agregar una sensación de movimiento o dinamismo. Se puede utilizar de manera creativa en varios contextos, desde gráficos para redes sociales hasta publicidad y arte digital.</p>
<p><strong>Funciona con:</strong> formatos de imagen de 24 y 32 bits, pero no es compatible con 32 bits debido a la capa alfa.</p>
<p>Si la imagen está en 32 bits con un canal alfa, la capa alfa permanecerá inalterada durante la transformación, lo que hará que la capa alfa se mezcle con el efecto. Para evitar esto, convierta la imagen a 24 bits. Para imágenes de 32 bits con una capa alfa, utilice el método <cite>swirl32</cite> (diseñado para 32 bits).</p>
<p>Este algoritmo utiliza una tabla de cosenos y senos para lograr el efecto.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/background.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">background_cp</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># in the game loop</span>
<span class="n">swirl</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="n">pixels3d</span><span class="p">(</span><span class="n">background</span><span class="p">),</span> <span class="n">angle</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background_cp</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de 24 y 32 bits. Sin embargo, no es compatible con 32 bits debido al canal alfa.</p>
<p><strong>rgb_array_cp</strong> (numpy.ndarray) Un arreglo 3D de numpy con forma (w, h, 3), que contiene datos de píxeles RGB. Una copia de la imagen a remolinar. Tanto <cite>surface_</cite> como <cite>rgb_array_cp</cite> deben tener la misma forma y tipo.</p>
<p><strong>degrees</strong> (float) El ángulo en grados para el efecto de remolino.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada <cite>surface_</cite> in situ aplicando el efecto de remolino.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirl32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirl32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirl32" title="Link to this definition">¶</a></dt>
<dd><p>Remolinar una imagen (in situ)</p>
<p><strong>Compatible con:</strong> formatos de 24 y 32 bits (con o sin capa alfa).</p>
<p>El efecto de remolino es una distorsión visual que crea una apariencia de espiral en una imagen o gráfico. Este efecto puede llamar la atención sobre áreas específicas de un diseño y agregar una sensación de movimiento o dinamismo. Se puede utilizar de manera creativa en varios contextos, desde gráficos para redes sociales hasta publicidad y arte digital.</p>
<p>Este algoritmo utiliza una tabla de cosenos y senos para la aproximación de ángulos.</p>
<p>A diferencia del método <cite>swirl</cite>, <cite>swirl32</cite> tiene en cuenta la capa alfa durante la transformación, lo que significa que funciona con imágenes de 32 bits que tienen transparencia por píxel, preservando el canal alfa.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirl32</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de 24 y 32 bits, incluyendo canales alfa.</p>
<p><strong>degrees</strong> (float) El ángulo en grados para el efecto de remolino.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada <cite>surface_</cite> in situ aplicando el efecto de remolino.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.swirlf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">swirlf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.swirlf" title="Link to this definition">¶</a></dt>
<dd><p>Remolinar una imagen (in situ) con precisión de punto flotante</p>
<p><strong>Compatible con:</strong> solo formato de 24 bits.</p>
<p>Este algoritmo no utiliza tablas de cosenos y senos; en su lugar, calcula los ángulos con precisión de punto flotante.</p>
<p>El efecto de remolino es una distorsión visual que crea una apariencia de espiral en una imagen o gráfico. Este efecto puede llamar la atención sobre áreas específicas de un diseño y agregar una sensación de movimiento o dinamismo. Se puede utilizar de manera creativa en varios contextos, desde gráficos para redes sociales hasta publicidad y arte digital.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">swirlf</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de 24 bits.</p>
<p><strong>degrees</strong> (float) El ángulo en grados para el efecto de remolino.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada <cite>surface_</cite> in situ aplicando el efecto de remolino.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma_config">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hue_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">6.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">255.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span> <span class="pre">/</span> <span class="pre">12.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma_config" title="Link to this definition">¶</a></dt>
<dd><p>Crear un efecto de plasma básico en la parte superior de una superficie de Pygame (in situ)</p>
<p><strong>Compatible con:</strong> superficies de 24 - 32 bits, con o sin capa alfa.</p>
<p>Esta función crea un efecto de plasma que se puede aplicar a una superficie de Pygame. Modifica la superficie in situ. El efecto simula distorsiones visuales similares al plasma utilizando factores matemáticos como tono, saturación y valor.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma_config</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de 24 o 32 bits.</p>
<p><strong>frame</strong> (int) Una variable que cambia con el tiempo, controlando la progresión del efecto de plasma.</p>
<p><strong>hue_</strong> (float, opcional) Un factor que controla el tono, el valor predeterminado es 1.0/6.0.</p>
<p><strong>sat_</strong> (float, opcional) Un factor que controla la saturación, el valor predeterminado es 1.0/6.0.</p>
<p><strong>value_</strong> (float, opcional) Un factor que controla el valor, el valor predeterminado es 1.0/8.0.</p>
<p><strong>a_</strong> (float, opcional) Un parámetro de control para la ecuación de plasma, el valor predeterminado es 1.0/255.0.</p>
<p><strong>b_</strong> (float, opcional) Un parámetro de control para la ecuación de plasma, el valor predeterminado es 1.0/12.0.</p>
<p><strong>c_</strong> (float, opcional) Un parámetro de control para la ecuación de plasma, el valor predeterminado es 1.0/12.0.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada <cite>surface_</cite> in situ aplicando el efecto de plasma.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.plasma">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">plasma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">palette_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.plasma" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar efecto de plasma in situ a una superficie</p>
<p>Esta función genera un efecto de plasma dinámico en una superficie de Pygame. El efecto evoluciona con el tiempo, produciendo un patrón visual fluido y brillante. El efecto de plasma se aplica directamente a la superficie, modificando sus píxeles in situ.</p>
<p>La función funciona con superficies de 24 y 32 bits (con o sin canal alfa).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plasma</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">frame_number</span><span class="p">,</span> <span class="n">palette</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame, compatible con formatos de 24 o 32 bits. El efecto de plasma se aplica directamente a esta superficie, modificando sus píxeles in situ.</p>
<p><strong>frame</strong> (float) El número de fotograma actual, que impulsa la evolución del efecto de plasma. Este valor determina los patrones cambiantes y la animación en el efecto de plasma.</p>
<p><strong>palette_</strong> (numpy.ndarray) Un arreglo 1D que contiene una paleta de colores (como enteros sin signo) utilizados para generar el efecto de plasma. Los colores se aplican cíclicamente para crear el efecto visual.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la superficie de entrada <cite>surface_</cite> in situ aplicando el efecto de plasma.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness" title="Link to this definition">¶</a></dt>
<dd><p>Ajustar el brillo in situ</p>
<p>Esta función controla el nivel de brillo de una pantalla de Pygame o una superficie SDL. El parámetro <cite>shift_</cite> es un valor flotante en el rango [-1.0, 1.0], donde +1.0 representa el brillo máximo y 0.0 no aplica cambios a la superficie. Los valores negativos oscurecen la superficie.</p>
<p>La función funciona con superficies de 24 y 32 bits (con o sin canal alfa).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame compatible con formatos de 24 o 32 bits (con o sin canal alfa).</p>
<p><strong>shift_</strong> (flotante) Un valor flotante en el rango [-1.0, 1.0], donde +1.0 aumenta el brillo, 0.0 mantiene la superficie sin cambios y los valores negativos disminuyen el brillo.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la entrada <cite>surface_</cite> en su lugar ajustando su brillo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness3d" title="Link to this definition">¶</a></dt>
<dd><p>Ajustar el brillo de un arreglo de imágenes 3D en su lugar</p>
<p>Esta función ajusta el brillo de una imagen modificando su arreglo 3D en su lugar. El arreglo debe tener la forma (w, h, n), donde <cite>n</cite> es típicamente 3 (RGB) o 4 (RGBA). El parámetro <cite>shift</cite> controla el nivel de brillo y debe ser un flotante en el rango [-1.0, 1.0]. Los valores positivos aumentan el brillo, los valores negativos lo disminuyen y 0.0 no causa cambios.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">brightness3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un arreglo 3D de numpy con la forma (w, h, n), donde <cite>n</cite> es el número de canales de color (3 para RGB o 4 para RGBA). El arreglo debe contener datos uint8 (valores entre 0–255 para cada canal de color).</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, 1.0] que controla el nivel de brillo. Los valores positivos aumentan el brillo, los valores negativos lo disminuyen y 0.0 deja el arreglo sin cambios.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la entrada <cite>rgb_array</cite> en su lugar ajustando su brillo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d" title="Link to this definition">¶</a></dt>
<dd><p>Controlar el brillo de una imagen desde un búfer C (en su lugar)</p>
<p>Esta función ajusta el brillo de una imagen basándose en un búfer de arreglo 1D. El búfer debe representar los datos de píxeles de la imagen en formato BGR(A) o RGB(A). El brillo se ajusta mediante un valor <cite>shift</cite>, que debe ser un flotante en el rango [-1.0, 1.0]. El parámetro <cite>format_32</cite> indica si el búfer es de 32 bits (<cite>True</cite> para BGRA) o de 24 bits (<cite>False</cite> para BGR).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D de numpy o un bytearray que contiene datos de píxeles en formato BGR(A) o RGB(A). El arreglo debe contener datos uint8 (valores entre 0–255 para cada canal de color).</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, 1.0] que controla el nivel de brillo. Los valores positivos aumentan el brillo, los valores negativos lo disminuyen y 0.0 deja el arreglo sin cambios.</p>
<p><strong>format_32</strong> (bool) Un valor booleano que indica si el búfer es de 32 bits (<cite>True</cite> para BGRA) o de 24 bits (<cite>False</cite> para BGR).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la entrada <cite>bgr_array</cite> en su lugar ajustando su brillo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness1d_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness1d_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness1d_copy" title="Link to this definition">¶</a></dt>
<dd><p>Controlar el brillo de una imagen (devuelve una copia)</p>
<p>Esta función ajusta el brillo de una imagen dada su C-buffer. El <cite>bgr_array</cite> debe ser un arreglo 1D que contenga datos de píxeles en formato BGR o BGRA. La función devuelve un nuevo arreglo con el brillo ajustado basado en el valor <cite>shift</cite>, que debe ser un flotante en el rango [-1.0, 1.0]. El parámetro <cite>format_32</cite> especifica si la imagen es de 32 bits (BGRA) o de 24 bits (BGR).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit image (BGR format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGR&#39;</span><span class="p">)</span>

<span class="c1"># For 32-bit image (BGRA format)</span>
<span class="n">array_bck</span> <span class="o">=</span> <span class="n">brightness1d_copy</span><span class="p">(</span><span class="n">background</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">array_bck</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="s1">&#39;BGRA&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>bgr_array</strong> (numpy.ndarray o bytearray) Un arreglo 1D de numpy o un bytearray que contiene datos de píxeles en formato BGR(A) o RGB(A). El arreglo debe contener datos uint8 (valores entre 0–255 para cada canal de color).</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, 1.0] que controla el nivel de brillo. Los valores positivos aumentan el brillo, los valores negativos lo disminuyen y 0.0 deja el arreglo sin cambios.</p>
<p><strong>format_32</strong> (bool) Un valor booleano que indica si el búfer es de 32 bits (<cite>True</cite> para BGRA) o de 24 bits (<cite>False</cite> para BGR).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo arreglo numpy que contiene los datos de píxeles con brillo ajustado. El arreglo original no se modifica.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_copy">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_copy" title="Link to this definition">¶</a></dt>
<dd><p>Brillo (devuelve una copia)</p>
<p>Esta función aplica una transformación de brillo a una nueva superficie SDL. El nivel de brillo de la superficie se modifica según el parámetro <cite>shift</cite>, que es un flotante en el rango [-1.0, 1.0]. Un valor de +1.0 corresponde al máximo brillo, mientras que un valor de 0.0 dejará la superficie sin cambios.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">new_surface</span> <span class="o">=</span> <span class="n">brightness_copy</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits, con o sin canal alfa.</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, 1.0] que ajusta el brillo de la superficie. Los valores positivos aumentan el brillo, los valores negativos lo disminuyen y 0.0 deja la superficie sin cambios.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>pygame.Surface</strong> Una nueva superficie Pygame con brillo ajustado, en formato de 24 bits sin canal alfa.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_exclude">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_exclude</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_exclude" title="Link to this definition">¶</a></dt>
<dd><p>Ajuste de brillo con exclusión de color (en su lugar)</p>
<p>Esta función modifica el brillo de una imagen, excluyendo un color específico del proceso de transformación. El parámetro <cite>shift_</cite> controla el nivel de brillo, siendo +1.0 el brillo máximo. La exclusión de color permite evitar afectar colores específicos durante la transformación.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_exclude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits.</p>
<p><strong>shift_</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el ajuste de brillo. +1.0 corresponde al brillo máximo, y 0.0 dejará la superficie sin cambios.</p>
<p><strong>color_</strong> (tupla, opcional) Una tupla de valores RGB (por ejemplo, (10, 22, 0)) para excluir de la transformación de brillo. El valor predeterminado es (0, 0, 0) para negro.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica la <cite>surface_</cite> en su lugar, ajustando su brillo mientras excluye el color especificado.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.brightness_bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">brightness_bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.brightness_bpf" title="Link to this definition">¶</a></dt>
<dd><p>Ajuste de brillo con exclusión de bpf (en su lugar) Esta función ajusta el brillo de una imagen utilizando un filtro de paso brillante (bpf). Los píxeles con una suma RGB por debajo del <cite>bpf_threshold</cite> especificado son excluidos de la transformación. Esto ayuda a evitar modificar píxeles más oscuros mientras se ajusta el brillo de los demás.</p>
<p>El parámetro <cite>shift_</cite> controla el nivel de brillo, siendo +1.0 el brillo máximo. La función funciona con imágenes de 24 bits y 32 bits.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 24-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># 32-bit image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">brightness_bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits.</p>
<p><strong>shift_</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el ajuste de brillo. +1.0 corresponde al brillo máximo, y 0.0 dejará la superficie sin cambios.</p>
<p><strong>bpf_threshold</strong> (int, opcional) Un valor entero en el rango [0, 255] que determina el umbral para el filtro de brillo. Los píxeles con una suma RGB por debajo de este umbral no serán modificados. El valor predeterminado es 64.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica la <cite>surface_</cite> en su lugar, ajustando su brillo según los parámetros dados.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation" title="Link to this definition">¶</a></dt>
<dd><p>Ajuste de saturación (en su lugar)</p>
<p>Esta función ajusta el nivel de saturación de una superficie Pygame o texto. Un <cite>shift_</cite> positivo aumenta la saturación, mientras que un valor negativo la disminuye. El ajuste de saturación se aplica directamente a la superficie, lo que significa que la superficie original se modifica directamente.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits.</p>
<p><strong>shift_</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el nivel de saturación. Un valor de 1.0 corresponde a la saturación máxima, 0.0 dejará la superficie sin cambios, y -1.0 resultará en ausencia de saturación de color.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica la <cite>surface_</cite> en su lugar, ajustando su saturación.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation3d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation3d" title="Link to this definition">¶</a></dt>
<dd><p>Saturar array 3D directamente (en su lugar)</p>
<p>Esta función ajusta el nivel de saturación de una imagen modificando los datos de su array 3D. El array debe estar en formato <cite>uint8</cite> con una forma de <cite>(w, h, 3)</cite> y debe contener datos de píxeles RGB. Otros formatos de píxeles también pueden ser compatibles. La imagen resultante estará en formato de 24 bits sin capa alfa.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">saturation3d</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>rgb_array</strong> (numpy.ndarray) Un array 3D de numpy (o vista de memoria) con forma <cite>(w, h, 3)</cite> y tipo <cite>uint8</cite>, que contiene datos RGB o de otro formato de píxel. Debe hacer referencia a una superficie SDL o a datos de imagen.</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el nivel de saturación. Un valor de 1.0 corresponde a la saturación máxima, 0.0 deja la imagen sin cambios, y -1.0 disminuye la saturación.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica el <cite>rgb_array</cite> en su lugar, ajustando la saturación de los datos de imagen referenciados.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d" title="Link to this definition">¶</a></dt>
<dd><p>Saturar array 1D directamente (en su lugar)</p>
<p>Esta función ajusta el nivel de saturación de una imagen modificando su búfer de datos 1D. El búfer debe estar en formato <cite>uint8</cite> con una forma de <cite>(w,)</cite>, y puede contener formatos de píxeles RGB(A), BGR(A) o otros. Para imágenes de 32 bits, el canal alfa debe estar al final del píxel (por ejemplo, RGB(A) o BGR(A)).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">saturation1d</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.3</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>buffer</strong> (numpy.ndarray o memoryviewslice) Un array 1D (o vista de memoria) con forma <cite>(w,)</cite> y tipo <cite>uint8</cite>, que contiene datos de píxeles en formatos RGB(A), BGR(A) u otros. Este debe hacer referencia a una superficie SDL o a un búfer de imagen.</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el nivel de saturación. Un valor de 1.0 corresponde a la saturación máxima, 0.0 deja la imagen sin cambios, y -1.0 disminuye la saturación.</p>
<p><strong>format_32</strong> (bool, opcional) Un indicador del formato de píxel: - <cite>True</cite> para “RGBA” (formato de 32 bits con canal alfa). - <cite>False</cite> para “RGB” (formato de 24 bits sin alfa).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica el <cite>buffer</cite> en su lugar, ajustando la saturación de los datos de imagen referenciados. La imagen final conserva el mismo formato de píxel que la imagen de entrada.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.saturation1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">saturation1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.saturation1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Saturar una imagen usando un C-buffer (devolver copia)</p>
<p>Esta función ajusta el nivel de saturación de una imagen modificando su búfer de datos 1D y devuelve un nuevo array con la saturación ajustada. El <cite>buffer</cite> debe estar en formato <cite>uint8</cite> con una forma de <cite>(w,)</cite>, y puede contener formatos de píxeles RGB(A), BGR(A) u otros. Para imágenes de 32 bits, el canal alfa debe colocarse al final del formato de píxel (por ejemplo, RGB(A) o BGR(A)).</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit image (RGBA format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit image (RGB format)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">new_buffer</span> <span class="o">=</span> <span class="n">saturation1d_cp</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>buffer</strong> (numpy.ndarray o memoryviewslice) Un array 1D (o vista de memoria) con forma <cite>(w,)</cite> y tipo <cite>uint8</cite>, que contiene datos de píxeles en formatos RGB(A), BGR(A) u otros. Este debe hacer referencia a una superficie SDL o a un búfer de imagen.</p>
<p><strong>shift</strong> (flotante) Un valor flotante en el rango [-1.0, +1.0] que controla el nivel de saturación. Un valor de 1.0 corresponde a la saturación máxima, 0.0 deja la imagen sin cambios, y -1.0 disminuye la saturación.</p>
<p><strong>format_32</strong> (bool, opcional) Un indicador del formato de píxel: - <cite>True</cite> para “RGBA” (formato de 32 bits con canal alfa). - <cite>False</cite> para “RGB” (formato de 24 bits sin alfa).</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un nuevo array 1D con forma <cite>(w,)</cite> y tipo <cite>uint8</cite>, que contiene el mismo formato de píxel que el array de entrada, pero con el nivel de saturación ajustado.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatconvection">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatconvection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatconvection" title="Link to this definition">¶</a></dt>
<dd><p>Convección de flujo de calor</p>
<p>Esta función simula la convección de flujo de calor (o transferencia de calor por convección) aplicando una transformación gaussiana a una imagen, creando un efecto de flujo vertical. La transformación se ve influenciada por los parámetros, como amplitud, centro, sigma y mu, que modifican la intensidad y la dirección del efecto.</p>
<p>El efecto de convección se puede utilizar para simular fenómenos como turbulencia en el aire o flujo de calor. Una variable periódica para <cite>amplitude</cite> (por ejemplo, usando una función coseno) puede crear efectos dinámicos y cambiantes.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-24 bit image format</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/fire.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">3.14</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">heatconvection</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">mu</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># Restore the original image</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits. La transformación se aplica directamente a esta superficie.</p>
<p><strong>amplitude</strong> (flotante) La amplitud máxima (desplazamiento vertical de píxeles) de la transformación gaussiana. Si la amplitud es cero, no se aplicará ninguna transformación. Se puede utilizar una función periódica para crear una amplitud dinámica.</p>
<p><strong>center</strong> (flotante, opcional) El centro de la transformación gaussiana. El valor predeterminado es 0.0, lo que centra el efecto.</p>
<p><strong>sigma</strong> (flotante, opcional) El valor sigma de la ecuación gaussiana. Un valor pequeño crea un efecto estrecho, mientras que un valor grande amplía el efecto. El valor predeterminado es 2.0.</p>
<p><strong>mu</strong> (flotante, opcional) El valor mu de la ecuación gaussiana. Cuando mu es periódico (por ejemplo, usando una función coseno), permite que el efecto se mueva horizontalmente. El valor predeterminado es 0.0.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la <cite>surface_</cite> en el lugar, aplicando el efecto de convección de calor.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_glitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_glitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_glitch" title="Link to this definition">¶</a></dt>
<dd><p>Glitch horizontal (en el lugar)</p>
<p>Esta función aplica un efecto glitch horizontal a una superficie de Pygame, deformando la imagen horizontalmente según una señal definida por los parámetros dados. El efecto se logra modificando los píxeles de la imagen de una manera glitch aleatoria, influenciada por los parámetros de deformación, frecuencia y amplitud.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_glitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits. La transformación se aplica directamente a esta superficie.</p>
<p><strong>deformación</strong> (flotante) El ángulo en radianes que controla la variación de la deformación horizontal. Este valor influye en el patrón general del glitch.</p>
<p><strong>frecuencia</strong> (flotante) Un factor que amplifica la variación del ángulo. Determina la velocidad a la que el efecto glitch cambia con el tiempo.</p>
<p><strong>amplitud</strong> (flotante) La amplitud de la función coseno utilizada para modular el efecto glitch. Una mayor amplitud conduce a una deformación más intensa.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la <cite>surface_</cite> en el lugar, aplicando el efecto glitch horizontal.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.horizontal_sglitch">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">horizontal_sglitch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deformation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.horizontal_sglitch" title="Link to this definition">¶</a></dt>
<dd><p>Glitch para fondo de imagen estática (en el lugar)</p>
<p>Esta función aplica un efecto glitch horizontal a una superficie de Pygame, modificando la imagen al deformarla según una señal definida por los parámetros de deformación, frecuencia y amplitud. Crea un efecto glitch específicamente para fondos de imágenes estáticas.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit and 32-bit</span>
<span class="n">horizontal_sglitch</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">bgr_array</span><span class="p">,</span> <span class="n">deformation</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.08</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="n">FRAME</span> <span class="o">%</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits. La transformación se aplica directamente a esta superficie.</p>
<p><strong>array_</strong> (numpy.ndarray) Un arreglo numpy que contiene una copia de píxeles utilizada para el efecto glitch. Este arreglo sirve como referencia para la transformación.</p>
<p><strong>deformación</strong> (flotante) El ángulo en radianes que controla la variación de la deformación horizontal. Este valor determina el grado del efecto glitch.</p>
<p><strong>frecuencia</strong> (flotante) Un factor que amplifica la variación del ángulo, influyendo en la velocidad a la que cambia el efecto glitch con el tiempo.</p>
<p><strong>amplitud</strong> (flotante) La amplitud de la función coseno que modula el efecto glitch. Una mayor amplitud da lugar a una deformación más intensa.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> La función modifica la <cite>surface_</cite> en el lugar, aplicando el efecto glitch horizontal usando los parámetros proporcionados.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bpf">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bpf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bpf" title="Link to this definition">¶</a></dt>
<dd><p>BPF, filtro de paso de brillo (en el lugar)</p>
<p>Esta función aplica un filtro de paso de brillo a una superficie de Pygame, conservando solo los píxeles más brillantes. Los píxeles que caen por debajo del umbral de brillo especificado se excluyen de la superficie, aclarando efectivamente la imagen.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># For 32-bit</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">bpf</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie Pygame compatible con formatos de 24 bits o 32 bits. La transformación se aplica directamente a esta superficie.</p>
<p><strong>umbral</strong> (entero) El umbral de paso de brillo, con un valor predeterminado de 128. Los píxeles con brillo por debajo de este umbral serán excluidos de la transformación.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>Ninguno</strong> Esta función modifica la <cite>surface_</cite> en el lugar aplicando el filtro de paso de brillo.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom" title="Link to this definition">¶</a></dt>
<dd><p>Crear un efecto de resplandor (en el lugar)</p>
<p>Esta función aplica un efecto de resplandor a una superficie o imagen de Pygame. El efecto de resplandor aclara la imagen y añade un efecto de brillo alrededor de las áreas brillantes. El efecto puede ser filtrado selectivamente usando una máscara, y el rendimiento se puede mejorar con la opción rápida a costa de reducir la apariencia del efecto.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the demo_bloom_mask.py script in the Demo folder</span>
<span class="n">bloom</span><span class="p">(</span><span class="n">SCREEN</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">BPF</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>surface_</strong> (pygame.Surface) Una superficie de Pygame compatible con formatos de 24 bits o 32 bits. Esta superficie será transformada en el lugar aplicando el efecto de resplandor.</p>
<p><strong>umbral_</strong> (entero) Un valor de umbral en el rango [0…255]. Este valor se usa para detectar píxeles brillantes dentro de la textura o imagen para aplicar el efecto de resplandor.</p>
<p><strong>rápido_</strong> (bool) Un valor booleano que, cuando se establece en <cite>True</cite>, aproxima el efecto de resplandor para mejorar el rendimiento (10x - 80x), pero reduce la intensidad visual del efecto. El valor predeterminado es <cite>False</cite>.</p>
<p><strong>mask_</strong> (numpy.ndarray o memoryviewslice) Un array 2D de tipo uint8 que representa la máscara alfa, con forma <cite>(w, h)</cite>. Los valores en el rango [0..255] controlan la transparencia y, por lo tanto, la aplicación selectiva del efecto bloom. Un array lleno de 255 renderiza el efecto bloom completo, mientras que un array lleno de 0 desactiva el efecto. Los valores intermedios crean efectos bloom parciales.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>None</strong> Esta función modifica el <cite>surface_</cite> in situ aplicando el efecto bloom.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint" title="Link to this definition">¶</a></dt>
<dd><p>Crear un modelo de lente ojo de pez que contiene las coordenadas de píxel de una superficie</p>
<p>Esta función genera un modelo de lente ojo de pez que contiene las coordenadas de píxel para cada píxel en una superficie dada. El modelo puede usarse para aplicar un efecto ojo de pez a una superficie mapeando sus coordenadas en una proyección de lente ojo de pez.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>w</strong> (int) El ancho de la superficie para proyectar en el modelo ojo de pez. El valor debe coincidir con el ancho de la superficie.</p>
<p><strong>h</strong> (int) La altura de la superficie para proyectar en el modelo ojo de pez. El valor debe coincidir con la altura de la superficie.</p>
<p><strong>centre_x</strong> (int) La coordenada x del centro del efecto ojo de pez.</p>
<p><strong>centre_y</strong> (int) La coordenada y del centro del efecto ojo de pez.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>numpy.ndarray</strong> Un array 2D de tipo <cite>np.uint32_t</cite> con forma <cite>(w, h, 2)</cite>, que representa el modelo ojo de pez y contiene las coordenadas de todos los píxeles proyectados a través del modelo de lente ojo de pez.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye_footprint_param">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye_footprint_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tmp_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param1_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye_footprint_param" title="Link to this definition">¶</a></dt>
<dd><p>Crear un modelo ojo de pez para contener las coordenadas de píxel con parámetros adicionales</p>
<p>Esta función genera un modelo ojo de pez que contiene las coordenadas de píxel de una superficie, con la capacidad adicional de controlar el aspecto y la distancia focal del modelo ojo de pez.</p>
<p><strong>Ejemplo de uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="mi">400</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="n">fisheye_footprint_param</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros:</strong></p>
<p><strong>tmp_array_</strong> (numpy.ndarray) Un array 3D con forma <cite>(w, h, 2)</cite> de enteros sin signo. La forma de este array determinará el modelo ojo de pez.</p>
<p><strong>centre_x</strong> (float) La coordenada x del centro del efecto ojo de pez. Corresponde a la mitad de la longitud del modelo ojo de pez.</p>
<p><strong>centre_y</strong> (float) La coordenada y del centro del efecto ojo de pez. Corresponde a la mitad del ancho del modelo ojo de pez.</p>
<p><strong>param1_</strong> (float) Un parámetro que controla el aspecto del modelo ojo de pez. Valores mayores que 1.0 hacen que el efecto converja hacia el centro, mientras que valores menores que 1.0 hacen que el efecto diverja desde el centro.</p>
<p><strong>focal_length</strong> (float) Controla el tipo de lente ojo de pez. Valores mayores que 1.0 crean un efecto de lente divergente, mientras que valores menores que 0 crean un efecto de lente convergente.</p>
<p><strong>Devuelve:</strong></p>
<p><strong>void</strong> Esta función realiza una transformación in situ en el <cite>tmp_array_</cite> proporcionado, actualizándolo con las coordenadas del modelo ojo de pez.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.fisheye">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">fisheye</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fisheye_model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.fisheye" title="Link to this definition">¶</a></dt>
<dd><p>Mostrar la superficie o el juego a través de un efecto de lente (in situ).</p>
<p>Compatible solo con superficies de 24 bits.</p>
<p>Una lente ojo de pez es una lente ultra gran angular que produce una fuerte distorsión visual destinada a crear una imagen panorámica o hemisférica amplia.</p>
<p>Esta función aplica un efecto de lente ojo de pez en tiempo real. Para lograr esto, el algoritmo utiliza una transformación de modelo de lente precalculada que se almacena en un ndarray de numpy, pasado como el argumento <cite>fisheye_model</cite>. El array <cite>fisheye_model</cite> tiene una forma de (w, h, 2) y contiene las coordenadas de píxel de la superficie después de la transformación de la lente. Todos los cálculos se realizan aguas arriba.</p>
<p>Usa la función <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code> para crear el array precalculado. Este método solo necesita ser llamado una vez.</p>
<p>La transformación de la lente ojo de pez se aplica in situ.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
<span class="n">f_model</span> <span class="o">=</span> <span class="n">fisheye_footprint</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">centre_x</span><span class="o">=</span><span class="n">width</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">centre_y</span><span class="o">=</span><span class="n">height</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fisheye</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">f_model</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto de superficie compatible con una profundidad de color de 24 bits. - <cite>fisheye_model</cite> (numpy.ndarray): Un array de numpy con forma (w, h, 2) que contiene valores uint32 que representan las coordenadas de píxel transformadas (<cite>x”</cite>, <cite>y”</cite>). Estos valores se calculan previamente utilizando la función <code class="xref py py-func docutils literal notranslate"><span class="pre">fisheye_footprint_c()</span></code>.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La transformación se aplica in situ y no se devuelve ningún valor.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tv_scan">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tv_scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tv_scan" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de líneas de escaneo de TV en una superficie de pygame (in situ).</p>
<p>El espacio entre cada línea de escaneo se puede ajustar con el valor <cite>space</cite>.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tv_scan</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto de superficie compatible con formatos de color de 24 o 32 bits. - <cite>space</cite> (int, opcional): El espacio entre cada línea de escaneo. Puedes establecer un valor constante o usar una variable para un efecto dinámico. El valor predeterminado es 5.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: El efecto se aplica in situ y no se devuelve ningún valor.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de ondulación sin deformación del fondo.</p>
<p>Esta función simula un efecto de ondulación sobre una superficie, utilizando los estados previos y actuales de la ondulación, junto con una imagen de fondo. El efecto se aplica sin distorsionar la imagen de fondo, que permanece estática.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="n">ripple</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.008</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>rows_</cite> (int): El ancho de la pantalla o la superficie. - <cite>cols_</cite> (int): La altura de la pantalla o la superficie. - <cite>previous_</cite> (numpy.ndarray): Un array de tipo float con forma (w, h) utilizado para la transformación. Contiene el estado previo del efecto de ondulación. - <cite>current_</cite> (numpy.ndarray): Un array de tipo float con forma (w, h) utilizado para la transformación. Contiene el estado actual del efecto de ondulación. - <cite>array_</cite> (numpy.ndarray): Un array de tipo uint8 con forma (w, h, 3) que contiene la imagen de fondo estática en formato RGB. Este array permanece sin cambios. - <cite>dispersion_</cite> (float, opcional): El factor de amortiguación de la ondulación, que controla la intensidad del efecto de ondulación. Valores más altos reducen el radio del efecto de ondulación. El valor predeterminado es 0.008.</p>
<p><strong>Returns</strong>:
- <cite>tuple</cite>: A tuple containing two arrays <cite>(current_, previous_)</cite>, which represent the updated states of the ripple. See the Parameters section for the sizes of each array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.ripple_seabed">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">ripple_seabed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cols_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dispersion_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.008</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.ripple_seabed" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de ondulación con deformación del fondo.</p>
<p>Esta función simula un efecto de ondulación sobre una superficie, donde la imagen de fondo se deforma como parte del efecto. La función utiliza los estados previos y actuales de la ondulación junto con una textura y una imagen de fondo.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">back_array</span> <span class="o">=</span> <span class="n">ripple_seabed</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span>
   <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">back_array</span><span class="p">,</span> <span class="n">dispersion_</span><span class="o">=</span><span class="mf">0.009</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>cols_</cite> (int): El ancho de la pantalla o la superficie. - <cite>rows_</cite> (int): La altura de la pantalla o la superficie. - <cite>previous_</cite> (numpy.ndarray): Un array de tipo float con forma (w, h) utilizado para la transformación. Contiene el estado previo del efecto de ondulación. - <cite>current_</cite> (numpy.ndarray): Un array de tipo float con forma (w, h) utilizado para la transformación. Contiene el estado actual del efecto de ondulación. - <cite>texture_array_</cite> (numpy.ndarray): Un array de tipo uint8 con forma (w, h, 3) que contiene la imagen de fondo estática en formato RGB. Este array permanece sin cambios durante la transformación de la ondulación. - <cite>background_array_</cite> (numpy.ndarray): Un array de tipo uint8 con forma (w, h, 3) que contiene la imagen de fondo en formato RGB. Este array se transforma por el efecto de ondulación. - <cite>dispersion_</cite> (float, opcional): El factor de amortiguación de la ondulación, que controla la intensidad del efecto de ondulación. Valores más altos reducen el radio del efecto de ondulación. El valor predeterminado es 0.008.</p>
<p><strong>Retorna</strong>: - <cite>tuple</cite>: Una tupla que contiene tres arrays <cite>(current_, previous_, bck_array)</cite>. Los arrays representan los estados actualizados del efecto de ondulación y la deformación del fondo. Consulta la sección de Parámetros para ver los tamaños de cada array.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.heatmap">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">heatmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.heatmap" title="Link to this definition">¶</a></dt>
<dd><p>Transformar una imagen en un equivalente de mapa de calor (in situ).</p>
<p>Esta función modifica la superficie de la imagen dada para aplicar un efecto de mapa de calor. La transformación se aplica directamente a la superficie, por lo que no se devuelve un nuevo objeto. También permite al usuario elegir si el mapa de calor debe estar en el modelo de color RGB o BGR.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, convert to an alpha surface, and apply heatmap</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">heatmap</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto pygame.Surface, típicamente en formato de imagen de 24 o 32 bits (compatible con pygame). La imagen a la que se aplicará el efecto de mapa de calor. - <cite>rgb_</cite> (bool, opcional): Si es True, la imagen se transformará en un mapa de calor basado en RGB. Si es False, la transformación utilizará el modelo de mapa de calor basado en BGR. El valor predeterminado es True (RGB).</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: Esta función opera in situ, lo que significa que la superficie de entrada se modifica directamente sin devolver un nuevo objeto.</p>
<p><strong>Lanza</strong>: - <cite>TypeError</cite>: Si <cite>surface_</cite> no es un objeto pygame.Surface válido.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.predator_vision">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">predator_vision</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bpf_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.predator_vision" title="Link to this definition">¶</a></dt>
<dd><p>Simular el modo de visión de depredador.</p>
<p>Esta función simula la visión de un depredador utilizando una serie de filtros de procesamiento de imágenes. Aplica detección de bordes Sobel, filtro de paso alto (BPF), efectos de bloom y una inversión de mapa de colores a la superficie dada. Opcionalmente, permite un procesamiento más rápido y efectos de mezcla.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">predator_vision</span><span class="p">(</span>
   <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sobel_threshold</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">bpf_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
   <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inv_colormap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto pygame.Surface, compatible con formatos de 24 o 32 bits. Esta es la imagen a la que se aplicará el efecto de visión de depredador. - <cite>sobel_threshold</cite> (int, opcional): El umbral para la detección de bordes Sobel, utilizado para detectar bordes en la imagen. El valor predeterminado es 12. - <cite>bpf_threshold</cite> (int, opcional): El umbral para el Filtro de Paso Alto (BPF), utilizado para detectar y resaltar píxeles brillantes. El valor predeterminado es 50. - <cite>bloom_threshold</cite> (int, opcional): La intensidad del efecto de bloom, que añade un resplandor alrededor de los píxeles brillantes. El valor predeterminado es 50. - <cite>inv_colormap</cite> (bool, opcional): Si es True, el mapa de colores se invertirá, cambiando el esquema de color para parecerse más a la visión de un depredador. El valor predeterminado es False. - <cite>fast</cite> (bool, opcional): Si es True, se utiliza un modo de procesamiento más rápido. Esto reducirá la calidad a cambio de un tiempo de procesamiento más rápido. El valor predeterminado es False. - <cite>blend</cite> (int, opcional): El modo de mezcla que se aplicará después de procesar todos los efectos. Puede ser un valor de los modos <cite>pygame.BLEND_*</cite>. El valor predeterminado es <cite>pygame.BLEND_RGB_ADD</cite>.</p>
<p><strong>Retorna</strong>: - <cite>pygame.Surface</cite>: Un nuevo objeto pygame.Surface con el efecto de visión de depredador aplicado. La superficie está en formato de 24 bits.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blood">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blood" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de sangre (in situ).</p>
<p>Esta función aplica un efecto de sangre a una superficie dada utilizando un array de máscara que define el contorno del efecto de sangre. La superficie y la máscara deben tener las mismas dimensiones. El parámetro <cite>percentage</cite> determina la intensidad del efecto de sangre, donde 1.0 representa la intensidad completa.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/Aliens.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">background</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">RLEACCEL</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">background</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/redvignette.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">blood_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">BLOOD_MASK</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels_alpha</span><span class="p">(</span><span class="n">blood_surface</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Then call the method in your main loop (percentage must vary over time)</span>
<span class="n">blood</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">BLOOD_MASK</span><span class="p">,</span> <span class="n">percentage</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): La superficie (por ejemplo, la pantalla del juego) a la que se aplicará el efecto de sangre. Debe estar en un formato compatible de 24 o 32 bits. - <cite>mask_</cite> (numpy.ndarray o cython.view.memoryview): Un array normalizado o memoryview (forma: (w, h), tipo: float) que representa la máscara de sangre. Los valores deben estar en el rango [0.0, 1.0], donde 1.0 representa la intensidad completa del efecto. - <cite>percentage_</cite> (float): Un valor en el rango [0.0, 1.0] que determina la intensidad del efecto de sangre. Un valor de 1.0 aplica el efecto completo, mientras que 0.0 no aplica ningún efecto.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La función modifica la superficie dada in situ (es decir, no tiene valor de retorno).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring_array">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring_array" title="Link to this definition">¶</a></dt>
<dd><p>Devolver un array numpy reflejado.</p>
<p>Este método devuelve un numpy.ndarray con píxeles reflejados, volteando la imagen a lo largo del eje horizontal. El array de salida tiene la misma forma y tipo que el de entrada, con los valores de píxel reflejados.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rgb_array</span> <span class="o">=</span> <span class="n">mirroring_array</span><span class="p">(</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">image</span><span class="p">))</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">make_surface</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>rgb_array</cite> (numpy.ndarray): Un array con forma (w, h, 3) de tipo uint8, que contiene RGB o cualquier otro formato de píxel (como BGR).</p>
<p><strong>Retorna</strong>: - <cite>numpy.ndarray</cite>: Un ndarray de numpy con forma (w, h, 3) de tipo uint8, idéntico al array de entrada pero con píxeles reflejados.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.mirroring">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">mirroring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.mirroring" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de espejo (in situ).</p>
<p>Este método crea una imagen reflejada de la superficie dada al reflejarla horizontalmente. El efecto se aplica directamente a la superficie (in situ).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image, apply the mirroring effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">mirroring</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Una superficie de pygame compatible con formatos de 24 o 32 bits que se someterá al efecto de espejo.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La función modifica la superficie dada in situ, lo que significa que no devuelve una nueva superficie, sino que altera la superficie de entrada.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen" title="Link to this definition">¶</a></dt>
<dd><p>Enfocar una imagen (in situ) utilizando un kernel de 3x3.</p>
<p>Esta función aplica un filtro de enfoque a la imagen en la superficie dada. El filtro utiliza un kernel de 3x3 para mejorar los bordes y detalles al aumentar el contraste alrededor de los bordes, haciendo que la imagen parezca más nítida.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load an image and apply the sharpen effect</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/px.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sharpen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con formatos de imagen de 24 o 32 bits que se modificará in situ para aplicar el efecto de enfoque.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>None</cite>: La función modifica la superficie dada in situ, lo que significa que no se devuelve una nueva superficie. La superficie original se enfocará.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d" title="Link to this definition">¶</a></dt>
<dd><p>Enfocar un array (in situ) utilizando un kernel de 3x3.</p>
<p>Esta función aplica un filtro de enfoque directamente a un array 1D utilizando un kernel de 3x3. Es compatible con tipos de array BGR o BGR(A), y también puede funcionar con otros formatos de píxel como RGB o RGB(A). El filtro de enfoque mejora los bordes al aumentar el contraste a su alrededor, haciendo que la imagen parezca más nítida. Si el array contiene transparencia alfa, establece <cite>format_32=True</cite>.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">sharpen_1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>w</cite> (int): El ancho del array. - <cite>h</cite> (int): La altura del array. - <cite>bgr_array</cite> (numpy.ndarray): Un array 1D (forma: (w, )) de tipo uint8, que contiene los valores de píxel BGR o RGB. - <cite>format_32</cite> (bool, opcional): Si es <cite>True</cite>, el array contiene transparencia alfa (formato BGRA). Si es <cite>False</cite>, el array está en formato BGR (el valor predeterminado es <cite>False</cite>).</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La función modifica el array dado in situ (es decir, no se devuelve un nuevo array).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen_1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen_1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen_1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Enfocar un array (devolver un nuevo array).</p>
<p>Esta función devuelve un nuevo array con un filtro de enfoque aplicado, utilizando un kernel de 3x3. Es compatible con tipos de array BGR o BGR(A), y también puede funcionar con otros formatos de píxel como RGB o RGB(A). El filtro de enfoque mejora los bordes al aumentar el contraste a su alrededor, haciendo que la imagen parezca más nítida. Si el array contiene transparencia alfa, establece <cite>format_32=True</cite>.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit array data (BGR(A))</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="c1"># for 24-bit array data (BGR type)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">sharpen_1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>w</cite> (int): El ancho del array. - <cite>h</cite> (int): La altura del array. - <cite>bgr_array</cite> (numpy.ndarray): Un array 1D (forma: (w, )) de tipo uint8, que contiene los valores de píxel BGR o RGB. - <cite>format_32</cite> (bool, opcional): Si es <cite>True</cite>, el array contiene transparencia alfa (formato BGRA). Si es <cite>False</cite>, el array está en formato BGR (el valor predeterminado es <cite>False</cite>).</p>
<p><strong>Retorna</strong>: - <cite>numpy.ndarray</cite>: Un array numpy 1D (forma: (w, )) de tipo uint8, con píxeles enfocados similares al array de entrada.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.sharpen32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">sharpen32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.sharpen32" title="Link to this definition">¶</a></dt>
<dd><p>Enfocar una imagen utilizando un kernel de 3x3 (in situ).</p>
<p>Esta función aplica un filtro de enfoque directamente a la imagen en la superficie dada. El filtro utiliza un kernel de 3x3 para mejorar los bordes y detalles al aumentar el contraste alrededor de los bordes, haciendo que la imagen parezca más nítida. Es compatible con imágenes de 24 y 32 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit images</span>
<span class="n">sharpen32</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con formatos de 24 o 32 bits que se enfocará.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La función modifica la superficie dada in situ (es decir, no se devuelve una nueva superficie).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dirt_lens">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dirt_lens</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lens_model_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">light_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dirt_lens" title="Link to this definition">¶</a></dt>
<dd><p>Efecto de lente sucia (in situ).</p>
<p>Esta función aplica una textura de lente sucia sobre la pantalla del juego para simular un artefacto de cámara o un efecto de cámara realista, particularmente cuando la luz de la escena está orientada directamente hacia la cámara. La función mezcla la textura de la lente con la pantalla, creando un efecto de suciedad en la lente.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dirt_lens</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">lens_model</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">,</span> <span class="n">light_</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): La superficie (pantalla o pantalla del juego) que se modificará con el efecto de lente sucia. Debe estar en un formato de 24 o 32 bits. - <cite>lens_model_</cite> (pygame.Surface): La textura del modelo de lente (por ejemplo, lente sucia) que se aplicará a la superficie. Puedes elegir entre varias texturas de lente proporcionadas en el directorio Assets. Estas texturas deben redimensionarse para ajustarse a las dimensiones de la pantalla. - <cite>flag_</cite> (int, opcional): La bandera de mezcla que se aplicará a la textura de la lente. El valor predeterminado es <cite>pygame.BLEND_RGB_ADD</cite>, que añade la textura de la lente sobre la superficie. Puedes usar otras banderas de mezcla de Pygame como <cite>BLEND_RGB_MAX</cite>, etc. - <cite>light_</cite> (float, opcional): Un valor flotante entre -1.0 y 0.2 que ajusta el brillo de la textura de la lente. Valores menores que 0 reducirán el efecto de la lente, mientras que valores mayores que 0 aumentarán el brillo de la pantalla y el efecto de lente sucia. El valor predeterminado es 0.0.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: Esta función modifica la superficie de entrada in situ y no devuelve un nuevo objeto.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Floyd-Steinberg (copia).</p>
<p>Esta función aplica el algoritmo de difuminado Floyd-Steinberg a una superficie de Pygame para crear la ilusión de profundidad de color en imágenes con una paleta de colores limitada. El difuminado aproxima colores que no están disponibles en la paleta difundiendo píxeles de color dentro de la paleta disponible. El resultado es una imagen difuminada con una apariencia característica de granulosidad o moteado.</p>
<p>La imagen de entrada se convierte de una superficie de Pygame a un array 3D (w, h, 3) con un tipo de dato float. Como la imagen se convierte a un tipo de dato diferente (de <cite>uint8</cite> a <cite>float32</cite>), la transformación no se aplica in situ, y se devuelve una copia de la imagen original (sin el canal alfa).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto de superficie de Pygame en formato de 24 o 32 bits. La superficie que se difuminará.</p>
<p><strong>Retorna</strong>: - <cite>pygame.Surface</cite>: Una nueva superficie de Pygame en formato de 24 bits (sin el canal alfa) que representa la versión difuminada de la imagen de entrada.</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Floyd-Steinberg (in situ).</p>
<p>Esta función aplica el algoritmo de difuminado Floyd-Steinberg a una superficie de Pygame para crear la ilusión de profundidad de color en imágenes con una paleta de colores limitada. El difuminado aproxima colores que no están disponibles en la paleta difundiendo píxeles de color dentro de la paleta disponible. El resultado es una imagen difuminada con una apariencia característica de granulosidad o moteado. A diferencia de la versión no in situ, esta función modifica la superficie de la imagen in situ.</p>
<p>La imagen de entrada se convierte de una superficie de Pygame a un array 3D (w, h, 3) con un tipo de dato float. La imagen se modifica directamente y no se devuelve un nuevo objeto.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>: - <cite>surface_</cite> (pygame.Surface): Un objeto de superficie de Pygame en formato de 24 o 32 bits. La superficie que se difuminará.</p>
<p><strong>Retorna</strong>: - <cite>None</cite>: La superficie de entrada se modifica in situ (es decir, no se devuelve una nueva superficie).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Floyd-Steinberg (in situ) en un array 1D.</p>
<p>Esta función aplica el algoritmo de difuminado Floyd-Steinberg a un array 1D, simulando la ilusión de profundidad de color en imágenes con una paleta de colores limitada. El difuminado aproxima colores que no están disponibles en la paleta difundiendo píxeles de color dentro de la paleta disponible. El resultado es una imagen difuminada con una apariencia característica de granulosidad o moteado. Esta función modifica el array de entrada in situ.</p>
<p>El proceso de difuminado puede manejar imágenes de 24 y 32 bits, con la bandera <cite>format_32</cite> indicando si la entrada es una imagen de 32 bits (con transparencia) o una imagen de 24 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">dithering1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): El ancho del array de la imagen.</p></li>
<li><p><cite>h</cite> (int): La altura del array de la imagen.</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray): Un array 1D con forma <cite>(w, h, 3)</cite> para imágenes de 24 bits (BGR) o <cite>(w, h, 4)</cite> para imágenes de 32 bits (BGRA).</p></li>
<li><p><cite>format_32</cite> (bool, opcional): Una bandera que indica el formato de la imagen. Establece <cite>True</cite> para imágenes de 32 bits (BGRA) o <cite>False</cite> para imágenes de 24 bits (BGR). El valor predeterminado es <cite>False</cite>.</p></li>
</ul>
<p><strong>Retorna</strong>: - <cite>None</cite>: Esta función modifica el array de entrada in situ (es decir, no se devuelve un nuevo array).</p>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering1d_cp">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering1d_cp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering1d_cp" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Floyd-Steinberg (copia) en un array 1D.</p>
<p>Esta función aplica el algoritmo de difuminado Floyd-Steinberg a un array 1D, simulando la ilusión de profundidad de color en imágenes con una paleta de colores limitada. El difuminado aproxima colores que no están disponibles en la paleta difundiendo píxeles de color dentro de la paleta disponible. El resultado es una imagen difuminada con una apariencia característica de granulosidad o moteado. A diferencia de <cite>dithering1d</cite>, esta función devuelve un nuevo array con el efecto de difuminado aplicado, en lugar de modificar el array in situ.</p>
<p>El proceso de difuminado puede manejar imágenes de 24 y 32 bits. La bandera <cite>format_32</cite> indica si la entrada es una imagen de 32 bits (con transparencia) o una imagen de 24 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>  <span class="c1"># for 24-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGB&quot;</span><span class="p">)</span>

<span class="n">buff</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">dithering1d_cp</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>   <span class="c1"># for 32-bit image</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="s2">&quot;RGBA&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): El ancho del array de la imagen.</p></li>
<li><p><cite>h</cite> (int): La altura del array de la imagen.</p></li>
<li><p><cite>rgb_array</cite> (numpy.ndarray): Un array 1D con forma <cite>(w, h, 3)</cite> para imágenes de 24 bits (RGB) o <cite>(w, h, 4)</cite> para imágenes de 32 bits (RGBA).</p></li>
<li><p><cite>format_32</cite> (bool, opcional): Una bandera que indica el formato de la imagen. Establece <cite>True</cite> para imágenes de 32 bits (RGBA) o <cite>False</cite> para imágenes de 24 bits (RGB). El valor predeterminado es <cite>False</cite>.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>numpy.ndarray</cite>: Un nuevo array 1D con el efecto de difuminado aplicado. La forma del array es <cite>(w, h, 3)</cite> para imágenes de 24 bits o <cite>(w, h, 4)</cite> para imágenes de 32 bits.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Atkinson (copia)</p>
<p>El difuminado Atkinson es una variante del difuminado Floyd-Steinberg, desarrollado por Bill Atkinson en Apple Computer y utilizado en la computadora Macintosh original. Esta técnica de difuminado se utiliza para crear la ilusión de «profundidad de color» en imágenes con una paleta de colores limitada, también conocida como cuantización de color. Los colores que no están disponibles en la paleta se aproximan difundiendo píxeles de color dentro de la paleta disponible. El ojo humano percibe esta difusión como una mezcla de los colores, lo que a menudo resulta en una apariencia característica de granulosidad o moteado.</p>
<p>Esta función aplica el difuminado Atkinson a una imagen representada por una superficie de Pygame. La imagen se convierte a un formato de array 3D con la forma <cite>(w, h, 3)</cite> y tipo <cite>float32</cite> (precisión simple). Dado que la imagen se convierte a un tipo de dato diferente (de <cite>uint8</cite> a <cite>float32</cite>), la transformación no se puede aplicar in situ.</p>
<p>La función devuelve una nueva imagen con el efecto de difuminado aplicado.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">dithering_atkinson</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>  <span class="c1"># for 24 or 32-bit image format</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame en formato de 24 o 32 bits que se someterá al difuminado Atkinson.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie de Pygame en formato de 24 bits con el efecto de difuminado aplicado (sin el canal alfa).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dithering_atkinson1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dithering_atkinson1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_buffer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dithering_atkinson1d" title="Link to this definition">¶</a></dt>
<dd><p>Difuminado Atkinson para Array 1D (in situ)</p>
<p>El difuminado Atkinson es una variante del difuminado Floyd-Steinberg, desarrollado por Bill Atkinson en Apple Computer y utilizado en la computadora Macintosh original. Esta técnica de difuminado se emplea para crear la ilusión de «profundidad de color» en imágenes con una paleta de colores limitada, un proceso también conocido como cuantización de color. En una imagen difuminada, los colores no disponibles en la paleta se aproximan difundiendo píxeles de color dentro de la paleta disponible. El ojo humano percibe esta difusión como una mezcla de colores, lo que a menudo resulta en una apariencia característica de granulosidad o moteado.</p>
<p>Esta función aplica el difuminado Atkinson a una imagen representada por un array 1D en memoria. Opera directamente sobre el array (in situ), modificando los valores de los píxeles para lograr el efecto de difuminado.</p>
<p>La función es compatible con imágenes de 24 y 32 bits. Si el proceso de difuminado no se aplica a la imagen, verifica la bandera <cite>format_32</cite>. La bandera debe establecerse en <cite>True</cite> para imágenes que contengan transparencia por píxel o formas de array equivalentes (w, h, 4). Para imágenes de 24 bits, establece <cite>format_32</cite> en <cite>False</cite> (forma del array (w, h, 3)).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># for 32-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># for 24-bit image</span>
<span class="n">dithering_atkinson1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): El ancho del array.</p></li>
<li><p><cite>h</cite> (int): La altura del array.</p></li>
<li><p><cite>c_buffer</cite> (C-Buffer o memoryviewslice o numpy.ndarray 1D): El array 1D o vista de memoria que contiene píxeles BGR o cualquier otro formato de píxel (tipo de dato uint8).</p></li>
<li><p><cite>format_32</cite> (bool, opcional): - <cite>True</cite> si el array representa una imagen de 32 bits (formato BGRA con transparencia). - <cite>False</cite> para una imagen de 24 bits (formato BGR). El valor predeterminado es <cite>False</cite>.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>None</cite>: Esta función modifica el array in situ. No devuelve un nuevo array.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.pixelation">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">pixelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocksize_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.pixelation" title="Link to this definition">¶</a></dt>
<dd><p>Pixelar una superficie de Pygame</p>
<p>La pixelación en gráficos por computadora se refiere al efecto causado al mostrar un mapa de bits o una sección de un mapa de bits a un tamaño tan grande que los píxeles individuales se vuelven visibles. Cuando se aplica a una imagen, la pixelación reduce la resolución de la imagen al aumentar el tamaño de los píxeles individuales, creando una apariencia bloqueada y pixelada.</p>
<p>Esta función pixeliza una superficie de Pygame dividiendo la imagen en bloques cuadrados, donde cada bloque representa el color promedio de los píxeles dentro de él. El tamaño del bloque se especifica con el parámetro <cite>blocksize_</cite> (el valor predeterminado es 64).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">pix_image</span> <span class="o">=</span> <span class="n">pixelation</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de Pygame que se pixelará.</p></li>
<li><p><cite>blocksize_</cite> (unsigned int, opcional): El tamaño del bloque utilizado para el proceso de pixelación, el valor predeterminado es 64. Este valor determina el tamaño de cada bloque pixelado (por ejemplo, bloques de 64x64 píxeles).</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie con el efecto de pixelación aplicado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend" title="Link to this definition">¶</a></dt>
<dd><p>Mezcla Alfa</p>
<p>Mezcla dos imágenes utilizando mezcla alfa, donde una imagen se superpone sobre otra con un nivel de transparencia especificado. La función permite mezclar la imagen <cite>source</cite> sobre la imagen <cite>destination</cite> según un valor de porcentaje, donde 0% significa que no hay mezcla y 100% significa que la imagen <cite>source</cite> reemplaza completamente la imagen <cite>destination</cite>.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 24 or 32-bit image</span>
<span class="n">transition</span> <span class="o">=</span> <span class="n">blend</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">image1</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">image2</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface): La imagen de origen (compatible con 24 o 32 bits).</p></li>
<li><p><cite>destination</cite> (pygame.Surface): La imagen de destino (compatible con 24 o 32 bits).</p></li>
<li><p><cite>percentage</cite> (float): El valor de porcentaje entre 0.0 y 100.0 que determina el nivel de mezcla. 0.0 significa que la imagen de origen es completamente transparente, y 100.0 significa que la imagen de origen reemplaza completamente la imagen de destino.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie (24 bits) que representa el resultado mezclado de las imágenes <cite>source</cite> y <cite>destination</cite>.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend1d" title="Link to this definition">¶</a></dt>
<dd><p>Mezcla Alfa (Array 1D)</p>
<p>Mezcla dos buffers de imagen 1D utilizando mezcla alfa. Este método permite mezclar dos imágenes proporcionando los buffers de imagen como origen y destino. El argumento <cite>percentage</cite> permite controlar cuánto contribuye cada imagen al resultado final. Por ejemplo, si <cite>percentage</cite> se establece en 25%, la imagen de origen contribuirá un 25% mientras que la imagen de destino contribuirá un 75%.</p>
<p>El argumento <cite>modes</cite> especifica el formato de píxel de los buffers de origen y destino, que puede ser “RGB(X)” o “BGR(X)”, donde “X” se refiere al canal alfa si está presente. El argumento <cite>format_32</cite> debe establecerse en <cite>True</cite> si los buffers de origen y destino contienen transparencia alfa (formato RGBA).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># For 32-bit images with alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1"># For 24-bit images without alpha transparency</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">blend1d</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="n">BCK</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="mi">25</span><span class="p">,</span> <span class="s1">&#39;BGR(X)&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): Ancho del array de origen.</p></li>
<li><p><cite>h</cite> (int): Altura del array de origen.</p></li>
<li><p><cite>source</cite> (numpy.ndarray): Array 1D de tipo uint8 que representa la imagen de origen en formato RGB(A) o BGR(A).</p></li>
<li><p><cite>destination</cite> (numpy.ndarray): Array 1D de tipo uint8 que representa la imagen de destino en el mismo formato que <cite>source</cite>.</p></li>
<li><p><cite>percentage</cite> (float): Valor de porcentaje de mezcla entre 0 y 100. Un valor de 0 significa que solo la imagen de destino es visible, mientras que 100 significa que solo la imagen de origen es visible.</p></li>
<li><p><cite>modes</cite> (str): Una cadena que representa el formato de píxel de los arrays de origen y destino. Usa “RGB(X)” para formato RGB o RGBA y “BGR(X)” para formato BGR o BGRA.</p></li>
<li><p><cite>format_32</cite> (bool): Si es <cite>True</cite>, los arrays de origen y destino contienen transparencia alfa (formato RGBA o BGRA). El valor predeterminado es <cite>False</cite>.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie con el efecto de mezcla aplicado, que puede ser de 24 o 32 bits dependiendo de los formatos de los arrays de origen y destino.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blend_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blend_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">destination</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blend_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Mezcla Alfa (In situ)</p>
<p>Esta función mezcla la imagen <cite>source</cite> en la imagen <cite>destination</cite>, modificando la imagen de destino directamente. Las texturas <cite>source</cite> y <cite>destination</cite> deben tener el mismo tamaño. El argumento <cite>percentage</cite> controla cuánto contribuye cada imagen al resultado final. Por ejemplo, si <cite>percentage</cite> se establece en 25%, la imagen de origen contribuirá un 25% mientras que la imagen de destino contribuirá un 75%.</p>
<p>La función es compatible con superficies de 24 y 32 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">blend_inplace</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>destination</cite> (pygame.Surface): La superficie que se modificará, compatible con superficies de 24 o 32 bits.</p></li>
<li><p><cite>source</cite> (pygame.Surface): La superficie que se mezclará en la destino, compatible con superficies de 24 o 32 bits.</p></li>
<li><p><cite>percentage</cite> (float): Un valor entre 0.0 y 100.0 que indica el porcentaje de mezcla. Un valor de 0.0 significa que no hay efecto de la imagen de origen, y 100.0 significa que la imagen de origen reemplaza completamente la imagen de destino.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: La operación se realiza in situ, lo que significa que la superficie de destino se modifica directamente.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.cartoon">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">cartoon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.cartoon" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de dibujo animado a una imagen.</p>
<p>Esta función aplica un efecto de dibujo animado a una superficie dada. Utiliza un filtro Sobel para la detección de bordes y lo combina con filtrado de mediana y reducción de color para crear un efecto de dibujo animado simplificado y estilizado. La función es compatible con imágenes de 24 y 32 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cartoon_image</span> <span class="o">=</span> <span class="n">cartoon</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie a la que se aplicará el efecto de dibujo animado. Puede ser de 24 o 32 bits.</p></li>
<li><p><cite>sobel_threshold</cite> (unsigned int, opcional): El umbral del filtro Sobel para la detección de bordes. El valor predeterminado es 128.</p></li>
<li><p><cite>median_kernel</cite> (unsigned int, opcional): El tamaño del kernel utilizado para el filtrado de mediana. El valor predeterminado es 2.</p></li>
<li><p><cite>color</cite> (unsigned int, opcional): El nivel máximo de reducción de color (es decir, el número de colores en la imagen después de la reducción). El valor predeterminado es 8.</p></li>
<li><p><cite>flag</cite> (unsigned int, opcional): La bandera de mezcla para combinar la imagen de dibujo animado final. El valor predeterminado es <cite>BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: La superficie de entrada con el efecto de dibujo animado aplicado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.convert_27">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">convert_27</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.convert_27" title="Link to this definition">¶</a></dt>
<dd><p>Convertir una imagen a una paleta de colores reducida de 27 colores (in situ).</p>
<p>Esta función reduce la profundidad de color de una imagen aplicando un algoritmo que la convierte a solo 27 colores distintos. La operación se realiza in situ, lo que significa que la superficie original se modifica directamente.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">convert_27</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie (imagen) que se convertirá a una paleta de colores reducida. Es compatible con formatos de imagen de 24 y 32 bits.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: La función modifica la superficie in situ y no devuelve una nueva superficie.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilateral">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilateral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilateral" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un filtrado bilateral a una imagen y devolver una copia filtrada.</p>
<p>El filtrado bilateral es un filtro de suavizado no lineal que preserva bordes y reduce el ruido. Reemplaza la intensidad de cada píxel con un promedio ponderado de las intensidades de los píxeles cercanos, donde los pesos se basan tanto en la proximidad espacial como en la similitud de intensidad. Esto permite que el filtro difumine regiones suaves mientras preserva los bordes nítidos.</p>
<p>El filtro depende de dos parámetros clave:</p>
<ul class="simple">
<li><p><strong>sigma_s</strong>: Extensión espacial del kernel. Define el tamaño del vecindario alrededor de cada píxel que influye en la operación del filtro.</p></li>
<li><p><strong>sigma_i</strong>: Rango de intensidad del kernel. Controla cuán sensible es el filtro a las diferencias de intensidad. Un valor más pequeño de <cite>sigma_i</cite> preserva los bordes de manera más efectiva, mientras que un valor más grande permite un desenfoque más uniforme.</p></li>
</ul>
<p>A medida que <cite>sigma_i</cite> aumenta, el filtro se aproxima a un desenfoque gaussiano (que se aplica uniformemente en toda la imagen). Un valor más pequeño de <cite>sigma_i</cite> retiene más detalles locales al reducir la contribución de píxeles con intensidades diferentes.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface</span> <span class="o">=</span> <span class="n">bilateral</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">18.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>image</cite> (pygame.Surface): La superficie (imagen) a la que se aplicará el filtro bilateral. La imagen debe estar en formato RGB de 24-32 bits, y el canal alfa se ignorará. La imagen se convierte en un array 3D para su procesamiento.</p></li>
<li><p><cite>sigma_s</cite> (float): La extensión espacial del kernel. Este parámetro controla el tamaño del vecindario utilizado para calcular el promedio ponderado.</p></li>
<li><p><cite>sigma_i</cite> (float): Sensibilidad de intensidad. Define la diferencia máxima de intensidad que contribuye al desenfoque. Valores más pequeños preservarán los bordes.</p></li>
<li><p><cite>kernel_size</cite> (int, opcional): El tamaño del kernel (el valor predeterminado es 3). Esto controla qué tan lejos llega el filtro desde cada píxel.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie de Pygame con el filtro bilateral aplicado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un filtro de relieve a una imagen o superficie, produciendo un efecto de relieve.</p>
<p>El filtro de relieve crea un efecto visual que hace que la imagen parezca elevada, similar a un relieve en papel o metal de la imagen original, lo que puede usarse para resaltar bordes o crear efectos artísticos.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">emboss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con formatos de imagen de 24 o 32 bits.</p></li>
<li><p><cite>flag_</cite> (int, opcional): Una bandera especial de mezcla de Pygame (el valor predeterminado es 0). Esta bandera puede ser uno de los modos de mezcla como <cite>BLEND_RGB_ADD</cite>, <cite>BLEND_RGB_MULT</cite>, etc. Modifica el comportamiento de mezcla de la imagen y afectará el resultado final.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una superficie que contiene la imagen en relieve. Si <cite>flag_</cite> se establece en 0, la salida es un formato de 24 bits; de lo contrario, se devuelve un formato de 32 bits.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Relieve de una superficie (in situ)</p>
<p>Esta función aplica un filtro de relieve a una imagen in situ, lo que significa que la imagen en sí se modifica en lugar de crear una nueva imagen. El efecto de relieve produce un efecto elevado y texturizado, similar a un relieve en papel o metal. Puede resaltar bordes y crear efectos artísticos en la imagen.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">pixel_copy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">array3d</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">emboss_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">pixel_copy</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame que se someterá al efecto de relieve. La superficie se modificará in situ una vez que se complete el proceso.</p></li>
<li><p><cite>copy</cite> (numpy.ndarray, opcional): Un array de numpy con forma <cite>(w, h, 3)</cite> de tipo <cite>uint8</cite> que contiene los píxeles RGB. Debe tener el mismo tamaño que la superficie de entrada. Este array se utiliza como una copia del array de origen para mejorar ligeramente el rendimiento.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: La superficie se modifica in situ y no se devuelve una nueva superficie.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss1d">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss1d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmp_array</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss1d" title="Link to this definition">¶</a></dt>
<dd><p>Relieve directo de un tipo C-buffer (in situ)</p>
<p>Esta función aplica un filtro de relieve a una imagen in situ, modificando directamente el array C-buffer proporcionado (<cite>bgr_array</cite>). El efecto de relieve produce una textura elevada, similar a un relieve en papel o metal, haciendo que los bordes sean más prominentes y creando efectos artísticos.</p>
<p>Si se proporciona <cite>tmp_array</cite>, se utiliza para mejorar el rendimiento, pero debe tener la misma forma y tamaño que el array de origen (<cite>bgr_array</cite>).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
<span class="n">image_copy</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">emboss1d</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">),</span> <span class="n">image_copy</span><span class="o">.</span><span class="n">get_buffer</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>w</cite> (int): El ancho de la superficie (imagen).</p></li>
<li><p><cite>h</cite> (int): La altura de la superficie (imagen).</p></li>
<li><p><cite>bgr_array</cite> (numpy.ndarray o memoryviewslice): Un array 1D de tipo <cite>uint8</cite> que contiene datos de píxeles BGR o cualquier otro formato de píxel. Este array representa los datos de origen que se modificarán in situ.</p></li>
<li><p><cite>tmp_array</cite> (numpy.ndarray o memoryviewslice, opcional): Un array 1D de tipo <cite>uint8</cite> que contiene datos de píxeles BGR o cualquier otro formato de píxel. Este array debe ser una copia del array de origen para mejorar el rendimiento.</p></li>
<li><p><cite>format_32</cite> (bool, predeterminado es False): Establece <cite>True</cite> si el array de origen contiene transparencia alfa (formato de 32 bits).</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: La función modifica <cite>bgr_array</cite> in situ y no devuelve un nuevo array.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.emboss_gray">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">emboss_gray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.emboss_gray" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un filtro de relieve en escala de grises a una imagen o superficie y devolver una copia modificada.</p>
<p>Esta función aplica un efecto de relieve a la imagen o superficie dada en escala de grises. El efecto de relieve crea una textura elevada que imita un relieve en papel o metal. El resultado es un efecto estilizado donde los bordes y contornos se enfatizan, pero en una paleta monocromática de escala de grises.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">emboss_gray</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de entrada (imagen) a la que se aplicará el efecto de relieve en escala de grises. Esta superficie debe ser compatible con formatos de 24 o 32 bits.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie de Pygame con la imagen en relieve en escala de grises. La imagen resultante siempre está en formato de 24 bits.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bilinear">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bilinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bilinear" title="Link to this definition">¶</a></dt>
<dd><p>Redimensionar una imagen utilizando el algoritmo de filtro bilineal (devuelve una copia).</p>
<p>Esta función aplica el filtro bilineal para redimensionar una imagen. El filtrado bilineal suaviza la imagen y se usa comúnmente en tareas de redimensionamiento de imágenes. La función admite imágenes de entrada de 32 bits, pero el resultado siempre se devuelve en formato de 24 bits (sin el canal alfa).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Resize image to 600x600</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bilinear</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Resize with specific scaling factors</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de entrada (imagen) que se redimensionará. Debe ser compatible con formatos de 24 o 32 bits.</p></li>
<li><p><cite>size_</cite> (tuple): Una tupla <cite>(ancho, alto)</cite> que especifica las nuevas dimensiones para la superficie redimensionada.</p></li>
<li><p><cite>fx</cite> (float, opcional): Un factor de escala para el eje x (ancho). Si se proporciona, anulará el ancho especificado en <cite>size_</cite>. El valor predeterminado es None.</p></li>
<li><p><cite>fy</cite> (float, opcional): Un factor de escala para el eje y (altura). Si se proporciona, anulará la altura especificada en <cite>size_</cite>. El valor predeterminado es None.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie de Pygame de tipo 24 bits (sin el canal alfa), redimensionada según los parámetros de entrada.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling24" title="Link to this definition">¶</a></dt>
<dd><p>Modelado de túnel de 24 bits Este método producirá datos de renderizado de 24 bits para simular un efecto de túnel.</p>
<p>El algoritmo utiliza una textura de 256x256 pero la redimensiona a 512x512 píxeles para una mejor renderización. Genera un efecto de túnel manipulando distancias, ángulos, sombras y datos de renderizado.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling24</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int): El ancho de la pantalla o el ancho del efecto de túnel.</p></li>
<li><p><cite>screen_height</cite> (int): La altura de la pantalla o la altura del efecto de túnel.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface): El efecto de textura del túnel, compatible con formatos de 24 o 32 bits.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: Una tupla que contiene cuatro buffers: - <cite>distances</cite>: Buffer que contiene datos de distancia. - <cite>angles</cite>: Buffer que contiene datos de ángulo. - <cite>shades</cite>: Buffer que contiene datos de sombreado. - <cite>scr_data</cite>: Buffer que contiene los datos de renderizado de la pantalla.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render24" title="Link to this definition">¶</a></dt>
<dd><p>Renderizado del efecto de túnel</p>
<p>Esta función renderiza el efecto de túnel basado en datos precalculados, creando una superficie de salida de 24 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render24</span><span class="p">(</span><span class="n">FRAME</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>t</cite> (int): Temporizador o conteo de fotogramas. Controla la velocidad del efecto de túnel.</p></li>
<li><p><cite>screen_width</cite> (int): El ancho de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>screen_height</cite> (int): La altura de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>screen_w2</cite> (int): El ancho de la pantalla dividido por 2.</p></li>
<li><p><cite>screen_h2</cite> (int): La altura de la pantalla dividido por 2.</p></li>
<li><p><cite>distances</cite> (numpy.ndarray): Un buffer C 1D que contiene las distancias. Este buffer se obtiene de la función <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray): Un buffer C 1D que contiene los ángulos. Este buffer se obtiene de la función <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray): Un buffer C 1D que contiene las sombras. Este buffer se obtiene de la función <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray): Un buffer C 1D que contiene los píxeles de fondo. Este buffer se obtiene de la función <cite>tunnel_modeling24</cite>.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray): Un buffer C 1D, típicamente vacío. Debe tener el mismo tamaño que la imagen de salida (ancho * alto * 4 para RGBA). Este buffer se utiliza para construir el efecto de textura final.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una superficie de 24 bits con el efecto de túnel renderizado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_modeling32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_modeling32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_modeling32" title="Link to this definition">¶</a></dt>
<dd><p>Generar un efecto de modelado de túnel de 32 bits.</p>
<p>Esta función simula un efecto de túnel y genera datos de renderizado de 32 bits basados en la textura de superficie proporcionada. Utiliza una textura de 256x256, que se redimensiona a una resolución de 512x512 para una mejor calidad de renderizado. El algoritmo calcula varios parámetros, como distancias, ángulos, sombras y datos de renderizado, que se pueden utilizar para visualizar el efecto de túnel.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">HEIGHT</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space2.jpg&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">BCK1</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BCK1</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;../Assets/space1.jpg&quot;</span><span class="p">)</span>
<span class="n">BACKGROUND</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">BACKGROUND</span><span class="p">,</span> <span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">))</span>
<span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span> <span class="o">=</span> <span class="n">tunnel_modeling32</span><span class="p">(</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">BACKGROUND</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>screen_width</cite> (int): El ancho de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>screen_height</cite> (int): La altura de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de textura utilizada para el efecto de túnel. La superficie debe ser compatible con formatos de 24 o 32 bits.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: Una tupla que contiene cuatro buffers: - <cite>distances</cite>: Un buffer que representa las distancias calculadas para el efecto. - <cite>angles</cite>: Un buffer que representa los ángulos calculados para el efecto. - <cite>shades</cite>: Un buffer que representa las sombras (brillo) calculadas para el efecto. - <cite>scr_data</cite>: Un buffer que contiene los datos de textura de la superficie.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.tunnel_render32">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">tunnel_render32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">screen_h2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shades</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scr_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.tunnel_render32" title="Link to this definition">¶</a></dt>
<dd><p>Renderizado del efecto de túnel.</p>
<p>Esta función renderiza el efecto de túnel utilizando datos de renderizado de 32 bits. Toma los parámetros calculados por la función <cite>tunnel_modeling32</cite> y los aplica para generar el efecto de túnel final. La salida es una superficie de 32 bits que se puede utilizar en el renderizado de Pygame.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surface_</span> <span class="o">=</span> <span class="n">tunnel_render32</span><span class="p">(</span><span class="n">FRAME</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">shades</span><span class="p">,</span> <span class="n">scr_data</span><span class="p">,</span> <span class="n">dest_array</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface_</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">special_flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>t</cite> (int): El temporizador o conteo de fotogramas. Esto controla la velocidad del efecto.</p></li>
<li><p><cite>screen_width</cite> (int): El ancho de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>screen_height</cite> (int): La altura de la pantalla o del efecto de túnel.</p></li>
<li><p><cite>screen_w2</cite> (int): Esto es la mitad del ancho de la pantalla (<cite>screen_width // 2</cite>).</p></li>
<li><p><cite>screen_h2</cite> (int): Esto es la mitad de la altura de la pantalla (<cite>screen_height // 2</cite>).</p></li>
<li><p><cite>distances</cite> (numpy.ndarray): Un buffer C de distancias, que se genera a partir de la función <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>angles</cite> (numpy.ndarray): Un buffer C de ángulos, que se genera a partir de la función <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>shades</cite> (numpy.ndarray): Un buffer C de sombras (brillo), que se genera a partir de la función <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>scr_data</cite> (numpy.ndarray): Un buffer C de datos de píxeles de fondo, que se genera a partir de la función <cite>tunnel_modeling32</cite>.</p></li>
<li><p><cite>dest_array</cite> (numpy.ndarray): Un buffer C vacío, típicamente un buffer vacío con una longitud de <cite>ancho * alto * 4</cite> (RGBA). Este buffer se utilizará para construir la imagen final del efecto de túnel.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una superficie que contiene la imagen de 32 bits del efecto de túnel renderizado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de bloom rápido a una superficie de entrada.</p>
<p>El efecto de bloom ilumina los píxeles de la imagen por encima de un umbral especificado y luego aplica un desenfoque para crear un efecto de resplandor. Esta función realiza una serie de operaciones de reducción de escala y desenfoques, que luego se combinan para producir el efecto de bloom final. El algoritmo puede optimizarse para la velocidad, sacrificando algo de calidad visual.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">shader_bloom_fast</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame que contiene datos de píxeles RGB (formato de color de 32 o 24 bits).</p></li>
<li><p><cite>threshold</cite> (int): El umbral de brillo para el efecto de bloom. Los píxeles con valores por encima de este umbral contribuirán al efecto de bloom. Un valor más pequeño causará un bloom más fuerte.</p></li>
<li><p><cite>fast</cite> (bint, opcional): Si es True, el algoritmo priorizará la velocidad sobre la calidad visual al aplicar el desenfoque solo a la superficie de menor escala (S16). El valor predeterminado es False.</p></li>
<li><p><cite>factor</cite> (int, opcional): Un valor entre 0 y 4 que controla el nivel de reducción de escala para las texturas utilizadas en el bloom. Valores más altos resultan en una reducción de escala más agresiva. El valor predeterminado es 2, que corresponde a una división por 4.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una superficie de Pygame con el efecto de bloom aplicado, en formato de color de 24 bits.</p></li>
</ul>
<p><strong>Lanza</strong>:</p>
<ul class="simple">
<li><p><cite>ValueError</cite>: Si la superficie es demasiado pequeña para procesar (por ejemplo, después de la reducción de escala).</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.shader_bloom_fast1">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">shader_bloom_fast1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.shader_bloom_fast1" title="Link to this definition">¶</a></dt>
<dd><p>Efecto de bloom aplicado in situ (versión simplificada para un mejor rendimiento).</p>
<p>La función <cite>shader_bloom_fast1</cite> aplica un efecto de bloom optimizado para objetos en movimiento en la pantalla. A diferencia de otros métodos de bloom, esta versión no hace que el halo de luz se desplace de los objetos en movimiento, ya que evita la técnica de reducción de escala. Esto la hace más adecuada para escenas dinámicas donde los objetos están en movimiento.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame con formato de color compatible de 32 o 24 bits (RGB).</p></li>
<li><p><cite>smooth_</cite> (int, opcional): El factor de suavizado para extender el halo de luz. El valor predeterminado es 3. Valores más altos extienden el bloom sobre toda la escena pero disminuyen el efecto, mientras que valores más pequeños crean un halo más pixelado pero intensifican el efecto en los objetos. Si smooth es menor que 3, el halo se vuelve pixelado.</p></li>
<li><p><cite>threshold_</cite> (int, opcional): El umbral para la intensidad del bloom. Un umbral de 0 corresponde al bloom máximo. El valor predeterminado es 0, lo que significa que no se aplica ningún umbral.</p></li>
<li><p><cite>flag_</cite> (int, opcional): Una bandera de mezcla de Pygame para efectos de mezcla especiales con la luz en la pantalla. El valor predeterminado es <cite>pygame.BLEND_RGB_ADD</cite>. Otras opciones incluyen <cite>BLEND_RGB_MAX</cite>, <cite>BLEND_RGB_SUB</cite> y otros atributos de mezcla de Pygame.</p></li>
<li><p><cite>saturation_</cite> (bool, opcional): Si es True, el efecto de bloom incluirá un efecto de saturación en el halo. El valor predeterminado es False.</p></li>
<li><p><cite>mask_</cite> (numpy.ndarray o memoryviewslice, opcional): Un array de numpy o memoryview que representa la máscara alfa. Debe tener la forma (w, h) y tipo <cite>float32</cite>, con valores en el rango (0..255). Una máscara llena de 255 renderizará y aplicará bloom a toda la imagen, mientras que una máscara llena de 0 desactivará el efecto de bloom. Los valores entre 0 y 255 crean un efecto de bloom selectivo. La máscara es opcional.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: Este efecto se aplica in situ, modificando directamente la superficie de entrada.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shader_bloom_fast1</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels" title="Link to this definition">¶</a></dt>
<dd><p>Efecto de división RGB (devuelve una copia).</p>
<p>Esta función aplica un efecto de división RGB a una imagen desplazando los canales según el desplazamiento proporcionado. El resultado es una imagen con los canales rojo, verde y azul desplazados de sus posiciones originales. El valor de desplazamiento controla la dirección y magnitud del desplazamiento.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con formatos de color de 24 o 32 bits (RGB). La imagen de entrada a la que se aplicará el efecto de división RGB.</p></li>
<li><p><cite>offset_</cite> (char): Un valor entero que especifica el desplazamiento a aplicar entre los canales RGB. El desplazamiento debe estar en el rango [-128, 127]. Si el desplazamiento es positivo, los canales se muestran en el orden BGR. Si el desplazamiento es negativo, los canales se muestran en el orden RGB.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, opcional): Un array de numpy con la forma (w, h, 3) y tipo <cite>uint8</cite>. Si se proporciona, este array acelerará el proceso al aplicar directamente la transformación a él. Este parámetro es opcional.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie (copia) con el efecto de división RGB aplicado, donde los canales RGB están desplazados según el valor especificado.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">split_channels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.split_channels_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">split_channels_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">array_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.split_channels_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Efecto de división RGB (in situ).</p>
<p>Esta función aplica un efecto de división RGB a una imagen directamente, modificando la imagen original sin crear una nueva copia. La función desplaza los canales rojo, verde y azul según el valor de desplazamiento proporcionado, ya sea reorganizando los canales o aplicando el desplazamiento especificado.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con formatos de color de 24 o 32 bits (RGB). La imagen de entrada a la que se aplicará el efecto de división RGB, y los cambios se aplicarán directamente a esta superficie.</p></li>
<li><p><cite>offset_</cite> (char): Un valor entero que especifica el desplazamiento a aplicar entre los canales RGB. El desplazamiento debe estar en el rango [-128, 127]. Si el desplazamiento es positivo, los canales se muestran en el orden BGR. Si el desplazamiento es negativo, los canales se muestran en el orden RGB.</p></li>
<li><p><cite>array_</cite> (numpy.ndarray, opcional): Un array de numpy con la forma (w, h, 3) y tipo <cite>uint8</cite>. Si se proporciona, este array se utilizará para acelerar el proceso al aplicar directamente la transformación a él. Este parámetro es opcional.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: Los cambios se aplican directamente a la superficie de entrada, por lo que no se devuelve una nueva superficie.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">split_channels_inplace</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.wavelength2rgb">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">wavelength2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.wavelength2rgb" title="Link to this definition">¶</a></dt>
<dd><p>Convertir una longitud de onda a color RGB.</p>
<p>Esta función mapea una longitud de onda dada (en nanómetros) a un color RGB. La longitud de onda se interpreta dentro del espectro visible (380–750 nm), y el color correspondiente se devuelve en el modelo de color RGB. La función permite opcionalmente la corrección gamma, que ajusta el brillo del color.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int): La longitud de onda de la luz en nanómetros (nm), típicamente dentro del rango del espectro visible de 380–750 nm. La función utiliza este valor para determinar el color correspondiente.</p></li>
<li><p><cite>gamma</cite> (float, opcional): Un factor de corrección gamma aplicado al color. El valor predeterminado es <cite>1.0</cite>, lo que significa que no se aplica ninguna corrección. Valores mayores que <cite>1.0</cite> aumentan el brillo del color, mientras que valores menores que <cite>1.0</cite> lo oscurecen.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: Una tupla de tres enteros que representan los componentes RGB del color, con cada valor en el rango de 0 a 255.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns RGB values for orange (255, 137, 0)</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>

<span class="c1"># Returns RGB values for red with gamma correction</span>
<span class="n">wavelength2rgb</span><span class="p">(</span><span class="mi">620</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.custom_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">custom_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.custom_map" title="Link to this definition">¶</a></dt>
<dd><p>Mapear una longitud de onda a un color RGB personalizado basado en un dominio de longitud de onda definido por el usuario.</p>
<p>A diferencia de la función <cite>wavelength2rgb</cite> que devuelve valores RGB correspondientes a una longitud de onda dentro del espectro visible estándar (380–750 nm), esta función permite al usuario definir un dominio de longitud de onda personalizado y devuelve el color RGB correspondiente para una longitud de onda en ese dominio.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int): La longitud de onda de la luz en nanómetros (nm). Este valor se mapea al dominio de longitud de onda personalizado definido en <cite>color_array</cite>.</p></li>
<li><p><cite>color_array</cite> (numpy.ndarray): Un array 1D de enteros que representa los límites de longitud de onda de diferentes colores. El array debe contener pares de valores para cada color (por ejemplo, rangos [min, max] para colores como amarillo, naranja, rojo, etc.). Estos rangos definen el dominio en el que se aplicarán los colores.</p></li>
<li><p><cite>gamma</cite> (float, opcional): Un factor de corrección gamma aplicado al color RGB resultante. El valor predeterminado es <cite>1.0</cite>, lo que significa que no se aplica corrección gamma. Valores mayores que <cite>1.0</cite> aumentarán el brillo del color, mientras que valores menores que <cite>1.0</cite> lo oscurecerán.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: Una tupla que contiene los valores RGB (0-255) para el color correspondiente a la longitud de onda dada dentro del dominio personalizado.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a custom wavelength domain with different color gradients</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Violet not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Blue not used</span>
     <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1"># Green not used</span>
     <span class="mi">570</span><span class="p">,</span> <span class="mi">619</span><span class="p">,</span>   <span class="c1"># Yellow gradient from 2 to 619 nm</span>
     <span class="mi">620</span><span class="p">,</span> <span class="mi">650</span><span class="p">,</span>   <span class="c1"># Orange gradient from 620 to 650 nm</span>
     <span class="mi">651</span><span class="p">,</span> <span class="mi">660</span>    <span class="c1"># Red gradient from 651 to 660 nm</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="c1"># Get RGB color for a wavelength of 600 nm</span>
<span class="n">rgb_color</span> <span class="o">=</span> <span class="n">custom_map</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

<span class="c1"># Generate a heatmap of colors for wavelengths from 380 nm to 799 nm</span>
<span class="n">heatmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">custom_map</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">20</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">380</span><span class="p">,</span> <span class="mi">800</span><span class="p">)]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.blue_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">blue_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.blue_map" title="Link to this definition">¶</a></dt>
<dd><p>Mapear una longitud de onda específica a un color RGB con tono azul.</p>
<p>Esta función toma una longitud de onda (en nanómetros) y devuelve los valores RGB correspondientes con un enfoque en generar un color azul. Utiliza un mapeo simple basado en la longitud de onda proporcionada y aplica una corrección gamma para ajustes de color más refinados.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int): La longitud de onda de la luz en nanómetros (nm). Este valor se mapea al valor RGB con tono azul.</p></li>
<li><p><cite>gamma</cite> (float, opcional): Un factor de corrección gamma aplicado al color RGB resultante. El valor predeterminado es <cite>1.0</cite>, lo que significa que no se aplica corrección gamma. Valores mayores que <cite>1.0</cite> aumentarán el brillo del color, mientras que valores menores que <cite>1.0</cite> lo oscurecerán.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite>: Una tupla que contiene los valores RGB (0-255) para el color con tono azul correspondiente a la longitud de onda dada.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the blue RGB color correspondi</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bluescale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bluescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bluescale" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un filtro de color azul a una imagen, transformándola en una versión con tono azul.</p>
<p>Esta función utiliza el rango de longitud de onda de 450 a 495 nm, que corresponde a la luz azul en el espectro visible, para convertir la imagen en varios tonos de azul.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de Pygame (imagen) que se transformará en tonos azules.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: Esta función modifica la superficie proporcionada in situ, por lo que no hay valor de retorno.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transform an image into shades of blue</span>
<span class="n">bluescale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.red_map">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">red_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.red_map" title="Link to this definition">¶</a></dt>
<dd><p>Devolver los componentes RGB correspondientes a una longitud de onda específica en el espectro rojo.</p>
<p>Esta función mapea una longitud de onda dada (en nm) a los valores RGB apropiados para la porción roja del espectro visible. Se puede utilizar para generar colores basados en rojo según una longitud de onda dada.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>wavelength</cite> (int): La longitud de onda en nanómetros (nm) para la cual se calculan los valores RGB correspondientes.</p></li>
<li><p><cite>gamma</cite> (float, opcional): Un valor de corrección gamma para ajustar el brillo de los colores. El valor predeterminado es <cite>1.0</cite> (sin corrección).</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>tuple</cite> (int, int, int): Una tupla de componentes RGB como enteros en el rango (0 … 255), correspondientes a la longitud de onda especificada.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the RGB color for a wavelength of 610 nm (Red color)</span>
<span class="n">rgb</span> <span class="o">=</span> <span class="n">red_map</span><span class="p">(</span><span class="mi">610</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.redscale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">redscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.redscale" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de escala de rojo a una imagen.</p>
<p>Este algoritmo mapea la imagen de entrada en tonos de rojo ajustando los canales de color según las longitudes de onda típicamente asociadas con la porción roja del espectro de luz visible, que va de 620 a 750 nm. El efecto de escala de rojo conserva las variaciones de intensidad del color rojo mientras reduce o elimina la influencia de otros canales de color.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame que representa la imagen que se transformará en escala de rojo. La superficie debe contener datos de píxeles RGB válidos.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>void</cite>: Esta función modifica la superficie de entrada directamente y no devuelve una nueva superficie.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply redscale effect to an image</span>
<span class="n">redscale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">display_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.dampening" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de amortiguación a una superficie.</p>
<p>Este efecto simula un escalado o reducción gradual de la superficie basado en una función de oscilación amortiguada. La duración del efecto está determinada por el producto de la duración y la frecuencia. La posición de la superficie se ajusta según su nuevo tamaño para mantener su posición centrada en la pantalla.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible con una profundidad de color de 24-32 bits.</p></li>
<li><p><cite>frame</cite> (int): El número de fotograma actual en la secuencia de animación. Este valor debe incrementarse con cada actualización de fotograma.</p></li>
<li><p><cite>display_width</cite> (int): El ancho de la ventana de visualización del juego.</p></li>
<li><p><cite>display_height</cite> (int): La altura de la ventana de visualización del juego.</p></li>
<li><p><cite>amplitude</cite> (float, opcional): La amplitud del efecto de amortiguación, que determina la cantidad máxima de escalado. El valor predeterminado es 50.0.</p></li>
<li><p><cite>duration</cite> (int, opcional): La duración del efecto, que controla cuánto tiempo dura el efecto en términos de fotogramas. El valor predeterminado es 30.</p></li>
<li><p><cite>freq</cite> (float, opcional): La frecuencia del efecto de amortiguación, que afecta la rapidez con la que oscila el escalado. Un valor más pequeño hará que el efecto dure más, mientras que un valor más grande lo acortará. El valor predeterminado es 20.0.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul>
<li><p>tuple: Una tupla que contiene:</p>
<blockquote>
<div><ul class="simple">
<li><p>Una nueva superficie de Pygame con el efecto de amortiguación aplicado.</p></li>
<li><p>La coordenada x de la nueva posición de la superficie (esquina superior izquierda).</p></li>
<li><p>La coordenada y de la nueva posición de la superficie (esquina superior izquierda).</p></li>
</ul>
<p>La superficie está centrada en el área de visualización.</p>
</div></blockquote>
</li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply dampening effect to a surface</span>
<span class="n">surf</span><span class="p">,</span> <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">dampening</span><span class="p">(</span><span class="n">BCK</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">SCREEN</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.lateral_dampening">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">lateral_dampening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amplitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.lateral_dampening" title="Link to this definition">¶</a></dt>
<dd><p>Aplicar un efecto de amortiguación lateral para producir un desplazamiento horizontal.</p>
<p>Este método calcula el desplazamiento lateral (coordenada x) basado en una función de oscilación amortiguada. El valor de desplazamiento oscila entre valores positivos y negativos, decayendo gradualmente según los parámetros de amplitud, frecuencia y duración.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>frame</cite> (int): El número de fotograma actual en la secuencia de animación. Este valor debe incrementarse con cada fotograma para producir una animación suave.</p></li>
<li><p><cite>amplitude</cite> (float, opcional): La amplitud del efecto de amortiguación lateral. Este valor controla el desplazamiento máximo de la superficie. Un valor más alto resulta en un movimiento horizontal más grande. El valor predeterminado es 50.0.</p></li>
<li><p><cite>duration</cite> (int, opcional): La duración total del efecto, en términos de fotogramas. Esto define cuánto tiempo durarán las oscilaciones. El valor predeterminado es 30 fotogramas.</p></li>
<li><p><cite>freq</cite> (float, opcional): La frecuencia de la oscilación amortiguada. Esto controla la rapidez con la que ocurren las oscilaciones. Un valor más bajo hace que el efecto tarde más en completarse (oscilación más lenta), mientras que un valor más alto acelera la oscilación. El valor predeterminado es 20.0.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p>float: El valor de desplazamiento lateral (x) que se puede utilizar para desplazar el objeto horizontalmente en la pantalla (por ejemplo, al blitear una imagen). El valor oscilará dentro de un rango determinado por la amplitud.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>: .. code-block:: python</p>
<blockquote>
<div><p># Aplicar efecto de amortiguación lateral a una superficie tm = lateral_dampening(frame, amplitude=50.0, duration=35, freq=5.0) SCREEN.blit(BCK, (tm, 0), special_flags=0)</p>
</div></blockquote>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>El desplazamiento sigue un modelo de oscilación amortiguada, donde el valor decae con el tiempo según los parámetros de frecuencia y duración.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending" title="Link to this definition">¶</a></dt>
<dd><p>Realizar mezcla alfa de dos imágenes de 32 bits.</p>
<p>Esta función mezcla dos imágenes de 32 bits, teniendo en cuenta sus canales alfa (transparencia). La imagen <cite>source</cite> se dibuja sobre la imagen <cite>destination</cite>. La mezcla utiliza el canal alfa para determinar cuán transparente es cada píxel en la imagen de origen.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>source</cite> (pygame.Surface): La imagen de origen que se mezclará con la imagen de destino. Debe ser una imagen de 32 bits con un canal alfa.</p></li>
<li><p><cite>destination</cite> (pygame.Surface): La imagen de destino sobre la cual se mezclará la imagen de origen. También debe ser una imagen de 32 bits con un canal alfa.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p>pygame.Surface: Una nueva superficie de Pygame de 32 bits con las dos imágenes mezcladas, basadas en sus valores alfa.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together using alpha blending</span>
<span class="n">new_image</span> <span class="o">=</span> <span class="n">alpha_blending</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>Esta función devuelve una nueva superficie y no modifica las imágenes originales <cite>source</cite> o <cite>destination</cite>.</p></li>
<li><p>Ambas imágenes deben tener un canal alfa para garantizar una mezcla adecuada de la transparencia.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.alpha_blending_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">alpha_blending_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.alpha_blending_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Realizar mezcla alfa en dos imágenes in situ.</p>
<p>Esta función mezcla dos imágenes con las mismas dimensiones, modificando la primera imagen (<cite>image1</cite>). La mezcla se realiza basándose en el canal alfa, donde la segunda imagen (<cite>image2</cite>) se mezcla en la primera imagen.</p>
<p>Ambas imágenes deben ser de 32 bits con un canal alfa y deben tener las mismas dimensiones. El proceso de mezcla utiliza los valores alfa de ambas imágenes para calcular la transparencia de los píxeles.</p>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>image1</cite> (pygame.Surface): La primera imagen que se mezclará con la segunda imagen. Debe ser una imagen de 32 bits con un canal alfa. Esta imagen se modifica in situ.</p></li>
<li><p><cite>image2</cite> (pygame.Surface): La segunda imagen que se mezclará en la primera imagen. También debe ser una imagen de 32 bits con un canal alfa.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p>None: Esta función modifica la primera imagen (<cite>image1</cite>) in situ y no devuelve una nueva superficie.</p></li>
</ul>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Blend two images together in-place</span>
<span class="n">alpha_blending_inplace</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>Esta función realiza la mezcla in situ, modificando la superficie <cite>image1</cite>.</p></li>
<li><p>Tanto <cite>image1</cite> como <cite>image2</cite> deben tener las mismas dimensiones e incluir un canal alfa.</p></li>
<li><p>Si alguna de las imágenes no tiene un canal alfa o tiene dimensiones no coincidentes, se lanzará una excepción.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.render_light_effect24">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">render_light_effect24</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">110</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.render_light_effect24" title="Link to this definition">¶</a></dt>
<dd><p>Genera un efecto de iluminación realista en una superficie o textura de Pygame.</p>
<p>Esta función simula un efecto de luz que puede mezclarse en una superficie usando mezcla aditiva (<cite>BLEND_RGBA_ADD</cite> en Pygame). El efecto se genera basado en una textura de máscara y puede incluir mejoras opcionales como bloom, ondas de calor y ajustes de saturación.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">render_light_effect24</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">background_rgb</span><span class="p">,</span>
    <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
    <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
    <span class="n">heat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">frequency</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>x</cite> (int): La coordenada X de la fuente de luz. Debe estar dentro del ancho de la pantalla.</p></li>
<li><p><cite>y</cite> (int): La coordenada Y de la fuente de luz. Debe estar dentro de la altura de la pantalla.</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, forma (w, h, 3), dtype uint8): Un array 3D de NumPy que representa los valores RGB de la superficie de fondo.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, forma (w, h), dtype uint8): Un array 2D de NumPy que contiene los valores alfa (transparencia) de la máscara de luz. Se recomienda usar una máscara de gradiente radial con intensidad máxima en el centro.</p></li>
<li><p><cite>intensity</cite> (float, opcional, predeterminado=1.0): Intensidad de la luz en el rango [0.0, 20.0]. Valores más altos producen un efecto más fuerte.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, opcional, predeterminado=[128.0, 128.0, 128.0]): Un array de 3 elementos de NumPy que representa el color RGB de la luz en formato float (valores en el rango [0.0, 255.0]).</p></li>
<li><p><cite>smooth</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, aplica un efecto de desenfoque para suavizar la iluminación.</p></li>
<li><p><cite>saturation</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, aplica un efecto de saturación para mejorar la vibración del color.</p></li>
<li><p><cite>sat_value</cite> (float, opcional, predeterminado=0.2): Ajusta el nivel de saturación. El rango válido es [-1.0, 1.0].</p></li>
<li><p><cite>bloom</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, habilita un efecto de bloom, que mejora el brillo de las áreas intensas.</p></li>
<li><p><cite>threshold</cite> (int, opcional, predeterminado=110): El umbral de brillo utilizado en el efecto de bloom. Los píxeles por encima de este valor contribuyen al bloom.</p></li>
<li><p><cite>heat</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, aplica un efecto de onda de calor que distorsiona la iluminación dinámicamente.</p></li>
<li><p><cite>frequency</cite> (float, opcional, predeterminado=1): Determina la frecuencia del efecto de onda de calor. Debe ser un valor creciente.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul>
<li><p><cite>tuple</cite>: Una tupla que contiene:</p>
<blockquote>
<div><ul class="simple">
<li><p>Una superficie de Pygame de 24 bits que representa el efecto de luz generado.</p></li>
<li><p>El ancho de la superficie (<cite>sw</cite>).</p></li>
<li><p>La altura de la superficie (<cite>sh</cite>).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La superficie de salida no contiene información alfa por píxel.</p></li>
<li><p>Use <cite>BLEND_RGBA_ADD</cite> al blitear la superficie para lograr un efecto de iluminación aditiva.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.bloom_effect_array24_c2">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">bloom_effect_array24_c2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.bloom_effect_array24_c2" title="Link to this definition">¶</a></dt>
<dd><p>Crea un efecto de bloom en una superficie de Pygame (superficie compatible de 24 bits).</p>
<p><strong>Definición</strong>:</p>
<p>Bloom es un efecto de gráficos por computadora utilizado en videojuegos, demos y renderizado de alto rango dinámico para reproducir un artefacto de imagen de cámaras del mundo real. El efecto simula áreas brillantes de una imagen que brillan y se extienden a áreas adyacentes, mejorando la iluminación y la calidad visual de la escena.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/px.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;../Assets/alpha.png&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">smoothscale</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>

<span class="c1"># In the main loop</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">bloom_effect_array24_c2</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame en formato de 24 bits sobre la cual se aplicará el efecto de bloom.</p></li>
<li><p><cite>threshold_</cite> (unsigned char): Valor de umbral utilizado por el algoritmo de paso brillante. El valor predeterminado es 128 y determina qué píxeles se consideran «lo suficientemente brillantes» para contribuir al efecto de bloom.</p></li>
<li><p><cite>smooth_</cite> (int, opcional, predeterminado=1): El número de iteraciones de desenfoque gaussiano (5x5) para aplicar a las imágenes reducidas. Aumentar este valor creará un efecto de suavizado más fuerte.</p></li>
<li><p><cite>mask_</cite> (pygame.Surface, opcional, predeterminado=None): Una superficie de Pygame que representa el alfa de la máscara. Los valores alfa en esta máscara determinan cuánto de la superficie debe verse afectado por el efecto de bloom. Los valores alfa de 255 renderizarán y aplicarán bloom a la imagen por completo, mientras que cero ocultará los píxeles correspondientes.</p></li>
<li><p><cite>fast_</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, acelera el proceso de bloom utilizando una superficie 16x y un filtro de paso brillante optimizado, lo que implica reducir el tamaño de la textura en un factor de 4 antes del procesamiento.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<ul class="simple">
<li><p><cite>pygame.Surface</cite>: Una nueva superficie de Pygame con el efecto de bloom aplicado (superficie de 24 bits).</p></li>
</ul>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La función aplica un efecto de bloom realizando primero un paso brillante en la imagen, luego aplicando un desenfoque gaussiano y mezclando el resultado con la superficie original.</p></li>
<li><p>El parámetro <cite>mask_</cite> se puede utilizar para controlar qué partes de la imagen tendrán bloom basado en los valores alfa.</p></li>
<li><p>El parámetro <cite>fast_</cite> permite una versión más rápida, aunque de menor calidad, del efecto de bloom.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.area24_cc">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">area24_cc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">numpy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=numpy.float32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">saturation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sat_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.area24_cc" title="Link to this definition">¶</a></dt>
<dd><p>Genera un efecto de iluminación realista en una superficie o textura de Pygame.</p>
<p>Esta función simula un efecto de luz que puede mezclarse en una superficie usando mezcla aditiva (<cite>BLEND_RGBA_ADD</cite> en Pygame). Soporta mejoras opcionales como bloom, suavizado y ajustes de saturación.</p>
<p><strong>Modos de iluminación</strong>: – - <strong>Smooth</strong>: Aplica un desenfoque gaussiano con un núcleo 5x5 para suavizar el efecto de iluminación. - <strong>Saturation</strong>: Ajusta la intensidad del color usando conversión de color HSL. Se admite un rango de valores de [-1.0, 1.0], donde valores más altos aumentan la vibración y valores por debajo de cero desaturan la salida. - <strong>Bloom</strong>: Mejora el brillo aplicando un efecto de bloom, haciendo que las áreas brillantes aparezcan más intensas.</p>
<p><strong>Parámetros de iluminación</strong>: - - <strong>Intensity</strong>: Define el brillo de la luz. Si se establece en cero, la función devuelve una <cite>pygame.Surface</cite> vacía con la bandera <cite>RLEACCEL</cite>. - <strong>Color</strong>: Especifica la coloración RGB de la luz. Por defecto es (128, 128, 128).</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lit_surface</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span> <span class="o">=</span> <span class="n">area24_cc</span><span class="p">(</span>
    <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MOUSE_POS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">background_rgb</span><span class="p">,</span> <span class="n">lalpha</span><span class="p">,</span>
    <span class="n">intensity</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sat_value</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bloom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bloom_threshold</span><span class="o">=</span><span class="mi">0</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>x</cite> (int): Coordenada X de la fuente de luz (debe estar dentro del ancho de la pantalla).</p></li>
<li><p><cite>y</cite> (int): Coordenada Y de la fuente de luz (debe estar dentro de la altura de la pantalla).</p></li>
<li><p><cite>background_rgb</cite> (numpy.ndarray, forma (w, h, 3), dtype uint8): Un array 3D de NumPy que representa los valores RGB de la superficie de fondo.</p></li>
<li><p><cite>mask_alpha</cite> (numpy.ndarray, forma (w, h), dtype uint8): Un array 2D de NumPy que contiene los valores alfa de la máscara de luz. Se recomienda usar una máscara de gradiente radial con intensidad máxima en el centro.</p></li>
<li><p><cite>color</cite> (numpy.ndarray, opcional, predeterminado=[128.0, 128.0, 128.0]): Un array de 3 elementos de NumPy que representa el color RGB de la luz en formato float (valores en el rango [0.0, 255.0]).</p></li>
<li><p><cite>intensity</cite> (float, opcional, predeterminado=1.0): Intensidad de la luz en el rango [0.0, 20.0]. Valores más altos producen un efecto más fuerte.</p></li>
<li><p><cite>smooth</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, aplica un efecto de desenfoque para suavizar la iluminación.</p></li>
<li><p><cite>saturation</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, aumenta la intensidad del color usando conversión HSL.</p></li>
<li><p><cite>sat_value</cite> (float, opcional, predeterminado=0.2): Ajusta el nivel de saturación. El rango válido es [-1.0, 1.0]. Valores más altos aumentan la vibración, mientras que valores negativos desaturan el efecto.</p></li>
<li><p><cite>bloom</cite> (bool, opcional, predeterminado=False): Si es <cite>True</cite>, habilita un efecto de bloom, mejorando el brillo.</p></li>
<li><p><cite>bloom_threshold</cite> (unsigned char, opcional, predeterminado=64): El umbral de brillo para el efecto de bloom, en el rango [0, 255]. Valores más bajos crean un efecto de bloom más fuerte.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>tuple:</dt><dd><p>Una tupla que contiene: - Una superficie de Pygame de 24 bits que representa el efecto de luz generado. - El ancho de la superficie (<cite>sw</cite>). - La altura de la superficie (<cite>sh</cite>).</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La superficie de salida no contiene información alfa por píxel.</p></li>
<li><p>Use <cite>BLEND_RGBA_ADD</cite> al blitear la superficie para lograr un efecto de iluminación aditiva.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic" title="Link to this definition">¶</a></dt>
<dd><p>Aberración cromática (devuelve una nueva superficie).</p>
<p>Esta función aplica un efecto de aberración cromática a una superficie dada. La amplitud del efecto es proporcional a la distancia desde el centro del efecto, creando una distorsión en los canales de color RGB. El efecto de aberración cromática simula el cambio de color que ocurre debido a imperfecciones ópticas en las lentes.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">chromatic</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible de 24 o 32 bits a la que se aplicará el efecto de aberración cromática.</p></li>
<li><p><cite>delta_x</cite> (unsigned int): La coordenada X del centro del efecto cromático. Este valor debe estar dentro del rango [0, ancho de la superficie].</p></li>
<li><p><cite>delta_y</cite> (unsigned int): La coordenada Y del centro del efecto cromático. Este valor debe estar dentro del rango [0, altura de la superficie].</p></li>
<li><p><cite>zoom</cite> (float, opcional, predeterminado=0.9999): El factor de zoom para el efecto. Un valor de 0.9999 significa sin zoom (imagen completa), mientras que un valor menor que 1.0 hará zoom. Debe estar en el rango [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, opcional, predeterminado=0.02): El desplazamiento aplicado a los canales RGB. Este valor determina la intensidad del efecto de aberración cromática y debe estar en el rango [0.0, 0.2].</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>Una nueva superficie de Pygame con el efecto de aberración cromática aplicado.</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La función devuelve una nueva superficie con el efecto de aberración cromática aplicado.</p></li>
<li><p>Los parámetros <cite>delta_x</cite> y <cite>delta_y</cite> definen el punto en el que se centra el efecto cromático, y la distorsión se vuelve más pronunciada a medida que aumenta la distancia desde este punto.</p></li>
<li><p>Los parámetros <cite>zoom</cite> y <cite>fx</cite> controlan la extensión y la intensidad del efecto, respectivamente.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.chromatic_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">chromatic_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.02</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.chromatic_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Aberración cromática (in situ).</p>
<p>Esta función aplica un efecto de aberración cromática a una superficie dada in situ. La amplitud del efecto es proporcional a la distancia desde el centro del efecto. A diferencia de la función <cite>chromatic</cite>, esta función modifica la superficie original en lugar de devolver una nueva superficie. Simula el efecto óptico de distorsión de color que se observa típicamente debido a imperfecciones en las lentes.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">chromatic_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="n">fx</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): Una superficie de Pygame compatible de 24 o 32 bits a la que se aplicará el efecto de aberración cromática in situ.</p></li>
<li><p><cite>delta_x</cite> (unsigned int): La coordenada X del centro del efecto cromático. Este valor debe estar dentro del rango [0, ancho de la superficie].</p></li>
<li><p><cite>delta_y</cite> (unsigned int): La coordenada Y del centro del efecto cromático. Este valor debe estar dentro del rango [0, altura de la superficie].</p></li>
<li><p><cite>zoom</cite> (float, opcional, predeterminado=0.9999): El factor de zoom para el efecto. Un valor de 0.9999 significa sin zoom (imagen completa), mientras que un valor menor que 1.0 hará zoom. Debe estar en el rango [0.0, 0.9999].</p></li>
<li><p><cite>fx</cite> (float, opcional, predeterminado=0.02): El desplazamiento aplicado a los canales RGB. Este valor determina la intensidad del efecto de aberración cromática y debe estar en el rango [0.0, 0.2].</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>La misma superficie de Pygame con el efecto de aberración cromática aplicado in situ.</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La función modifica la superficie original en lugar de devolver una nueva.</p></li>
<li><p>Los parámetros <cite>delta_x</cite> y <cite>delta_y</cite> definen el punto en el que se centra el efecto cromático. El efecto se vuelve más pronunciado cuanto más lejos esté el píxel de este punto central.</p></li>
<li><p>Los parámetros <cite>zoom</cite> y <cite>fx</cite> controlan la extensión y la intensidad del efecto de aberración cromática.</p></li>
<li><p>Esta función es útil cuando se desea aplicar el efecto de aberración cromática directamente a una superficie sin necesidad de crear una nueva superficie.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom" title="Link to this definition">¶</a></dt>
<dd><p>Zoom dentro de una imagen (devuelve una copia).</p>
<p>Esta función hace zoom dentro o fuera de una imagen hacia un punto central dado (delta_x, delta_y) usando un factor de zoom especificado (zx). La función admite formatos de imagen de 24 y 32 bits, y la imagen de salida tendrá el mismo formato que la entrada. El efecto de zoom es más eficiente en imágenes de 24 bits.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">surf</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de Pygame sobre la cual aplicar el efecto de zoom. Puede ser una superficie compatible de 24 o 32 bits.</p></li>
<li><p><cite>delta_x</cite> (unsigned int): La coordenada X del centro del zoom. Este valor debe estar dentro del rango [0, ancho de la superficie].</p></li>
<li><p><cite>delta_y</cite> (unsigned int): La coordenada Y del centro del zoom. Este valor debe estar dentro del rango [0, altura de la superficie].</p></li>
<li><p><cite>zx</cite> (float, opcional, predeterminado=0.9999): El factor de zoom. Este valor debe estar en el rango (0.0, 1.0). Un valor de 1.0 resultará en ningún zoom (imagen completa), mientras que valores más cercanos a 0.0 harán zoom. La intensidad del zoom se atenúa alrededor de 1.0, con el máximo efecto de zoom ocurriendo cuando zx se acerca a 0.0.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>pygame.Surface:</dt><dd><p>Una nueva superficie de Pygame con el efecto de zoom aplicado. La imagen de salida tendrá el mismo formato (24 o 32 bits) que la imagen de entrada.</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>El efecto de zoom se centra alrededor del punto especificado por <cite>delta_x</cite> y <cite>delta_y</cite>. Los píxeles más cercanos a este centro aparecerán menos ampliados, mientras que los más alejados experimentarán un zoom más pronunciado.</p></li>
<li><p>Esta función devuelve una nueva superficie con el efecto de zoom aplicado, dejando la superficie original sin cambios.</p></li>
<li><p>El rendimiento es generalmente mejor con imágenes de 24 bits debido a menos canales de datos para procesar.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.zoom_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">zoom_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9999</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.zoom_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Zoom dentro de una imagen (in situ).</p>
<p>Esta función hace zoom dentro o fuera de una imagen hacia un punto central dado (delta_x, delta_y) usando un factor de zoom especificado (zx), modificando la imagen in situ. La función admite formatos de imagen de 24 y 32 bits, y el formato de la imagen de entrada permanece sin cambios durante el proceso.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">zoom_inplace</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">MOUSE_POS</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de Pygame sobre la cual aplicar el efecto de zoom. Puede ser una superficie compatible de 24 o 32 bits.</p></li>
<li><p><cite>delta_x</cite> (unsigned int): La coordenada X del centro del zoom. Este valor debe estar dentro del rango [0, ancho de la superficie].</p></li>
<li><p><cite>delta_y</cite> (unsigned int): La coordenada Y del centro del zoom. Este valor debe estar dentro del rango [0, altura de la superficie].</p></li>
<li><p><cite>zx</cite> (float, opcional, predeterminado=0.9999): El factor de zoom. Este valor debe estar en el rango (0.0, 1.0). Un valor de 1.0 resultará en ningún zoom (imagen completa), mientras que valores más cercanos a 0.0 harán zoom. El efecto de zoom se atenúa alrededor de 1.0, con el máximo efecto de zoom ocurriendo cuando zx se acerca a 0.0.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>None:</dt><dd><p>Esta función modifica la <cite>surface_</cite> in situ. No devuelve una nueva superficie.</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>El efecto de zoom se centra alrededor del punto especificado por <cite>delta_x</cite> y <cite>delta_y</cite>. Los píxeles más cercanos a este centro aparecerán menos ampliados, mientras que los más alejados experimentarán un zoom más pronunciado.</p></li>
<li><p>Esta función modifica la superficie de entrada directamente, sin crear una nueva.</p></li>
<li><p>El rendimiento es generalmente mejor con imágenes de 24 bits debido a menos canales de datos para procesar.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader.Luma_GreyScale">
<span class="sig-prename descclassname"><span class="pre">Shader.</span></span><span class="sig-name descname"><span class="pre">Luma_GreyScale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader.Luma_GreyScale" title="Link to this definition">¶</a></dt>
<dd><p>Convertir imagen a escala de grises usando YIQ (información de luminancia).</p>
<p>Esta función convierte la imagen proporcionada en una imagen en escala de grises utilizando el modelo de color YIQ, que se centra en la información de luminancia (brillo). La función modifica la imagen de entrada in situ.</p>
<p><strong>Ejemplo de uso</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Luma_GreyScale</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parámetros</strong>:</p>
<ul class="simple">
<li><p><cite>surface_</cite> (pygame.Surface): La superficie de Pygame que se convertirá a escala de grises. Esta superficie puede estar en cualquier formato de color compatible con Pygame.</p></li>
</ul>
<p><strong>Retorna</strong>:</p>
<dl class="simple">
<dt>None:</dt><dd><p>La función modifica la <cite>surface_</cite> de entrada in situ, convirtiéndola a escala de grises. No devuelve una nueva superficie.</p>
</dd>
</dl>
<p><strong>Notas</strong>:</p>
<ul class="simple">
<li><p>La conversión utiliza el modelo de color YIQ, específicamente el componente de luminancia (Y), que representa el brillo de la imagen.</p></li>
<li><p>La superficie de entrada se modifica directamente y no se devuelve una nueva superficie.</p></li>
</ul>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader</a><ul>
<li><a class="reference internal" href="#high-performance-image-processing-library">1. Biblioteca de Procesamiento de Imágenes de Alto Rendimiento</a></li>
<li><a class="reference internal" href="#key-features">2. Características Clave</a></li>
<li><a class="reference internal" href="#library-functional-overview">3. Resumen Funcional de la Biblioteca</a></li>
<li><a class="reference internal" href="#target-applications">4. Aplicaciones Objetivo</a></li>
<li><a class="reference internal" href="#summary">5. Resumen</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Métodos de listas en Cython</a><ul>
<li><a class="reference internal" href="#Shader.bgr"><code class="docutils literal notranslate"><span class="pre">bgr()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_copy"><code class="docutils literal notranslate"><span class="pre">bgr_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_3d"><code class="docutils literal notranslate"><span class="pre">bgr_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d"><code class="docutils literal notranslate"><span class="pre">bgr_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bgr_1d_cp"><code class="docutils literal notranslate"><span class="pre">bgr_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg"><code class="docutils literal notranslate"><span class="pre">brg()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_copy"><code class="docutils literal notranslate"><span class="pre">brg_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_3d"><code class="docutils literal notranslate"><span class="pre">brg_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d"><code class="docutils literal notranslate"><span class="pre">brg_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brg_1d_cp"><code class="docutils literal notranslate"><span class="pre">brg_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey"><code class="docutils literal notranslate"><span class="pre">grey()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_copy"><code class="docutils literal notranslate"><span class="pre">grey_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_2d"><code class="docutils literal notranslate"><span class="pre">grey_2d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_3d"><code class="docutils literal notranslate"><span class="pre">grey_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d"><code class="docutils literal notranslate"><span class="pre">grey_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.grey_1d_cp"><code class="docutils literal notranslate"><span class="pre">grey_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia"><code class="docutils literal notranslate"><span class="pre">sepia()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_copy"><code class="docutils literal notranslate"><span class="pre">sepia_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_3d"><code class="docutils literal notranslate"><span class="pre">sepia_3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sepia_1d"><code class="docutils literal notranslate"><span class="pre">sepia_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median"><code class="docutils literal notranslate"><span class="pre">median()</span></code></a></li>
<li><a class="reference internal" href="#Shader.painting"><code class="docutils literal notranslate"><span class="pre">painting()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixels"><code class="docutils literal notranslate"><span class="pre">pixels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.median_grayscale"><code class="docutils literal notranslate"><span class="pre">median_grayscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.posterize_surface"><code class="docutils literal notranslate"><span class="pre">posterize_surface()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel"><code class="docutils literal notranslate"><span class="pre">sobel()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_1d"><code class="docutils literal notranslate"><span class="pre">sobel_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sobel_fast"><code class="docutils literal notranslate"><span class="pre">sobel_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert"><code class="docutils literal notranslate"><span class="pre">invert()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert_copy"><code class="docutils literal notranslate"><span class="pre">invert_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert3d"><code class="docutils literal notranslate"><span class="pre">invert3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d"><code class="docutils literal notranslate"><span class="pre">invert1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.invert1d_cp"><code class="docutils literal notranslate"><span class="pre">invert1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl_effect"><code class="docutils literal notranslate"><span class="pre">hsl_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl3d"><code class="docutils literal notranslate"><span class="pre">hsl3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d"><code class="docutils literal notranslate"><span class="pre">hsl1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsl1d_cp"><code class="docutils literal notranslate"><span class="pre">hsl1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv_effect"><code class="docutils literal notranslate"><span class="pre">hsv_effect()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv3d"><code class="docutils literal notranslate"><span class="pre">hsv3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d"><code class="docutils literal notranslate"><span class="pre">hsv1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.hsv1d_cp"><code class="docutils literal notranslate"><span class="pre">hsv1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave"><code class="docutils literal notranslate"><span class="pre">wave()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave32"><code class="docutils literal notranslate"><span class="pre">wave32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wave_static"><code class="docutils literal notranslate"><span class="pre">wave_static()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl"><code class="docutils literal notranslate"><span class="pre">swirl()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirl32"><code class="docutils literal notranslate"><span class="pre">swirl32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.swirlf"><code class="docutils literal notranslate"><span class="pre">swirlf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma_config"><code class="docutils literal notranslate"><span class="pre">plasma_config()</span></code></a></li>
<li><a class="reference internal" href="#Shader.plasma"><code class="docutils literal notranslate"><span class="pre">plasma()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness"><code class="docutils literal notranslate"><span class="pre">brightness()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness3d"><code class="docutils literal notranslate"><span class="pre">brightness3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d"><code class="docutils literal notranslate"><span class="pre">brightness1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness1d_copy"><code class="docutils literal notranslate"><span class="pre">brightness1d_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_copy"><code class="docutils literal notranslate"><span class="pre">brightness_copy()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_exclude"><code class="docutils literal notranslate"><span class="pre">brightness_exclude()</span></code></a></li>
<li><a class="reference internal" href="#Shader.brightness_bpf"><code class="docutils literal notranslate"><span class="pre">brightness_bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation"><code class="docutils literal notranslate"><span class="pre">saturation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation3d"><code class="docutils literal notranslate"><span class="pre">saturation3d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d"><code class="docutils literal notranslate"><span class="pre">saturation1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.saturation1d_cp"><code class="docutils literal notranslate"><span class="pre">saturation1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatconvection"><code class="docutils literal notranslate"><span class="pre">heatconvection()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_glitch"><code class="docutils literal notranslate"><span class="pre">horizontal_glitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.horizontal_sglitch"><code class="docutils literal notranslate"><span class="pre">horizontal_sglitch()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bpf"><code class="docutils literal notranslate"><span class="pre">bpf()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom"><code class="docutils literal notranslate"><span class="pre">bloom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye_footprint_param"><code class="docutils literal notranslate"><span class="pre">fisheye_footprint_param()</span></code></a></li>
<li><a class="reference internal" href="#Shader.fisheye"><code class="docutils literal notranslate"><span class="pre">fisheye()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tv_scan"><code class="docutils literal notranslate"><span class="pre">tv_scan()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple"><code class="docutils literal notranslate"><span class="pre">ripple()</span></code></a></li>
<li><a class="reference internal" href="#Shader.ripple_seabed"><code class="docutils literal notranslate"><span class="pre">ripple_seabed()</span></code></a></li>
<li><a class="reference internal" href="#Shader.heatmap"><code class="docutils literal notranslate"><span class="pre">heatmap()</span></code></a></li>
<li><a class="reference internal" href="#Shader.predator_vision"><code class="docutils literal notranslate"><span class="pre">predator_vision()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blood"><code class="docutils literal notranslate"><span class="pre">blood()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring_array"><code class="docutils literal notranslate"><span class="pre">mirroring_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader.mirroring"><code class="docutils literal notranslate"><span class="pre">mirroring()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen"><code class="docutils literal notranslate"><span class="pre">sharpen()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d"><code class="docutils literal notranslate"><span class="pre">sharpen_1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen_1d_cp"><code class="docutils literal notranslate"><span class="pre">sharpen_1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.sharpen32"><code class="docutils literal notranslate"><span class="pre">sharpen32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dirt_lens"><code class="docutils literal notranslate"><span class="pre">dirt_lens()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering"><code class="docutils literal notranslate"><span class="pre">dithering()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_inplace"><code class="docutils literal notranslate"><span class="pre">dithering_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d"><code class="docutils literal notranslate"><span class="pre">dithering1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering1d_cp"><code class="docutils literal notranslate"><span class="pre">dithering1d_cp()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dithering_atkinson1d"><code class="docutils literal notranslate"><span class="pre">dithering_atkinson1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.pixelation"><code class="docutils literal notranslate"><span class="pre">pixelation()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend"><code class="docutils literal notranslate"><span class="pre">blend()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend1d"><code class="docutils literal notranslate"><span class="pre">blend1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blend_inplace"><code class="docutils literal notranslate"><span class="pre">blend_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.cartoon"><code class="docutils literal notranslate"><span class="pre">cartoon()</span></code></a></li>
<li><a class="reference internal" href="#Shader.convert_27"><code class="docutils literal notranslate"><span class="pre">convert_27()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilateral"><code class="docutils literal notranslate"><span class="pre">bilateral()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss"><code class="docutils literal notranslate"><span class="pre">emboss()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_inplace"><code class="docutils literal notranslate"><span class="pre">emboss_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss1d"><code class="docutils literal notranslate"><span class="pre">emboss1d()</span></code></a></li>
<li><a class="reference internal" href="#Shader.emboss_gray"><code class="docutils literal notranslate"><span class="pre">emboss_gray()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bilinear"><code class="docutils literal notranslate"><span class="pre">bilinear()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling24"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render24"><code class="docutils literal notranslate"><span class="pre">tunnel_render24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_modeling32"><code class="docutils literal notranslate"><span class="pre">tunnel_modeling32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.tunnel_render32"><code class="docutils literal notranslate"><span class="pre">tunnel_render32()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast()</span></code></a></li>
<li><a class="reference internal" href="#Shader.shader_bloom_fast1"><code class="docutils literal notranslate"><span class="pre">shader_bloom_fast1()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels"><code class="docutils literal notranslate"><span class="pre">split_channels()</span></code></a></li>
<li><a class="reference internal" href="#Shader.split_channels_inplace"><code class="docutils literal notranslate"><span class="pre">split_channels_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.wavelength2rgb"><code class="docutils literal notranslate"><span class="pre">wavelength2rgb()</span></code></a></li>
<li><a class="reference internal" href="#Shader.custom_map"><code class="docutils literal notranslate"><span class="pre">custom_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.blue_map"><code class="docutils literal notranslate"><span class="pre">blue_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bluescale"><code class="docutils literal notranslate"><span class="pre">bluescale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.red_map"><code class="docutils literal notranslate"><span class="pre">red_map()</span></code></a></li>
<li><a class="reference internal" href="#Shader.redscale"><code class="docutils literal notranslate"><span class="pre">redscale()</span></code></a></li>
<li><a class="reference internal" href="#Shader.dampening"><code class="docutils literal notranslate"><span class="pre">dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.lateral_dampening"><code class="docutils literal notranslate"><span class="pre">lateral_dampening()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending"><code class="docutils literal notranslate"><span class="pre">alpha_blending()</span></code></a></li>
<li><a class="reference internal" href="#Shader.alpha_blending_inplace"><code class="docutils literal notranslate"><span class="pre">alpha_blending_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.render_light_effect24"><code class="docutils literal notranslate"><span class="pre">render_light_effect24()</span></code></a></li>
<li><a class="reference internal" href="#Shader.bloom_effect_array24_c2"><code class="docutils literal notranslate"><span class="pre">bloom_effect_array24_c2()</span></code></a></li>
<li><a class="reference internal" href="#Shader.area24_cc"><code class="docutils literal notranslate"><span class="pre">area24_cc()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic"><code class="docutils literal notranslate"><span class="pre">chromatic()</span></code></a></li>
<li><a class="reference internal" href="#Shader.chromatic_inplace"><code class="docutils literal notranslate"><span class="pre">chromatic_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom"><code class="docutils literal notranslate"><span class="pre">zoom()</span></code></a></li>
<li><a class="reference internal" href="#Shader.zoom_inplace"><code class="docutils literal notranslate"><span class="pre">zoom_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader.Luma_GreyScale"><code class="docutils literal notranslate"><span class="pre">Luma_GreyScale()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="index.html"
                          title="capítulo anterior">¡Bienvenido a la documentación de PygameShader!</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="Shader_gpu.html"
                          title="próximo capítulo">Shader_gpu</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="Shader_gpu.html" title="Shader_gpu"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="index.html" title="¡Bienvenido a la documentación de PygameShader!"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentación de PygameShader - 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>