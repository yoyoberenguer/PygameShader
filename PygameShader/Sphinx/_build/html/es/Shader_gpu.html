
<!DOCTYPE html>

<html lang="es" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Shader_gpu &#8212; documentación de PygameShader - 1.0.11</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="_static/bizstyle.css?v=5283bb3d" />
    
    <script src="_static/documentation_options.js?v=28946ee5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=f85f4cfb"></script>
    <script src="_static/bizstyle.js"></script>
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Búsqueda" href="search.html" />
    <link rel="next" title="PygameTools" href="PygameTools.html" />
    <link rel="prev" title="Sombreado" href="Shader.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Sombreado"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentación de PygameShader - 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="shader-gpu">
<h1>Shader_gpu<a class="headerlink" href="#shader-gpu" title="Link to this heading">¶</a></h1>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">Shader_gpu.pyx</span></code></p>
<hr class="docutils" />
<section id="gpu-accelerated-image-processing-library">
<span id="gpu-image-processing-summary"></span><h2>1. Biblioteca de Procesamiento de Imágenes Acelerada por GPU<a class="headerlink" href="#gpu-accelerated-image-processing-library" title="Link to this heading">¶</a></h2>
<p>Esta biblioteca proporciona funcionalidad de procesamiento de imágenes acelerada por GPU utilizando <strong>CUDA</strong> (a través de <strong>CuPy</strong>) para realizar eficientemente diversas transformaciones y filtros de imágenes en <strong>GPUs NVIDIA</strong>. Su propósito principal es acelerar operaciones de procesamiento de imágenes computacionalmente costosas que de otro modo serían lentas en una CPU.</p>
</section>
<section id="key-features-use-cases">
<h2>2. Características Clave y Casos de Uso<a class="headerlink" href="#key-features-use-cases" title="Link to this heading">¶</a></h2>
<p><strong>Memoria GPU e Información de Hardware</strong>: Recupera detalles sobre la memoria GPU disponible, el ID del bus PCI y la capacidad de cálculo. <strong>Caso de Uso</strong>: Útil para gestionar dinámicamente la asignación de memoria y optimizar tareas de procesamiento en paralelo.</p>
<dl class="simple">
<dt><strong>Procesamiento de Imágenes y Filtros</strong></dt><dd><p>Realiza filtros de imagen comunes de manera eficiente en la GPU, incluyendo:</p>
</dd>
</dl>
<ul class="simple">
<li><p><strong>Inversión</strong>: <code class="xref py py-func docutils literal notranslate"><span class="pre">invert_gpu()</span></code></p></li>
<li><p><strong>Escala de Grises y Sepia</strong>: <code class="xref py py-func docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></p></li>
<li><p><strong>Detección de Bordes</strong>: Sobel, Prewitt, Canny</p></li>
<li><p><strong>Filtros de Desenfoque y Suavizado</strong>: Gaussiano, Mediana, Bilateral</p></li>
<li><p><strong>Relieve y Enfoque</strong></p></li>
</ul>
</section>
<section id="use-case">
<h2>3. Caso de Uso<a class="headerlink" href="#use-case" title="Link to this heading">¶</a></h2>
<blockquote>
<div><p>Optimizado para el procesamiento de video e imágenes en tiempo real ejecutando estas operaciones en paralelo en la GPU.</p>
</div></blockquote>
<p><strong>Manipulación y Mejoras de Color</strong>: Ajusta propiedades de la imagen como brillo, contraste, saturación y valores HSL/HSV.</p>
<p><strong>Caso de Uso</strong>: Ideal para mejora de imágenes, aplicaciones de realidad aumentada (AR) y software de edición de fotos.</p>
<p><strong>Efectos Especiales y Transformaciones</strong>: Aplica transformaciones y efectos artísticos, incluyendo:</p>
<ul class="simple">
<li><p><strong>Efectos de Remolino, Ojo de Pez, Onda y Ondulación</strong></p></li>
<li><p><strong>Aberración Cromática y División RGB</strong></p></li>
<li><p><strong>Efecto de Dibujo Animado y Filtros Bloom</strong></p></li>
<li><p><strong>Efectos de Difuminado y Mapas de Calor</strong></p></li>
</ul>
<p><strong>Caso de Uso</strong>: Útil para desarrollo de juegos, efectos visuales (VFX) y aplicaciones de gráficos por computadora.</p>
<p><strong>Transformaciones Geométricas</strong>: Soporte para transformaciones geométricas como:</p>
<ul class="simple">
<li><p><strong>Reflejo</strong></p></li>
<li><p><strong>Zoom</strong></p></li>
<li><p><strong>Reducción de Escala</strong></p></li>
<li><p><strong>Mezcla</strong></p></li>
</ul>
<p><strong>Caso de Uso</strong>: Puede usarse para compresión de imágenes, mapeo de texturas y renderizado en tiempo real.</p>
<p><strong>Procesamiento de Video en Tiempo Real</strong>: Los efectos de video en tiempo real son soportados por funciones como <code class="xref py py-func docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">predator_gpu()</span></code> y <code class="xref py py-func docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code>.</p>
<p><strong>Caso de Uso</strong>: Ideal para integración en software de transmisión, filtros de video o sistemas de vigilancia.</p>
</section>
<section id="potential-applications">
<h2>4. Aplicaciones Potenciales<a class="headerlink" href="#potential-applications" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Procesamiento de Imágenes y Video en Tiempo Real</strong>: Mejora las transmisiones de cámara en tiempo real.</p></li>
<li><p><strong>Visión por Computadora y Preprocesamiento para IA</strong>: Aplica filtros rápidos antes de pasar imágenes a modelos de aprendizaje automático.</p></li>
<li><p><strong>Desarrollo de Juegos y Gráficos</strong>: Añade efectos especiales para entornos de juegos y simulaciones.</p></li>
<li><p><strong>Realidad Aumentada y Virtual (AR/VR)</strong>: Optimiza los gráficos para experiencias inmersivas.</p></li>
<li><p><strong>Herramientas de Fotografía de Alto Rendimiento</strong>: Edita imágenes grandes de manera eficiente utilizando la GPU.</p></li>
</ul>
</section>
<section id="summary">
<h2>5. Resumen<a class="headerlink" href="#summary" title="Link to this heading">¶</a></h2>
<p>Esta biblioteca descarga tareas complejas de procesamiento de imágenes de la CPU a la GPU, haciendo que las operaciones sean significativamente más rápidas y eficientes. Es ideal para aplicaciones que requieren rendimiento en tiempo real, como juegos, AR/VR, transmisión de video y procesamiento de imágenes basado en IA.</p>
</section>
<section id="cython-list-methods">
<h2>6. Métodos de listas en Cython<a class="headerlink" href="#cython-list-methods" title="Link to this heading">¶</a></h2>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_free_mem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_free_mem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_free_mem" title="Link to this definition">¶</a></dt>
<dd><p>Recupera la memoria libre disponible en la GPU.</p>
<p>Esta función consulta el dispositivo GPU para obtener su memoria libre actual y devuelve la cantidad en bytes. Es útil para monitorear el uso de memoria cuando se trabaja con cálculos acelerados por GPU, asegurando que las operaciones no excedan la memoria disponible.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>int</strong>: La cantidad de memoria libre en la GPU en bytes.</p></li>
</ul>
<p><strong>Ejemplo de Uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">free_mem</span> <span class="o">=</span> <span class="n">get_gpu_free_mem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available GPU Memory: </span><span class="si">{</span><span class="n">free_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_maxmem">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_maxmem</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_maxmem" title="Link to this definition">¶</a></dt>
<dd><p>Recupera la capacidad total de memoria de la GPU.</p>
<p>Esta función consulta el dispositivo GPU para determinar su memoria total disponible, representando la capacidad total de VRAM de la GPU.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>int</strong>: La memoria total de la GPU en bytes.</p></li>
</ul>
<p><strong>Ejemplo de Uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">total_mem</span> <span class="o">=</span> <span class="n">get_gpu_maxmem</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total GPU Memory: </span><span class="si">{</span><span class="n">total_mem</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_pci_bus_id">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_pci_bus_id</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_pci_bus_id" title="Link to this definition">¶</a></dt>
<dd><p>Recupera el ID del bus PCI de la GPU.</p>
<p>Esta función consulta el dispositivo GPU y devuelve su ID de bus PCI, que identifica de manera única la GPU dentro del sistema. El ID de bus PCI es útil para configuraciones multi-GPU, depuración y gestión de dispositivos.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: El ID de bus PCI de la GPU en el formato «Dominio:Bus:Dispositivo.Función» (por ejemplo, «0000:01:00.0»).</p></li>
</ul>
<p><strong>Ejemplo de Uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pci_id</span> <span class="o">=</span> <span class="n">get_gpu_pci_bus_id</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU PCI Bus ID: </span><span class="si">{</span><span class="n">pci_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_compute_capability">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_compute_capability</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_compute_capability" title="Link to this definition">¶</a></dt>
<dd><p>Recupera la capacidad de cálculo de la GPU.</p>
<p>La capacidad de cálculo representa la versión de la arquitectura de la GPU y determina su compatibilidad con varias características de CUDA. Valores más altos de capacidad de cálculo indican soporte para características y optimizaciones más avanzadas.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: La capacidad de cálculo de la GPU como una cadena en el formato «major.minor» (por ejemplo, «7.5» para GPUs NVIDIA Turing).</p></li>
</ul>
<p><strong>Ejemplo de Uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">capability</span> <span class="o">=</span> <span class="n">get_compute_capability</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GPU Compute Capability: </span><span class="si">{</span><span class="n">capability</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_max_grid_per_block">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_max_grid_per_block</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_max_grid_per_block" title="Link to this definition">¶</a></dt>
<dd><p>Recupera el número máximo de bloques de cuadrícula por multiprocesador.</p>
<p>Esta función devuelve el número máximo de bloques de cuadrícula que pueden estar activos por multiprocesador en la GPU. Este valor es esencial para optimizar cargas de trabajo en paralelo y garantizar un uso eficiente de los recursos.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>unsigned int</strong>: El número máximo de bloques de cuadrícula por multiprocesador.</p></li>
</ul>
<p><strong>Ejemplo de Uso:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">max_grid_blocks</span> <span class="o">=</span> <span class="n">get_max_grid_per_block</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max grid blocks per multiprocessor: </span><span class="si">{</span><span class="n">max_grid_blocks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>El valor devuelto depende de la capacidad de cálculo de la GPU.</p></li>
<li><p>Por ejemplo, las GPUs con Capacidad de Cálculo 2.x admiten hasta 8 bloques activos por multiprocesador, mientras que las GPUs con Capacidad de Cálculo 3.x y superior pueden admitir hasta 16 o más bloques activos por multiprocesador. Consulte la guía de programación de CUDA de NVIDIA para obtener valores específicos por arquitectura.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_grid">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_grid" title="Link to this definition">¶</a></dt>
<dd><p>Calcula automáticamente los tamaños óptimos de cuadrícula y bloque para la ejecución en GPU.</p>
<p>Esta función determina la mejor configuración de cuadrícula y bloque para la ejecución en GPU basándose en las dimensiones de la pantalla (o dominio computacional). Asegura que los tamaños de cuadrícula y bloque calculados sean válidos y compatibles con el ancho (<cite>w</cite>) y la altura (<cite>h</cite>) dados.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>): El ancho de la pantalla o dominio computacional. Debe ser mayor que 0.</p></li>
<li><p><strong>h</strong> (<em>int</em>): La altura de la pantalla o dominio computacional. Debe ser mayor que 0.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong>: Una tupla que contiene: - <cite>grid</cite>: (<em>y, x</em>) - El tamaño de la cuadrícula calculada (número de bloques en cada dimensión). - <cite>block</cite>: (<em>yy, xx</em>) - El tamaño del bloque calculado (número de hilos por bloque en cada dimensión).</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>: - Si <cite>w</cite> o <cite>h</cite> es menor o igual a 0. - Si los tamaños de cuadrícula y bloque calculados no son válidos (es decir, no cubren exactamente las dimensiones de entrada).</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función primero determina los divisores posibles de <cite>w</cite> y <cite>h</cite>, luego selecciona tamaños de bloque que no excedan 32 (un tamaño máximo común de bloque para la ejecución en GPU).</p></li>
<li><p>El tamaño final de la cuadrícula se determina dividiendo las dimensiones de entrada por los tamaños de bloque seleccionados.</p></li>
<li><p>Si la configuración calculada no es válida (es decir, <cite>yy * y != h</cite> o <cite>xx * x != w</cite>), se lanza un error de aserción, sugiriendo que podría ser necesaria una configuración manual.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="n">block_grid</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>  <span class="c1"># Output: (4, 4) (16, 16)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.conv">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">conv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.conv" title="Link to this definition">¶</a></dt>
<dd><p>Convierte un valor a un formato legible, escalándolo por potencias de 1024 (por ejemplo, KB, MB, GB).</p>
<p>Esta función divide el valor de entrada <cite>v</cite> por 1024 repetidamente hasta que sea menor o igual a 1024. Luego devuelve el valor con su unidad apropiada (por ejemplo, KB, MB, GB) basándose en el número de divisiones realizadas.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>v</strong> (<em>float</em> o <em>int</em>): El valor a convertir (típicamente representando bytes o tamaño de datos).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>str</strong>: Una cadena legible que representa el valor con una unidad apropiada, redondeada a 3 decimales.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza las siguientes unidades: - 1024 bytes = 1 KB - 1024 KB = 1 MB - 1024 MB = 1 GB - y así sucesivamente…</p></li>
<li><p>Si el valor de entrada <cite>v</cite> es menor que 1024, se devolverá tal cual con la primera unidad.</p></li>
<li><p>La función asegura que se seleccione la unidad apropiada basándose en la escala de <cite>v</cite>.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">conv</span><span class="p">(</span><span class="mi">1048576</span><span class="p">)</span>  <span class="c1"># Returns &#39;1.0 MB&#39;</span>
<span class="n">conv</span><span class="p">(</span><span class="mi">123456789</span><span class="p">)</span>  <span class="c1"># Returns &#39;117.74 MB&#39;</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.block_and_grid_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">block_and_grid_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.block_and_grid_info" title="Link to this definition">¶</a></dt>
<dd><p>Calcula y muestra las dimensiones apropiadas de bloque y cuadrícula de la GPU para un tamaño de imagen dado.</p>
<p>Esta función calcula los tamaños de cuadrícula y bloque necesarios para una paralelización óptima en la GPU. Utiliza la función <cite>block_grid</cite> para determinar los mejores tamaños de bloque y cuadrícula basándose en el ancho (<cite>w</cite>) y la altura (<cite>h</cite>) proporcionados de la imagen o pantalla.</p>
<p>Los tamaños de bloque y cuadrícula se validan para asegurar que puedan cubrir correctamente toda el área. Si la validación falla, se lanzan aserciones. Posteriormente, la función imprime los tamaños de cuadrícula y bloque resultantes.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>w</strong> (<em>int</em>): El ancho de la imagen o pantalla (debe ser mayor que 0).</p></li>
<li><p><strong>h</strong> (<em>int</em>): La altura de la imagen o pantalla (debe ser mayor que 0).</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>: - Si <cite>w</cite> o <cite>h</cite> no son positivos. - Si los tamaños de cuadrícula y bloque calculados no cubren adecuadamente la imagen.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: Esta función solo imprime la información de la cuadrícula y bloque de la GPU. No devuelve ningún valor.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">block_and_grid_info</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">)</span>
<span class="c1"># Output:</span>
<span class="c1"># GPU GRID        : (grid_y=34.000000, grid_x=60.000000)</span>
<span class="c1"># GPU BLOCK       : (block_y=32.000000, block_x=32.000000)</span>
</pre></div>
</div>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La cuadrícula se determina por el número de bloques necesarios para cubrir la altura y el ancho de la imagen.</p></li>
<li><p>El tamaño del bloque se refiere al tamaño de cada bloque individual de hilos en la GPU.</p></li>
<li><p>Esta función asume que el procesamiento en la GPU se optimizará para los tamaños de cuadrícula y bloque calculados.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.get_gpu_info">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">get_gpu_info</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.get_gpu_info" title="Link to this definition">¶</a></dt>
<dd><p>Muestra información detallada de la GPU, incluyendo memoria, capacidad de cálculo y ID del bus PCI.</p>
<p>Esta función recupera e imprime varios detalles sobre la GPU, incluyendo: - La versión instalada de CuPy. - El tamaño máximo de cuadrícula por bloque soportado por la GPU. - La memoria disponible y total de la GPU, tanto en bytes como en formatos legibles. - El ID del bus PCI de la GPU. - La capacidad de cálculo de la GPU.</p>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: Esta función imprime información relacionada con la GPU en la consola.</p></li>
</ul>
<p><strong>Ejemplo de salida:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">get_gpu_info</span><span class="p">()</span>
<span class="c1"># Output:</span>
<span class="c1"># CUPY VERSION           : 11.2.0</span>
<span class="c1"># GPU MAX GRID PER BLOCK : 65535</span>
<span class="c1"># GPU FREE MEMORY        : (mem=8388608000.000000, (8.0 GB))</span>
<span class="c1"># GPU MAX MEMORY         : (mem=17179869184.000000, (16.0 GB))</span>
<span class="c1"># GPU PCI BUS ID         : (bus=0000:01:00.0)</span>
<span class="c1"># GPU CAPABILITY         : (capa=7.5)</span>
</pre></div>
</div>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función depende de CuPy para la información de la memoria de la GPU.</p></li>
<li><p>La función <cite>conv</cite> se utiliza para convertir valores de memoria en bruto a un formato más legible (por ejemplo, GB).</p></li>
<li><p>Esta función es útil para depurar y verificar la disponibilidad de recursos de la GPU antes de lanzar operaciones basadas en CUDA.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Realiza la inversión de color acelerada por GPU en una superficie de Pygame (devuelve una copia).</p>
<p>Esta función transfiere los datos de la imagen de una <cite>pygame.Surface</cite> a la GPU, invierte los valores de color utilizando CuPy y luego reconstruye una nueva superficie con los datos de píxeles modificados.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Un objeto de superficie de Pygame (24-bit o 32-bit) que contiene la imagen a invertir.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con colores invertidos, conservando el formato original (BGR o BGRA).</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si la superficie no puede ser referenciada como un búfer 1D o tiene longitud cero.</p></li>
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es un objeto <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Utiliza CuPy para realizar la inversión directamente en la GPU para un rendimiento óptimo.</p></li>
<li><p>Detecta automáticamente si la superficie es de 24 bits (BGR) o de 32 bits (BGRA).</p></li>
<li><p>Sincroniza la GPU para asegurar la finalización antes de devolver la imagen procesada.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">inverted_surface</span> <span class="o">=</span> <span class="n">invert_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">inverted_surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_gpu_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Realiza la inversión de color acelerada por GPU en una superficie de Pygame in situ.</p>
<p>Esta función modifica directamente los datos de píxeles de la <cite>pygame.Surface</cite> dada invirtiendo sus valores de color utilizando procesamiento en la GPU a través de CuPy. La inversión se realiza in situ, lo que significa que la superficie original se altera sin crear una nueva.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de Pygame cuyos colores de píxeles se invertirán. Debe ser una superficie válida de 24 bits (BGR) o 32 bits (BGRA).</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si el búfer de la superficie no se puede acceder o tiene longitud cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función transfiere los datos de píxeles a la GPU, realiza la inversión y copia los píxeles modificados de vuelta a la superficie original.</p></li>
<li><p>Utiliza CuPy para un cálculo eficiente en la GPU.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">invert_gpu_inplace</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;inverted_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Realiza la inversión in situ de un búfer de píxeles BGR utilizando la GPU.</p>
<p>Esta función toma un búfer BGR 1D contiguo (como un array de NumPy o memoryview), lo transfiere a la GPU, invierte los valores de píxeles (255 - valor de píxel) y escribe el resultado de vuelta en el búfer original.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> o <em>memoryview</em>): Un array 1D contiguo que representa el búfer de píxeles BGR. El búfer debe ser mutable y no estar vacío.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>bgr_array</cite> no es un array de NumPy o un memoryview.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>bgr_array</cite> está vacío (tiene longitud cero).</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función modifica <cite>bgr_array</cite> in situ.</p></li>
<li><p>Utiliza CuPy habilitado para CUDA para la aceleración por GPU.</p></li>
<li><p>Adecuado para el procesamiento de imágenes de alto rendimiento donde es necesaria la modificación in situ.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Example BGR array</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to CuPy array</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Invert colors in place</span>
<span class="n">invert_buffer_gpu</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to NumPy array</span>
<span class="n">inverted_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inverted_bgr_array</span><span class="p">)</span>  <span class="c1"># Output: [  0 255 255 255   0 255 255 255   0]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.invert_rgb_array_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">invert_rgb_array_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.invert_rgb_array_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Invierte los valores RGB de una imagen (array 3D de NumPy o memoryview) in situ utilizando la GPU.</p>
<p>Esta función realiza una inversión in situ de los canales RGB en el array de entrada. Opera bajo la suposición de que el <cite>rgb_array</cite> de entrada es un array 3D de NumPy o un memoryview con forma (altura, ancho, 3), donde la última dimensión representa los canales de color RGB.</p>
<p><strong>Nota</strong>: Esta operación se realiza utilizando la GPU para acelerar el cálculo.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em> o <em>memoryview</em>): Un array 3D o memoryview con forma (altura, ancho, 3) que contiene los valores RGB de la imagen. El dtype debe ser <em>numpy.uint8</em>. Si <cite>rgb_array</cite> es un memoryview, debe ser de un tipo compatible.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>rgb_array</cite> no es un <em>numpy.ndarray</em> o <em>memoryview</em>.</p></li>
<li><p><strong>ValueError</strong>: Si el <cite>rgb_array</cite> no es de tipo <em>numpy.uint8</em> o no tiene 3 dimensiones. Si el ancho o la altura del array es cero.</p></li>
</ul>
<p><strong>Descripción:</strong></p>
<p>Esta función modifica directamente el arreglo de entrada <cite>rgb_array</cite> invirtiendo los canales RGB utilizando operaciones aceleradas por GPU. La inversión se realiza in situ, lo que significa que el arreglo original será actualizado. La GPU se utiliza para realizar la inversión de manera eficiente.</p>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a white image of shape (100, 100, 3)</span>
<span class="n">rgb_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>

<span class="c1"># Invert the image colors in place</span>
<span class="n">invert_rgb_array_inplace</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">)</span>

<span class="c1"># Print the color of the first pixel, should be black [0, 0, 0]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rgb_image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un sombreador Sepia a una superficie de Pygame y devuelve una nueva superficie con el efecto Sepia aplicado.</p>
<p>Esta función funciona con superficies de Pygame de profundidad de color de 32 bits y 24 bits. Utiliza cálculos basados en GPU para transformar los colores de los píxeles aplicando un filtro Sepia.</p>
<p>La función primero verifica el tipo de la superficie proporcionada para asegurarse de que sea una superficie válida de Pygame. Luego extrae los datos de píxeles de la superficie, aplica el filtro Sepia utilizando un kernel basado en GPU y devuelve una nueva superficie de Pygame con la imagen transformada.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Un objeto Pygame Surface que contiene la imagen a la que se aplicará el filtro Sepia. Se espera que la superficie esté en formato de 32 bits o 24 bits.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Un nuevo objeto Pygame Surface con las mismas dimensiones y el filtro Sepia aplicado, en formato «RGB».</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el efecto Sepia de manera eficiente.</p></li>
<li><p>La superficie de entrada no se modifica; se devuelve una nueva superficie con el efecto Sepia aplicado.</p></li>
<li><p>Asegúrese de que la superficie de Pygame esté en un formato compatible (24 bits o 32 bits) antes de aplicar el filtro.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sepia filter</span>
<span class="n">sepia_surface</span> <span class="o">=</span> <span class="n">sepia_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sepia_surface</span><span class="p">,</span> <span class="s2">&quot;sepia_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_rgb_array_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_rgb_array_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_rgb_array_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro Sepia in situ a un arreglo de imagen RGB utilizando aceleración por GPU.</p>
<p>Esta función procesa una imagen de 32 bits o 24 bits in situ modificando el arreglo <cite>numpy.ndarray</cite> proporcionado de forma (w, h, 3) que contiene valores RGB de tipo uint8. El efecto Sepia se aplica directamente al arreglo de entrada sin crear un nuevo arreglo.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>rgb_array</strong> (<em>numpy.ndarray</em>): Un arreglo numpy 3D con forma (w, h, 3), que representa una imagen con valores de píxeles RGB en el tipo de datos uint8. La forma debe representar el ancho (w), la altura (h) y los tres canales (Rojo, Verde, Azul).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: Esta función modifica el arreglo de entrada <cite>rgb_array</cite> in situ y no devuelve nada.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el efecto Sepia de manera eficiente.</p></li>
<li><p>El arreglo de entrada se modifica directamente; no se crea un nuevo arreglo.</p></li>
<li><p>Asegúrese de que el arreglo de entrada sea de tipo <cite>numpy.uint8</cite> y tenga tres dimensiones que representen los canales RGB.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample RGB image (100x100 pixels)</span>
<span class="n">rgb_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">rgb_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">rgb_array</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_rgb_array_gpu</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_rgb_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">rgb_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sepia_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sepia_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sepia_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro Sepia a un búfer de imagen BGR o BGRA en la GPU (in situ).</p>
<p>Esta función utiliza un kernel de GPU para aplicar un efecto Sepia a una imagen almacenada en formato BGR o BGRA. La operación se realiza en el búfer de imagen de entrada (<cite>bgr_array</cite>), que es un arreglo 1D o una vista de memoria que representa los datos de píxeles en formato BGR o BGRA.</p>
<p>La función asume que el búfer está organizado como un arreglo 1D, donde cada píxel consta de 3 o 4 bytes (dependiendo de si está en formato BGR o BGRA). El efecto Sepia se aplica en paralelo en la GPU utilizando un kernel CUDA, y el resultado se almacena directamente en el búfer de entrada.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>grid_</strong> (<em>tuple</em>): Las dimensiones de la cuadrícula de bloques que se utilizarán para el lanzamiento del kernel, generalmente obtenidas de una función auxiliar como <cite>block_grid()</cite>.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Las dimensiones de los bloques que se utilizarán para el lanzamiento del kernel, generalmente obtenidas de una función auxiliar como <cite>block_grid()</cite>.</p></li>
<li><p><strong>w</strong> (<em>Py_ssize_t</em>): El ancho de la imagen, en píxeles. Debe ser mayor que 0.</p></li>
<li><p><strong>h</strong> (<em>Py_ssize_t</em>): La altura de la imagen, en píxeles. Debe ser mayor que 0.</p></li>
<li><p><strong>bgr_array</strong> (<em>unsigned char [::1]</em>): Un arreglo 1D o una vista de memoria que contiene los datos de píxeles de la imagen. Este arreglo representa la imagen en formato BGR (3 canales) o BGRA (4 canales), donde cada píxel ocupa 3 o 4 bytes consecutivos.</p></li>
<li><p><strong>format_32</strong> (<em>bint</em>, opcional): Una bandera booleana que indica si el arreglo de entrada está en formato BGRA (True) o BGR (False). El valor predeterminado es False (formato BGR).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: Esta función modifica el arreglo de entrada <cite>bgr_array</cite> in situ y no devuelve nada.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>bgr_array</cite> no es un numpy.ndarray o una vista de memoria válida.</p></li>
<li><p><strong>ValueError</strong>: Si las dimensiones de la imagen de entrada o la longitud del búfer no coinciden con los valores esperados basados en el ancho, la altura y el formato de píxel.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el efecto Sepia de manera eficiente.</p></li>
<li><p>El arreglo de entrada se modifica directamente; no se crea un nuevo arreglo.</p></li>
<li><p>Asegúrese de que el arreglo de entrada sea de tipo <cite>numpy.uint8</cite> y tenga tres o cuatro dimensiones que representen los canales RGB o RGBA.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Sepia filter in-place</span>
<span class="n">sepia_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">sepia_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de paso brillante (BPF) a una superficie de Pygame utilizando aceleración por GPU.</p>
<p>Esta función aplica un filtro de paso brillante a una imagen representada por una superficie de Pygame. El filtro conserva los píxeles con valores de brillo superiores a un umbral especificado y establece los demás en negro. La operación se realiza en la GPU para mejorar el rendimiento.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada (imagen) a la que se aplicará el efecto de filtro de paso brillante.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, opcional): El umbral de brillo en el rango [0, 255]. Los píxeles con un valor de brillo mayor o igual al umbral conservarán su color, mientras que los que estén por debajo se establecerán en negro. El valor predeterminado es 128.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con el efecto de filtro de paso brillante aplicado, en formato RGB, con el mismo ancho y altura que la superficie de entrada.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es de tipo <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si hay un problema al referenciar los píxeles de la superficie en un arreglo 3D, o si las dimensiones de la superficie no son válidas.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el filtro de paso brillante de manera eficiente.</p></li>
<li><p>La superficie de entrada no se modifica; se devuelve una nueva superficie con el efecto de filtro de paso brillante aplicado.</p></li>
<li><p>Asegúrese de que la superficie de Pygame esté en un formato compatible (24 bits o 32 bits) antes de aplicar el filtro.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_surface</span> <span class="o">=</span> <span class="n">bpf_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bpf_surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_inplace_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_inplace_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_inplace_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de paso brillante (BPF) a una superficie de Pygame in situ utilizando aceleración por GPU.</p>
<p>Esta función aplica un efecto de filtro de paso brillante a una imagen en la GPU. El filtro conserva los píxeles con valores de brillo mayores o iguales a un umbral especificado, estableciendo los demás en negro. La operación se realiza in situ, modificando directamente la superficie de entrada.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada (imagen) a la que se aplicará el efecto de filtro de paso brillante. La superficie debe estar en formato RGB.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Especifica la configuración de la cuadrícula para el kernel de la GPU. Esto determina cómo se divide el trabajo entre múltiples hilos en la GPU. Las dimensiones de la cuadrícula deben coincidir con los tamaños de la textura y el arreglo.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Especifica la configuración del bloque para el kernel de la GPU. Esto define el número de hilos dentro de un bloque. El número máximo de hilos por bloque es 1024. El tamaño del bloque debe elegirse para optimizar el rendimiento en el hardware.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, opcional): El umbral de brillo (en el rango [0, 255]) que determina qué píxeles se conservan. Los píxeles con un valor de brillo mayor o igual al umbral permanecen sin cambios, mientras que los píxeles por debajo del umbral se establecen en negro. El valor predeterminado es 128.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: La función modifica la superficie de entrada <cite>surface_</cite> in situ y no devuelve nada.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es de tipo <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si hay un problema al referenciar los píxeles de la superficie en un arreglo 3D, o si las dimensiones de la superficie no son válidas.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el filtro de paso brillante de manera eficiente.</p></li>
<li><p>La superficie de entrada se modifica directamente; no se crea una nueva superficie.</p></li>
<li><p>Asegúrese de que la superficie de Pygame esté en un formato compatible (24 bits o 32 bits) antes de aplicar el filtro.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the Bright Pass Filter with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_inplace_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">surface</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="s2">&quot;bpf_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bpf_buffer_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bpf_buffer_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bgr_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bpf_buffer_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de paso de banda (BPF) a un búfer de imagen utilizando aceleración por GPU.</p>
<p>Esta función procesa un búfer de imagen representado por un arreglo 1D o una vista de memoria en formato BGR o BGRA. El BPF conserva los píxeles con valores de brillo dentro de un rango especificado y establece los demás en negro. La operación se realiza en la GPU para mejorar el rendimiento.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>): Tamaño de la cuadrícula para la ejecución del kernel de la GPU (bloques por cuadrícula).</p></li>
<li><p><strong>block</strong> (<em>tuple</em>): Tamaño del bloque para la ejecución del kernel de la GPU (hilos por bloque).</p></li>
<li><p><strong>w</strong> (<em>int</em>): Ancho de la imagen en píxeles.</p></li>
<li><p><strong>h</strong> (<em>int</em>): Altura de la imagen en píxeles.</p></li>
<li><p><strong>bgr_array</strong> (<em>numpy.ndarray</em> o <em>memoryview</em>): Búfer de imagen de entrada en formato BGR o BGRA.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, opcional): Valor de umbral utilizado para el filtrado (predeterminado: 128).</p></li>
<li><p><strong>format_32</strong> (<em>bool</em>, opcional): Si es True, trata el búfer de entrada como BGRA (4 bytes por píxel). Si es False, lo trata como BGR (3 bytes por píxel).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>None</strong>: La función modifica <cite>bgr_array</cite> in situ con la imagen filtrada.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>bgr_array</cite> no es un numpy.ndarray o una vista de memoria.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>bgr_array</cite> está vacío o no coincide con el tamaño esperado.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para aplicar el BPF de manera eficiente.</p></li>
<li><p>El arreglo de entrada se modifica directamente; no se crea un nuevo arreglo.</p></li>
<li><p>Asegúrese de que el arreglo de entrada sea de tipo <cite>numpy.uint8</cite> y tenga tres o cuatro dimensiones que representen los canales RGB o RGBA.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Create a sample BGR image (100x100 pixels)</span>
<span class="n">bgr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Convert to a CuPy array for GPU processing</span>
<span class="n">bgr_array_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bgr_array</span><span class="p">)</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="c1"># Apply the BPF with a threshold of 150</span>
<span class="n">threshold_value</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">bpf_buffer_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bgr_array_gpu</span><span class="p">,</span> <span class="n">threshold_value</span><span class="p">)</span>

<span class="c1"># Convert back to a NumPy array if needed</span>
<span class="n">filtered_bgr_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bgr_array_gpu</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una superficie de Pygame a escala de grises utilizando aceleración por GPU.</p>
<p>Esta función toma una superficie de Pygame en formato de 24 bits o 32 bits, la procesa en la GPU para convertirla a escala de grises y devuelve una nueva superficie de 24 bits en escala de grises.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una superficie de Pygame con un formato de color de 24 bits o 32 bits.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame de 24 bits en escala de grises.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una superficie de Pygame.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie no se puede convertir en una vista de arreglo 3D, o si el ancho o la altura de la superficie es cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para realizar la conversión a escala de grises de manera eficiente.</p></li>
<li><p>La superficie de entrada no se modifica; se devuelve una nueva superficie con el efecto de escala de grises aplicado.</p></li>
<li><p>Asegúrese de que la superficie de Pygame esté en un formato compatible (24 bits o 32 bits) antes de aplicar el filtro.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.grayscale_lum_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">grayscale_lum_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.grayscale_lum_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Convierte una superficie de Pygame a escala de grises utilizando aceleración por GPU con un método basado en luminancia.</p>
<p>Esta función toma una superficie de Pygame en formato de 24 bits o 32 bits, la procesa en la GPU utilizando una conversión a escala de grises basada en luminancia y devuelve una nueva superficie de Pygame de 24 bits en escala de grises.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una superficie de Pygame con un formato de color de 24 bits o 32 bits.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame de 24 bits en escala de grises.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una superficie de Pygame.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie no se puede convertir en una vista de arreglo 3D, o si el ancho o la altura de la superficie es cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para realizar la conversión a escala de grises de manera eficiente.</p></li>
<li><p>La superficie de entrada no se modifica; se devuelve una nueva superficie con el efecto de escala de grises aplicado.</p></li>
<li><p>Asegúrese de que la superficie de Pygame esté en un formato compatible (24 bits o 32 bits) antes de aplicar el filtro.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert the image to grayscale</span>
<span class="n">grayscale_surface</span> <span class="o">=</span> <span class="n">grayscale_lum_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">grayscale_surface</span><span class="p">,</span> <span class="s2">&quot;grayscale_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_generic_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_generic_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_generic_filter_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de mediana a una superficie de Pygame utilizando aceleración por GPU.</p>
<p>Esta función utiliza un filtro de mediana genérico, que procesa cada píxel en función de los valores vecinos. El filtro opera en superficies de 24 bits y 32 bits aplicando una función de kernel.</p>
<p><strong>Consideración de rendimiento:</strong> El filtro de mediana utiliza un kernel con un búfer de tipo <cite>double</cite>, lo que puede resultar en un rendimiento más bajo en comparación con métodos especializados de filtrado de mediana basados en GPU.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de Pygame de entrada, que se espera que esté en formato de 24 bits o 32 bits.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, opcional): El tamaño de la ventana de vecindad utilizada para el filtro de mediana. Debe ser mayor que cero. El valor predeterminado es 5.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con el filtro de mediana aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si <cite>size_</cite> es menor o igual a cero, o si la superficie de entrada tiene un ancho o altura de cero.</p></li>
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite> válida.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función aprovecha CuPy (<cite>cp.asarray</cite>) para la computación acelerada por GPU.</p></li>
<li><p>El filtro opera en cada canal de color (R, G, B) por separado.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_generic_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.median_filter_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">median_filter_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.median_filter_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de mediana a una superficie de Pygame utilizando aceleración por GPU.</p>
<p>El filtro de mediana es un filtro no lineal que reduce el ruido reemplazando cada píxel con el valor mediano de sus vecinos circundantes.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de Pygame de entrada que se procesará.</p></li>
<li><p><strong>size_</strong> (<em>int</em>, opcional): El tamaño de la vecindad considerada para el filtrado de mediana. Debe ser mayor que cero. El valor predeterminado es 5.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con el filtro de mediana aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>AssertionError</strong>: Si <cite>size_</cite> no es mayor que cero.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>surface_</cite> no es una superficie de Pygame válida, o si la superficie no se puede referenciar como un arreglo 3D, o si el ancho o la altura de la superficie es cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función aprovecha CuPy (<cite>cp.asarray</cite>) para la computación acelerada por GPU.</p></li>
<li><p>El filtro opera en cada canal de color (R, G, B) por separado.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the median filter with a window size of 5</span>
<span class="n">filtered_surface</span> <span class="o">=</span> <span class="n">median_filter_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">size_</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filtered_surface</span><span class="p">,</span> <span class="s2">&quot;filtered_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_5x5_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un desenfoque gaussiano de 5x5 a una imagen utilizando procesamiento acelerado por GPU.</p>
<p>Esta función convoluciona cada canal RGB de la superficie dada con un kernel de desenfoque gaussiano de 5x5 para crear un efecto de suavizado mientras preserva los bordes.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una superficie de Pygame de 24 bits o 32 bits que se desenfocará.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con el desenfoque gaussiano aplicado en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una superficie de Pygame válida.</p></li>
<li><p><strong>ValueError</strong>: Si las dimensiones de la superficie no son válidas o no se puede acceder a los datos de píxeles.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza <cite>pixels3d(surface_)</cite> para extraer el arreglo de píxeles.</p></li>
<li><p>El cálculo se realiza en la GPU para mayor eficiencia.</p></li>
<li><p>Se llama a <cite>gaussian_5x5_cupy</cite> para aplicar el efecto de desenfoque.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 5x5 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_5x5_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.gaussian_3x3_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">gaussian_3x3_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.gaussian_3x3_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un desenfoque gaussiano de 3x3 a una superficie de Pygame utilizando aceleración por GPU.</p>
<p>Esta función convierte una <cite>pygame.Surface</cite> dada en un arreglo compatible con la GPU, aplica un filtro de desenfoque gaussiano de 3x3 a cada canal de color (R, G, B) y devuelve una nueva <cite>pygame.Surface</cite> desenfocada.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una <cite>pygame.Surface</cite> de 24 bits o 32 bits que representa la imagen de entrada.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva <cite>pygame.Surface</cite> con el efecto de desenfoque gaussiano aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie tiene dimensiones no válidas o no se puede convertir en un arreglo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asume que <cite>gaussian_kernel_3x3</cite> está predefinido.</p></li>
<li><p><cite>cp.cuda.Stream.null.synchronize()</cite> asegura que las operaciones de la GPU se completen antes de devolver el resultado.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the 3x3 Gaussian blur</span>
<span class="n">blurred_surface</span> <span class="o">=</span> <span class="n">gaussian_3x3_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blurred_surface</span><span class="p">,</span> <span class="s2">&quot;blurred_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sobel_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sobel_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sobel_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica el filtro de detección de bordes Sobel a una imagen en escala de grises utilizando aceleración por GPU.</p>
<p>Esta función asume que la imagen de entrada está en escala de grises, lo que significa que la misma intensidad está presente en los tres canales RGB. Aplica el filtro Sobel utilizando solo el canal rojo (<cite>R</cite>), aunque también se podrían usar los canales verde (<cite>G</cite>) o azul (<cite>B</cite>).</p>
<p>Si la imagen de entrada no está realmente en escala de grises, el efecto Sobel puede variar ligeramente porque los canales RGB podrían tener diferentes intensidades.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una <cite>pygame.Surface</cite> de 24 bits o 32 bits que representa la imagen de entrada.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva <cite>pygame.Surface</cite> con el efecto de detección de bordes Sobel aplicado en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie tiene dimensiones no válidas o no se puede convertir en un arreglo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asume que <cite>sobel_cupy()</cite> está implementado para procesar el arreglo de la GPU.</p></li>
<li><p>La imagen final conserva el formato <cite>RGB</cite>, pero solo se modifica el canal rojo.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Sobel edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">sobel_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.prewitt_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">prewitt_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.prewitt_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica el algoritmo de detección de bordes Prewitt a una imagen en escala de grises utilizando aceleración por GPU.</p>
<p>Esta función asume que la imagen de entrada está en escala de grises, lo que significa que la misma intensidad está presente en los tres canales RGB. Aplica el filtro Prewitt utilizando solo el canal rojo (<cite>R</cite>), aunque también se podrían usar los canales verde (<cite>G</cite>) o azul (<cite>B</cite>).</p>
<p>Si la imagen de entrada no está realmente en escala de grises, el efecto Prewitt puede variar ligeramente porque los canales RGB podrían tener diferentes intensidades.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una <cite>pygame.Surface</cite> de 24 bits o 32 bits que representa la imagen de entrada.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva <cite>pygame.Surface</cite> con el efecto de detección de bordes Prewitt aplicado en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie tiene dimensiones no válidas o no se puede convertir en un arreglo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asume que <cite>prewitt_cupy()</cite> está implementado para procesar el arreglo de la GPU.</p></li>
<li><p>La imagen final conserva el formato <cite>RGB</cite>, pero solo se modifica el canal rojo.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Prewitt edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">prewitt_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.canny_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">canny_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.canny_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica el algoritmo de detección de bordes Canny a una imagen en escala de grises utilizando aceleración por GPU.</p>
<p>Esta función asume que la imagen de entrada está en escala de grises, lo que significa que la misma intensidad está presente en los tres canales RGB. Aplica el algoritmo de detección de bordes Canny utilizando solo el canal rojo (<cite>R</cite>), aunque también se podrían usar los canales verde (<cite>G</cite>) o azul (<cite>B</cite>). Si la imagen de entrada no está realmente en escala de grises, el efecto Canny puede variar ligeramente porque los canales RGB podrían tener diferentes intensidades.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Una <cite>pygame.Surface</cite> de 24 bits o 32 bits que representa la imagen de entrada.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva <cite>pygame.Surface</cite> con el efecto de detección de bordes Canny aplicado en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie tiene dimensiones no válidas o no se puede convertir en un arreglo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asume que <cite>canny_cupy()</cite> está implementado para procesar el arreglo de la GPU.</p></li>
<li><p>La imagen final conserva el formato <cite>RGB</cite>, pero solo se modifica el canal rojo.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the Canny edge detection filter</span>
<span class="n">edge_surface</span> <span class="o">=</span> <span class="n">canny_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">edge_surface</span><span class="p">,</span> <span class="s2">&quot;edge_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.color_reduction_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">color_reduction_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.color_reduction_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de reducción de color a una imagen utilizando aceleración por GPU.</p>
<p>Esta función reduce el número de colores únicos en la imagen cuantizando cada canal RGB. Por ejemplo, si <cite>color_number=8</cite>, cada canal tendrá 8 niveles distintos (0, 32, 64, …, 255), lo que resulta en un total de 8^3 colores posibles.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada (imagen) a la que se aplicará la reducción de color.</p></li>
<li><p><strong>color_number</strong> (<em>int</em>, opcional): El número de colores (niveles) a los que se reducirá cada canal RGB. El valor predeterminado es 8. El número de colores en la paleta será <cite>color_number^3</cite>.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie con el efecto de reducción de color aplicado, en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si el argumento <cite>surface_</cite> no es una instancia válida de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>color_number</cite> es menor o igual a 0 o si la superficie tiene dimensiones no válidas.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>La reducción de color se logra cuantizando cada canal de color RGB.</p></li>
<li><p>La función funciona con imágenes de 32 bits y 24 bits (formato Pygame Surface).</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the color reduction with a palette size of 8</span>
<span class="n">reduced_surface</span> <span class="o">=</span> <span class="n">color_reduction_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">color_number</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">reduced_surface</span><span class="p">,</span> <span class="s2">&quot;reduced_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsv_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsv_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsv_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de rotación de tono a una imagen utilizando aceleración por GPU.</p>
<p>Esta función modifica el tono de cada píxel en la imagen mientras preserva su saturación y brillo, cambiando efectivamente los colores mientras mantiene la estructura general de la imagen.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada (imagen) a la que se aplicará el efecto de rotación de tono.</p></li>
<li><p><strong>val_</strong> (<em>float</em>): El valor de desplazamiento de tono, que debe estar dentro del rango [0.0, 1.0]. - <cite>0.0</cite> corresponde a un desplazamiento de -180° (rotación completa hacia atrás). - <cite>0.5</cite> representa un desplazamiento de 0° (sin cambios). - <cite>1.0</cite> corresponde a un desplazamiento de +180° (rotación completa hacia adelante).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Especifica las dimensiones de la cuadrícula CUDA para la ejecución del kernel. - Ejemplo: <cite>(grid_y, grid_x)</cite>, por ejemplo, <cite>(25, 25)</cite>. - El tamaño de la cuadrícula debe ajustarse según los tamaños de la textura y el arreglo.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Especifica las dimensiones del bloque CUDA para la ejecución del kernel. - Ejemplo: <cite>(block_y, block_x)</cite>, por ejemplo, <cite>(32, 32)</cite>. - El número total de hilos (<cite>block_x * block_y</cite>) no debe exceder 1024 debido a las limitaciones del hardware de la GPU.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie que contiene la imagen con el tono modificado, devuelta en formato RGB de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una instancia válida de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la superficie de entrada tiene un ancho o altura de cero, si <cite>val_</cite> está fuera del rango válido [0.0, 1.0], o si los píxeles de la superficie no se pueden referenciar como un arreglo 3D.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La imagen de entrada debe estar en formato RGB antes de aplicar esta transformación.</p></li>
<li><p>La función realiza la rotación de tono utilizando aceleración por GPU con CuPy para un rendimiento optimizado.</p></li>
<li><p>La transformación funciona convirtiendo RGB a HSV, modificando el canal H (tono) y luego convirtiéndolo de nuevo a RGB.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the hue rotation with a shift value of 0.5 (no change)</span>
<span class="n">rotated_surface</span> <span class="o">=</span> <span class="n">hsv_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">val_</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">grid_</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span> <span class="n">block_</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">rotated_surface</span><span class="p">,</span> <span class="s2">&quot;rotated_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mult_downscale_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mult_downscale_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mult_downscale_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Realiza una reducción de resolución progresiva para el efecto bloom.</p>
<p>Esta función reduce la resolución de una imagen basada en GPU en cuatro subarreglos progresivamente más pequeños con resoluciones reducidas por factores de 2, 4, 8 y 16. Es compatible con imágenes de 24 bits y 32 bits (formato RGB, uint8).</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array</strong> (<em>cupy.ndarray</em>): Un arreglo 3D de CuPy con forma (altura, ancho, 3) y tipo de datos uint8, que representa una imagen RGB almacenada en la GPU.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>tuple of cupy.ndarray</strong>: Una tupla que contiene cuatro versiones reducidas de la imagen de entrada con formas (H/2, W/2, 3), (H/4, W/4, 3), (H/8, W/8, 3) y (H/16, W/16, 3).</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función realiza la reducción de resolución utilizando <cite>cupyx.scipy.ndimage.zoom</cite>, aplicando interpolación de vecino más cercano (<cite>order=0</cite>) para preservar los bordes definidos.</p></li>
<li><p>Los píxeles fuera de los límites se rellenan con cero (<cite>mode=”constant”, cval=0.0</cite>).</p></li>
<li><p>Se realiza una sincronización de la GPU para asegurar que todas las operaciones CUDA se completen antes de devolver el resultado.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">downscaled_images</span> <span class="o">=</span> <span class="n">mult_downscale_gpu</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">)</span>

<span class="c1"># Access the downscaled images</span>
<span class="n">image_2x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">image_4x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">image_8x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">image_16x</span> <span class="o">=</span> <span class="n">downscaled_images</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.upscale_c">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">upscale_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">new_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.upscale_c" title="Link to this definition">¶</a></dt>
<dd><p>Amplía una imagen en la GPU utilizando interpolación.</p>
<p>Esta función redimensiona una imagen basada en GPU al <cite>new_width</cite> y <cite>new_height</cite> especificados utilizando el orden de interpolación indicado. El redimensionamiento se realiza utilizando <cite>cupyx.scipy.ndimage.zoom</cite>, que admite diferentes métodos de interpolación.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>): Un arreglo 3D en la GPU (altura x ancho x 3) que representa una imagen RGB en formato <cite>uint8</cite>.</p></li>
<li><p><strong>new_width</strong> (<em>int</em>): El ancho deseado de la imagen ampliada.</p></li>
<li><p><strong>new_height</strong> (<em>int</em>): La altura deseada de la imagen ampliada.</p></li>
<li><p><strong>order_</strong> (<em>int</em>, opcional, predeterminado=0): El orden de interpolación para el redimensionamiento: - <cite>0</cite>: Interpolación de vecino más cercano. - <cite>1</cite>: Interpolación bilineal. - <cite>3</cite>: Interpolación bicúbica. Órdenes más altos proporcionan resultados más suaves pero aumentan el tiempo de cálculo.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>cupy.ndarray</strong>: La imagen ampliada como un arreglo basado en GPU con forma (<cite>new_height</cite>, <cite>new_width</cite>, 3).</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asegura que el arreglo de entrada sea de tipo <cite>uint8</cite> antes del procesamiento.</p></li>
<li><p>El <cite>mode=”constant”, cval=0.0</cite> asegura que los píxeles fuera de los límites se traten como cero durante la interpolación.</p></li>
<li><p>Se realiza una sincronización de la GPU (<cite>cp.cuda.Stream.null.synchronize()</cite>) para asegurar que todas las operaciones se completen antes de devolver el resultado.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Assume gpu_array is a 3D CuPy array representing an RGB image</span>
<span class="n">upscaled_image</span> <span class="o">=</span> <span class="n">upscale_c</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">new_width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">new_height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">order_</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto Bloom a una superficie de Pygame utilizando aceleración por GPU.</p>
<p>Esta función mejora las regiones brillantes de una imagen para crear un efecto de resplandor (bloom) utilizando un proceso de varios pasos que incluye: - Reducir la resolución de la imagen en sub-superficies progresivamente más pequeñas. - Aplicar un filtro de paso brillante para aislar las áreas brillantes. - Desenfocar las regiones brillantes utilizando un filtro gaussiano. - Ampliar y mezclar las capas procesadas de nuevo en la superficie original.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada a la que se aplicará el efecto bloom.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, opcional, predeterminado=128): El umbral de brillo para el filtro de paso brillante. Los píxeles con intensidad por encima de este valor contribuyen al efecto bloom. Debe estar en el rango [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, opcional, predeterminado=True): Cuando es <cite>True</cite>, solo se utiliza la reducción de resolución de menor resolución (x16) para el bloom. Cuando es <cite>False</cite>, se procesan y mezclan múltiples capas reducidas (x2, x4, x8, x16) para un efecto más detallado.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, opcional, predeterminado=pygame.BLEND_RGB_ADD): El modo de mezcla utilizado al fusionar el efecto bloom de nuevo en la superficie original. Los modos comunes incluyen: - <cite>pygame.BLEND_RGB_ADD</cite> (predeterminado) - <cite>pygame.BLEND_RGB_MULT</cite>, etc.</p></li>
<li><p><strong>factor_</strong> (<em>int</em>, opcional, predeterminado=2): Determina cuánto se reduce la textura. Debe estar en el rango [0, 4], correspondiendo a una reducción de: - 1 (sin reducción) - 2 (mitad del tamaño) - 4 (un cuarto del tamaño) - 8 (un octavo del tamaño).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: La superficie de entrada mezclada con el efecto bloom.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si la imagen de entrada es demasiado pequeña para ser procesada.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>El efecto bloom se logra a través de una serie de operaciones de reducción de resolución, filtrado y mezcla.</p></li>
<li><p>El modo <cite>pygame.BLEND_RGB_ADD</cite> se utiliza para agregar el efecto bloom a la superficie original.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surface</span> <span class="o">=</span> <span class="n">bloom_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">factor_</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_surface</span><span class="p">,</span> <span class="s2">&quot;bloomed_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bloom_array">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bloom_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fast_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bloom_array" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto Bloom a una imagen representada como un arreglo de GPU.</p>
<p>Esta función aplica un efecto bloom a un <cite>gpu_array_</cite> dado, que representa una imagen en la GPU. El proceso incluye: - Reducir la resolución de la imagen en versiones progresivamente más pequeñas (x2, x4, x8, x16). - Aplicar un filtro de paso brillante para aislar los píxeles de alta intensidad. - Desenfocar las regiones brillantes para crear un efecto de resplandor. - Ampliar y mezclar las imágenes procesadas para lograr el efecto bloom final.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>): Un arreglo 3D que representa la imagen en la memoria de la GPU. Debe tener el tipo de datos <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>threshold_</strong> (<em>int</em>, opcional, predeterminado=128): El umbral de brillo para el filtro de paso brillante. Los píxeles por encima de este valor contribuyen al bloom. Debe estar dentro del rango [0, 255].</p></li>
<li><p><strong>fast_</strong> (<em>bool</em>, opcional, predeterminado=True): Cuando es <cite>True</cite>, solo se utiliza la reducción de resolución de menor resolución (x16), reduciendo el tiempo de procesamiento. Cuando es <cite>False</cite>, se mezclan múltiples niveles (x2, x4, x8, x16) para un efecto bloom más rico.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, opcional, predeterminado=pygame.BLEND_RGB_ADD): El modo de mezcla utilizado al fusionar las capas del efecto bloom.</p></li>
<li><p><strong>mask_</strong> (<em>opcional</em>, predeterminado=None): Parámetro no utilizado, reservado para implementaciones futuras.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>tuple of pygame.Surface</strong>: Las superficies del efecto bloom procesadas en diferentes niveles de reducción de resolución (s2, s4, s8, s16). Si <cite>fast_</cite> está habilitado, solo se utiliza <cite>s16</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>El efecto bloom se logra a través de una serie de operaciones de reducción de resolución, filtrado y mezcla.</p></li>
<li><p>El modo <cite>pygame.BLEND_RGB_ADD</cite> se utiliza para agregar el efecto bloom a la superficie original.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Convert Pygame surface to CuPy array</span>
<span class="n">gpu_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="n">surface</span><span class="p">))</span>

<span class="c1"># Apply the bloom effect</span>
<span class="n">bloomed_surfaces</span> <span class="o">=</span> <span class="n">bloom_array</span><span class="p">(</span><span class="n">gpu_array</span><span class="p">,</span> <span class="n">threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">fast_</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Convert back to Pygame surfaces</span>
<span class="n">bloomed_images</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">make_surface</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">bloom</span><span class="p">))</span> <span class="k">for</span> <span class="n">bloom</span> <span class="ow">in</span> <span class="n">bloomed_surfaces</span><span class="p">]</span>

<span class="c1"># Save the new images</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bloomed_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bloomed_images</span><span class="p">):</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">bloomed_image</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;bloomed_image_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.cartoon_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">cartoon_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sobel_threshold_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">median_kernel_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contour_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.cartoon_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de dibujo animado a una superficie dada utilizando aceleración por GPU.</p>
<p>Esta función procesa una imagen para generar un efecto de dibujo animado aplicando detección de bordes, filtrado de mediana y cuantización de colores. El efecto también puede incluir contornos si está habilitado.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de la imagen de entrada que se procesará.</p></li>
<li><p><strong>sobel_threshold_</strong> (<em>int</em>, opcional, predeterminado=128): El valor de umbral para el filtro de detección de bordes Sobel.</p></li>
<li><p><strong>median_kernel_</strong> (<em>int</em>, opcional, predeterminado=2): Tamaño del kernel para el filtrado de mediana (utilizado para reducir el ruido mientras se preservan los bordes).</p></li>
<li><p><strong>color_</strong> (<em>int</em>, opcional, predeterminado=8): Número máximo de colores que se utilizarán en el efecto de dibujo animado (reducción de color).</p></li>
<li><p><strong>contour_</strong> (<em>bool</em>, opcional, predeterminado=False): Si se deben dibujar contornos en los bordes detectados en la imagen.</p></li>
<li><p><strong>flag_</strong> (<em>int</em>, opcional, predeterminado=BLEND_RGB_ADD): Modo de mezcla utilizado para combinar el efecto con la imagen original.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: La superficie transformada con el efecto de dibujo animado aplicado.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>El efecto de dibujo animado se logra a través de una serie de operaciones de detección de bordes, filtrado y mezcla.</p></li>
<li><p>El modo <cite>BLEND_RGB_ADD</cite> se utiliza para agregar el efecto de dibujo animado a la superficie original.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the cartoon effect</span>
<span class="n">cartoon_surface</span> <span class="o">=</span> <span class="n">cartoon_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">sobel_threshold_</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">median_kernel_</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color_</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">contour_</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">flag_</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">BLEND_RGB_ADD</span><span class="p">)</span>

<span class="c1"># Save the new image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">cartoon_surface</span><span class="p">,</span> <span class="s2">&quot;cartoon_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.blending_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">blending_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">percentage_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.blending_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Mezcla una textura fuente hacia una textura de destino (efecto de transición).</p>
<p>Esta función mezcla una superficie de Pygame fuente en una superficie de destino, creando un efecto de transición basado en el porcentaje especificado. La mezcla se realiza utilizando los siguientes cálculos: - <strong>Alpha</strong>: <cite>outA = SrcA + DstA * (1 - SrcA)</cite> - <strong>RGB</strong>: <cite>outRGB = SrcRGB + DstRGB * (1 - SrcA)</cite></p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>source_</strong> (<em>pygame.Surface</em>): La superficie fuente que se mezclará.</p></li>
<li><p><strong>destination_</strong> (<em>pygame.Surface</em>): La superficie de destino en la que se mezclará la fuente.</p></li>
<li><p><strong>percentage_</strong> (<em>float</em>): El porcentaje de mezcla, un valor entre 0.0 y 100.0, que representa la proporción de la fuente que se mezclará con el destino.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame de 24 bits con el resultado mezclado.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función asume que las superficies fuente y destino tienen el mismo tamaño.</p></li>
<li><p>La superficie de salida se convierte para un blitting rápido utilizando el método <cite>convert()</cite>.</p></li>
<li><p>El modo de mezcla utilizado es <cite>BLEND_RGB_ADD</cite>, que agrega el color de la fuente al color del destino. Este modo se puede ajustar cambiando el parámetro <cite>flag_</cite>.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load source and destination images</span>
<span class="n">source</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;source_image.png&#39;</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;destination_image.png&#39;</span><span class="p">)</span>

<span class="c1"># Apply blending with 50% source</span>
<span class="n">blended_surface</span> <span class="o">=</span> <span class="n">blending_gpu</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">)</span>

<span class="c1"># Save the blended image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">blended_surface</span><span class="p">,</span> <span class="s1">&#39;blended_image.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro de enfoque a la imagen pygame.Surface dada utilizando un kernel de filtro genérico.</p>
<p>La función enfoca la imagen de entrada aplicando un kernel de enfoque a cada canal RGB (rojo, verde, azul) de forma independiente. La imagen enfocada se devuelve en formato pygame.Surface de 24 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Un objeto de superficie pygame que representa la imagen de entrada que se enfocará.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie pygame con la imagen enfocada en formato de 24 bits (RGB).</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si la superficie de entrada no es una pygame.Surface válida o tiene dimensiones cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>El efecto de enfoque se logra mediante la convolución con un kernel de enfoque.</p></li>
<li><p>La superficie de salida se convierte para un blitting rápido utilizando el método <cite>convert()</cite>.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.ripple_effect_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">ripple_effect_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">previous</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.ripple_effect_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de gota de agua (ondulación) a una textura utilizando aceleración por GPU.</p>
<p>Esta función utiliza un kernel CUDA (<cite>ripple_kernel</cite>) para calcular el efecto de ondulación en la textura. Funciona manipulando el estado <cite>previous</cite> y <cite>current</cite> del efecto de ondulación y aplicándolo a la textura. El efecto se calcula en paralelo en la GPU, lo que lo hace eficiente para manejar texturas grandes o simulaciones.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>grid</strong> (<em>tuple</em>): Tupla que define el tamaño de la cuadrícula para la ejecución del kernel CUDA, por ejemplo, (25, 25). El tamaño de la cuadrícula debe coincidir con el tamaño de la textura para un procesamiento paralelo eficiente.</p></li>
<li><p><strong>block</strong> (<em>tuple</em>): Tupla que define el tamaño del bloque para la ejecución del kernel CUDA, por ejemplo, (32, 32). El número máximo de hilos es 1024 (block_x * block_y).</p></li>
<li><p><strong>w</strong> (<em>int</em>): El ancho de la textura y los arreglos.</p></li>
<li><p><strong>h</strong> (<em>int</em>): La altura de la textura y los arreglos.</p></li>
<li><p><strong>previous</strong> (<em>cupy.ndarray</em>): Un arreglo de CuPy con forma (w, h), que contiene el estado anterior del efecto de ondas (float32).</p></li>
<li><p><strong>current</strong> (<em>cupy.ndarray</em>): Un arreglo de CuPy con forma (w, h), que contiene el estado actual del efecto de ondas (float32).</p></li>
<li><p><strong>texture_array</strong> (<em>cupy.ndarray</em>): Un arreglo de CuPy con forma (w, h, 3), que contiene la textura de origen en RGB (uint8).</p></li>
<li><p><strong>background_array</strong> (<em>cupy.ndarray</em>): Un arreglo de CuPy con forma (w, h, 3), que representa la textura de fondo a la que se aplicará el efecto (uint8).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>tuple</strong>: Una tupla que contiene dos arreglos de CuPy, los estados actualizados de <cite>previous</cite> y <cite>current</cite> del efecto de ondas.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">512</span>

<span class="c1"># Initialize previous and current ripple states</span>
<span class="n">previous</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">current</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="c1"># Initialize texture and background arrays</span>
<span class="n">texture_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">background_array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c1"># Apply ripple effect</span>
<span class="n">updated_previous</span><span class="p">,</span> <span class="n">updated_current</span> <span class="o">=</span> <span class="n">ripple_effect_gpu</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">texture_array</span><span class="p">,</span> <span class="n">background_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>El tamaño de la cuadrícula y los bloques debe elegirse adecuadamente según el tamaño de la textura y los recursos disponibles de la GPU.</p></li>
<li><p>El cálculo del kernel se realiza en la GPU utilizando CuPy para una ejecución más rápida.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.sharpen1_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">sharpen1_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.sharpen1_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aumenta la nitidez de una imagen usando un kernel sin procesar.</p>
<p>Esta función aumenta la nitidez de la imagen de entrada aplicando un kernel de enfoque a cada canal RGB (rojo, verde, azul) de forma independiente. Los bordes no se procesan con el kernel (valor = 0).</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de imagen de entrada a afilar.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensiones de la cuadrícula para la ejecución del kernel de CUDA, por ejemplo, (25, 25). Los valores de la cuadrícula y los bloques deben coincidir con los tamaños de la textura y los arreglos.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensiones de los bloques para la ejecución del kernel de CUDA, por ejemplo, (32, 32). El número máximo de hilos es 1024. Máx. hilos = block_x * block_y.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Una nueva superficie de Pygame con la imagen afilada en formato de 24 bits (RGB).</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento eficiente.</p></li>
<li><p>El efecto de enfoque se logra mediante la convolución con un kernel de enfoque.</p></li>
<li><p>La superficie de salida se convierte para un blitting rápido utilizando el método <cite>convert()</cite>.</p></li>
</ul>
<p><strong>Ejemplo:</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pygame</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

<span class="c1"># Initialize Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="c1"># Load an image</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;image.png&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="c1"># Define grid and block dimensions</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Apply the sharpening filter</span>
<span class="n">sharpened_surface</span> <span class="o">=</span> <span class="n">sharpen1_gpu</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>

<span class="c1"># Save the sharpened image</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">sharpened_surface</span><span class="p">,</span> <span class="s2">&quot;sharpened_image.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.mirroring_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">mirroring_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.mirroring_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto espejo a una imagen utilizando aceleración GPU.</p>
<p>Esta función crea una versión reflejada de una imagen representada como <cite>pygame.Surface</cite>. Admite formatos de imagen de 32 y 24 bits y genera una imagen en formato de 24 bits. La orientación del espejo (horizontal o vertical) se controla mediante el parámetro <cite>format_</cite>.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada como un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Define las dimensiones de la cuadrícula como <cite>(grid_y, grid_x)</cite>, por ejemplo, <cite>(25, 25)</cite>. Las dimensiones de la cuadrícula y los bloques deben coincidir con los tamaños de la textura y los arreglos.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Especifica las dimensiones de los bloques como <cite>(block_y, block_x)</cite>, por ejemplo, <cite>(32, 32)</cite>. El número máximo de hilos por bloque es 1024, siguiendo la condición: <cite>Máx. hilos = block_x * block_y</cite>.</p></li>
<li><p><strong>format_</strong> (<em>bool</em>, opcional, por defecto=`False`): Determina la orientación del espejo: - <cite>False</cite> (0) → Reflejo horizontal (por defecto). - <cite>True</cite> (1) → Reflejo vertical.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Un <cite>pygame.Surface</cite> de 24 bits con el efecto espejo aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>surface_</cite> tiene un formato o dimensiones no válidas (<cite>w</cite> o <cite>h</cite> es 0).</p></li>
<li><p><strong>ValueError</strong>: Si <cite>surface_</cite> no se puede referenciar como un arreglo 3D.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función extrae los datos de píxeles de <cite>surface_</cite> y los convierte en un arreglo 3D.</p></li>
<li><p>La función <cite>mirroring_cupy</cite> realiza el reflejo acelerado por GPU y devuelve la imagen procesada.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.saturation_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">saturation_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.saturation_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Ajusta el nivel de saturación de una imagen dada utilizando aceleración GPU.</p>
<p>Esta función modifica la saturación de una imagen representada como <cite>pygame.Surface</cite>. Admite formatos de imagen de 32 y 24 bits, generando una salida en formato de 24 bits. El valor de ajuste de saturación debe estar dentro del rango [-1.0, 1.0].</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada como un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Define las dimensiones de la cuadrícula como <cite>(grid_y, grid_x)</cite>, por ejemplo, <cite>(25, 25)</cite>. Las dimensiones de la cuadrícula y los bloques deben coincidir con los tamaños de la textura y los arreglos.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Especifica las dimensiones de los bloques como <cite>(block_y, block_x)</cite>, por ejemplo, <cite>(32, 32)</cite>. El número máximo de hilos por bloque es 1024, siguiendo la condición: <cite>Máx. hilos = block_x * block_y</cite>.</p></li>
<li><p><strong>val_</strong> (<em>float</em>, opcional, por defecto=`1.0`): Nivel de ajuste de saturación en el rango <cite>[-1.0, 1.0]</cite>. - <cite>-1.0</cite> → Completamente desaturado (escala de grises). - <cite>0.0</cite> → Sin cambios en la saturación. - <cite>1.0</cite> → Totalmente saturado.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Un <cite>pygame.Surface</cite> de 24 bits con el nivel de saturación ajustado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>surface_</cite> tiene un formato o dimensiones no válidas (<cite>w</cite> o <cite>h</cite> es 0).</p></li>
<li><p><strong>ValueError</strong>: Si <cite>val_</cite> está fuera del rango <cite>[-1.0, 1.0]</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función extrae los datos de píxeles de <cite>surface_</cite> y los convierte en un arreglo 3D.</p></li>
<li><p>La función <cite>saturation_cupy</cite> realiza el ajuste de saturación acelerado por GPU y devuelve la imagen procesada.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.bilateral_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">bilateral_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.bilateral_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un filtro bilateral a una imagen de 32 o 24 bits usando la GPU.</p>
<p>El filtro bilateral es un filtro de suavizado no lineal que conserva los bordes y reduce el ruido. Reemplaza la intensidad de cada píxel con un promedio ponderado de los píxeles cercanos, donde los pesos se determinan tanto por la proximidad espacial como por las diferencias de intensidad, siguiendo una distribución gaussiana.</p>
<p>Los parámetros del filtro (<cite>sigma_r</cite> y <cite>sigma_s</cite>) están predefinidos dentro del kernel de la GPU. Esta función es compatible con imágenes de 32 y 24 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada como un objeto <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>kernel_size_</strong> (<em>int</em>): Tamaño del kernel, que determina el número de píxeles adyacentes incluidos en el cálculo.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Un <cite>pygame.Surface</cite> nuevo de 24 bits con el efecto de filtrado bilateral aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una instancia de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si las dimensiones de <cite>surface_</cite> son cero o si <cite>kernel_size_</cite> es negativo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función extrae los datos de píxeles de <cite>surface_</cite> y los convierte en un arreglo 3D.</p></li>
<li><p>La función <cite>bilateral_cupy</cite> realiza el filtrado bilateral acelerado por GPU y devuelve la imagen procesada.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.emboss5x5_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">emboss5x5_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.emboss5x5_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de relieve a una imagen de 32 o 24 bits utilizando un kernel de convolución 5x5.</p>
<dl class="simple">
<dt>El kernel de relieve utilizado:</dt><dd><p>[-2.0, -1.0,  0.0,  1.0,  2.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[ 0.0,  2.0,  4.0,  6.0,  8.0]
[-1.0,  1.0,  2.0,  3.0,  4.0]
[-2.0, -1.0,  0.0,  1.0,  2.0]</p>
</dd>
</dl>
<p>Cada canal RGB de la imagen de entrada se procesa de forma independiente mediante convolución. La imagen de entrada debe estar en formato de 32 o 24 bits, y la salida será una imagen de 24 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada como un objeto <cite>pygame.Surface</cite>.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p><strong>pygame.Surface</strong>: Un <cite>pygame.Surface</cite> nuevo de 24 bits con el efecto de relieve aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una instancia de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si no se puede acceder a los datos de píxeles de <cite>surface_</cite> o si su ancho/alto es cero.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función extrae los datos de píxeles de <cite>surface_</cite> y los convierte en un arreglo 3D.</p></li>
<li><p>La función <cite>emboss_cupy</cite> realiza el efecto de relieve acelerado por GPU y devuelve la imagen procesada.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.area24_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">area24_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rgb_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cupy.asarray([128.0,</span> <span class="pre">128.0,</span> <span class="pre">128.0],</span> <span class="pre">dtype=cupy.float32,</span> <span class="pre">copy=False)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.area24_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica una superposición de color a un área específica en una imagen RGB de 24 bits utilizando aceleración por GPU.</p>
<p>Esta función modifica el color de una región en el <cite>rgb_array</cite> en las coordenadas <cite>(x, y)</cite>, mezclándolo con el <cite>color</cite> dado según los parámetros <cite>mask_alpha</cite> e <cite>intensity</cite>. Utiliza CuPy para cálculos rápidos basados en GPU.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>x</strong> (<em>int</em>): Coordenada X del píxel objetivo en la imagen.</p></li>
<li><p><strong>y</strong> (<em>int</em>): Coordenada Y del píxel objetivo en la imagen.</p></li>
<li><p><strong>rgb_array</strong> (<em>cupy.ndarray</em>): Un array 3D que representa la imagen RGB almacenada en la memoria de la GPU. Debe tener una forma de <cite>(altura, ancho, 3)</cite>.</p></li>
<li><p><strong>mask_alpha</strong> (<em>cupy.ndarray</em>): Máscara alfa que determina el efecto de transparencia aplicado a la superposición de color. Debe coincidir con la forma de <cite>rgb_array</cite>.</p></li>
<li><p><strong>intensity</strong> (<em>float</em>, opcional, predeterminado=`1.0`): Factor de escala para el efecto de superposición. Determina cuánto se mezcla el <cite>color</cite> con la imagen original. Debe estar en el rango <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>color</strong> (<em>cupy.ndarray</em>, opcional, predeterminado=`[128.0, 128.0, 128.0]`): Un array de 3 elementos que representa el color RGB a mezclar.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>tuple</em>): Los valores RGB modificados en <cite>(x, y)</cite> después de aplicar el efecto.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si <cite>x</cite> o <cite>y</cite> están fuera de los límites.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>intensity</cite> no está dentro de <cite>[0.0, 1.0]</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>rgb_array</cite> o <cite>mask_alpha</cite> tienen formas incompatibles.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU con CuPy para un procesamiento rápido de imágenes.</p></li>
<li><p>El efecto de mezcla de color se basa en la máscara alfa y la intensidad, permitiendo una transparencia personalizable.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.brightness_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">brightness_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">brightness_factor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.brightness_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Ajusta el brillo de una imagen dada utilizando aceleración por GPU.</p>
<p>Esta función modifica el brillo de un <cite>pygame.Surface</cite> aplicando una transformación acelerada por GPU. Procesa eficientemente imágenes de 24 y 32 bits, aprovechando CUDA para cálculos paralelos.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada a procesar. Debe estar en formato de 24 o 32 bits.</p></li>
<li><p><strong>brightness_factor</strong> (<em>float</em>): Factor de escala de brillo. - Valores mayores que <cite>1.0</cite> aumentan el brillo. - Valores entre <cite>0.0</cite> y <cite>1.0</cite> disminuyen el brillo. - <cite>1.0</cite> mantiene el brillo original.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensiones de la cuadrícula <cite>(grid_y, grid_x)</cite>, por ejemplo, <cite>(25, 25)</cite>. Define cómo se divide la imagen para la ejecución paralela en la GPU. Debe coincidir con los tamaños de la textura y el array.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensiones del bloque <cite>(block_y, block_x)</cite>, por ejemplo, <cite>(32, 32)</cite>. Determina el número de hilos por bloque para la ejecución en CUDA. El producto <cite>block_x * block_y</cite> no debe exceder <cite>1024</cite> (límite máximo de hilos por bloque en CUDA).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Una nueva superficie con el brillo modificado en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es de tipo <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>brightness_factor</cite> es negativo.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función aprovecha la aceleración por GPU para procesar la imagen de manera eficiente, haciéndola adecuada para imágenes grandes o aplicaciones en tiempo real.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.hsl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">hsl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.hsl_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica una rotación HSL (Tono, Saturación, Luminosidad) a una imagen utilizando aceleración por GPU.</p>
<p>Esta función rota el color de los píxeles en una imagen o textura representada por un <cite>pygame.Surface</cite> modificando el componente de tono del modelo de color HSL. Soporta formatos de imagen de 24 y 32 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de la imagen de entrada que se procesará.</p></li>
<li><p><strong>val_</strong> (<em>float</em>): Un valor flotante que representa el valor de rotación del tono. El tono se ajusta rotando su valor en el espacio de color HSL.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>, opcional): Dimensiones de la cuadrícula <cite>(grid_y, grid_x)</cite>, por ejemplo, <cite>(25, 25)</cite>. Define cómo se divide la imagen para la ejecución paralela en la GPU. Las dimensiones de la cuadrícula y el bloque deben coincidir con los tamaños de la textura y el array.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>, opcional): Dimensiones del bloque <cite>(block_y, block_x)</cite>, por ejemplo, <cite>(32, 32)</cite>. Especifica el número de hilos por bloque para la ejecución en CUDA. El número máximo de hilos por bloque es 1024, por lo que <cite>block_x * block_y</cite> no debe exceder este límite.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nuevo <cite>pygame.Surface</cite> con el tono modificado según el valor de rotación dado.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función aplica una operación acelerada por GPU para rotar el componente de tono de la imagen, permitiendo un procesamiento eficiente para imágenes grandes o aplicaciones en tiempo real.</p></li>
<li><p>Los parámetros <cite>grid_</cite> y <cite>block_</cite> son opcionales, pero deben proporcionarse para que el procesamiento paralelo funcione de manera óptima en la GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.dithering_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">dithering_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpu_array_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.dithering_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de difuminado a una imagen utilizando aceleración por GPU.</p>
<p>Esta función aplica un efecto de difuminado a una imagen RGB utilizando un núcleo CUDA. La operación se realiza en la GPU para un procesamiento rápido. La imagen se normaliza primero, se procesa utilizando el núcleo de difuminado y luego se convierte de nuevo a formato de 8 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>gpu_array_</strong> (<em>cupy.ndarray</em>): Un array de CuPy con forma <cite>(w, h, 3)</cite> que contiene los datos de la imagen en formato RGB. Debe ser de tipo <cite>cupy.uint8</cite>.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensiones de la cuadrícula CUDA <cite>(grid_y, grid_x)</cite>. Define cómo se distribuye el cálculo en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensiones del bloque CUDA <cite>(block_y, block_x)</cite>. El número de hilos por bloque no debe exceder 1024.</p></li>
<li><p><strong>factor_</strong> (<em>float</em>, opcional, predeterminado=`1.0`): Un factor que controla la intensidad del difuminado. Un valor mayor aumenta el efecto de difuminado.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nuevo <cite>pygame.Surface</cite> que contiene la imagen procesada en formato RGB.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>gpu_array_</cite> no es un ndarray de CuPy.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>gpu_array_</cite> no es de tipo <cite>cupy.uint8</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza un núcleo CUDA (<cite>dithering_kernel</cite>) para un procesamiento de alto rendimiento.</p></li>
<li><p>La imagen de entrada se normaliza a [0, 1] antes del procesamiento y luego se convierte de nuevo a [0, 255].</p></li>
<li><p>Los tamaños de la cuadrícula y el bloque deben elegirse adecuadamente según las dimensiones de la imagen y los recursos de la GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.fisheye_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">fisheye_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">focal_texture</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.fisheye_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de lente ojo de pez a un <cite>pygame.Surface</cite> utilizando aceleración por GPU.</p>
<p>Esta función aplica un efecto de distorsión ojo de pez a una superficie dada utilizando procesamiento basado en CUDA. Está optimizada para renderizado en tiempo real y puede usarse para mostrar escenas de juegos a través de un efecto de lente.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Superficie de pygame de entrada en formato de 24 o 32 bits.</p></li>
<li><p><strong>focal</strong> (<em>float</em>): Longitud focal del efecto ojo de pez, controlando la intensidad de la distorsión.</p></li>
<li><p><strong>focal_texture</strong> (<em>float</em>): Longitud focal de la textura, ajustando aún más la intensidad del efecto ojo de pez.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensiones de la cuadrícula CUDA <cite>(grid_y, grid_x)</cite>. Define cómo se distribuye el cálculo en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensiones del bloque CUDA <cite>(block_y, block_x)</cite>. El número máximo de hilos por bloque no debe exceder 1024.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nuevo <cite>pygame.Surface</cite> con el efecto de lente ojo de pez aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una instancia de <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si la función no puede acceder a los datos de píxeles de <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función aprovecha CUDA para un procesamiento de imágenes de alto rendimiento.</p></li>
<li><p>El efecto se aplica directamente a la superficie de entrada y se devuelve como una superficie transformada.</p></li>
<li><p>Asegúrese de que los valores de la cuadrícula y el bloque se elijan para que coincidan con los tamaños de la textura y el array para un rendimiento óptimo.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.swirl_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">swirl_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.swirl_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de distorsión de remolino a una imagen utilizando aceleración por GPU.</p>
<p>Esta función crea un efecto de remolino en un <cite>pygame.Surface</cite> dado aplicando una transformación basada en CUDA. El efecto distorsiona los píxeles radialmente alrededor de un punto central especificado.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): Superficie de entrada, debe estar en formato de 24 o 32 bits.</p></li>
<li><p><strong>rad</strong> (<em>float</em>): Ángulo de rotación en radianes, controlando la intensidad del remolino.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Tamaño de la cuadrícula CUDA, típicamente <cite>(grid_y, grid_x)</cite>. Define cómo se distribuye el cálculo en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Tamaño del bloque CUDA, típicamente <cite>(block_y, block_x)</cite>. El número de hilos por bloque no debe exceder 1024.</p></li>
<li><p><strong>centre_x</strong> (<em>int</em>): Coordenada X del centro del remolino (debe ser mayor que 0).</p></li>
<li><p><strong>centre_y</strong> (<em>int</em>): Coordenada Y del centro del remolino (debe ser mayor que 0).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nuevo <cite>pygame.Surface</cite> con el efecto de remolino aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>ValueError</strong>: Si la superficie de entrada no puede ser referenciada como un array 3D.</p></li>
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite> válida.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función opera directamente en la GPU utilizando CuPy para un alto rendimiento.</p></li>
<li><p>Asegúrese de que <cite>grid_</cite> y <cite>block_</cite> estén configurados correctamente para una ejecución óptima.</p></li>
<li><p>La función llama a <cite>swirl_cupy</cite>, que maneja el procesamiento real basado en GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wave_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wave_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wave_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Crea un efecto de onda en una imagen utilizando aceleración por GPU.</p>
<p>Esta función aplica un efecto de distorsión de onda a un <cite>pygame.Surface</cite> dado mediante una transformación basada en CUDA. El efecto crea un movimiento de onda realista en la imagen basado en el ángulo y el tamaño de bloque especificados.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de la imagen de entrada, que debe estar en formato de 24 o 32 bits.</p></li>
<li><p><strong>rad_</strong> (<em>float</em>): Un ángulo variable en radianes que controla el efecto de onda.</p></li>
<li><p><strong>size_</strong> (<em>int</em>): El tamaño del bloque para el efecto de onda. Para una onda realista, se recomienda mantener el tamaño por debajo de 15.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Tamaño de la cuadrícula CUDA, típicamente <cite>(grid_y, grid_x)</cite>, define cómo se distribuye el cálculo en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Tamaño del bloque CUDA, típicamente <cite>(block_y, block_x)</cite>, el número de hilos por bloque no debe exceder 1024.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Un nuevo <cite>pygame.Surface</cite> con el efecto de onda aplicado. Se recomienda reescalar la imagen para ocultar cualquier distorsión visible alrededor de los bordes izquierdo e inferior, especialmente si se nota un efecto de envoltura de textura.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Ejemplo de uso: <cite>IMAGE = wave_gpu(IMAGE, 8 * math.pi/180.0 + FRAME/10, 8, grid, block)</cite> <cite>IMAGE = scale(IMAGE, (WIDTH + 16, HEIGHT + 16))</cite> para ocultar el efecto de envoltura.</p></li>
<li><p>La función opera directamente en la GPU utilizando CuPy para un alto rendimiento.</p></li>
<li><p>Asegúrese de que las configuraciones de la cuadrícula y el bloque estén seleccionadas correctamente para un rendimiento óptimo.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.chromatic_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">chromatic_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.999</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.chromatic_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de desplazamiento cromático a una superficie dada utilizando aceleración por GPU.</p>
<p>Este efecto crea una separación de colores desplazando los canales RGB según los valores de desplazamiento horizontal y vertical especificados. La función está optimizada para formatos de imagen de 24 y 32 bits.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada a procesar. Debe estar en formato de 24 o 32 bits.</p></li>
<li><p><strong>delta_x</strong> (<em>int</em>): Desplazamiento horizontal para el cambio cromático. Afecta los canales rojo y azul, creando un efecto de separación de colores. Un valor de cero resulta en ningún desplazamiento horizontal (si <cite>fx</cite> es bajo).</p></li>
<li><p><strong>delta_y</strong> (<em>int</em>): Desplazamiento vertical para el cambio cromático. Funciona de manera similar a <cite>delta_x</cite>, pero se aplica al movimiento vertical. Un valor de cero resulta en ningún desplazamiento vertical (si <cite>fx</cite> es bajo).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa las dimensiones de la cuadrícula, por ejemplo, <cite>(25, 25)</cite>. Define la división de la imagen para el procesamiento en GPU y debe coincidir con los tamaños de la textura y el array.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa las dimensiones del bloque, por ejemplo, <cite>(32, 32)</cite>. Determina el número de hilos por bloque en el procesamiento en GPU. El producto <cite>block_x * block_y</cite> no debe exceder 1024 (el límite de CUDA para hilos por bloque).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, opcional, predeterminado=`0.999`): Un factor de zoom que controla la escala de la imagen después del procesamiento. Debe estar en el rango <cite>(0.0, 1.0)</cite>. El valor predeterminado es <cite>1.0</cite> (sin zoom).</p></li>
<li><p><strong>fx</strong> (<em>float</em>, opcional, predeterminado=`0.05`): Intensidad del efecto cromático, controlando la fuerza de la separación de colores. Debe estar dentro del rango <cite>[0.0, 0.2]</cite>. El valor predeterminado es <cite>0.05</cite>.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>cupy.ndarray</em>): Un array de CuPy que representa la imagen procesada con el efecto de desplazamiento cromático aplicado. El formato de salida es una imagen de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es de tipo <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>surface_</cite> tiene ancho o altura cero.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>delta_x</cite> o <cite>delta_y</cite> son negativos.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función aprovecha la aceleración por GPU para un desplazamiento cromático eficiente.</p></li>
<li><p>Asegúrese de que los tamaños de la cuadrícula y el bloque se elijan adecuadamente según el tamaño de la imagen y las capacidades de la GPU.</p></li>
<li><p>El parámetro <cite>fx</cite> controla la fuerza del efecto de separación cromática, y <cite>zoom</cite> permite redimensionar después de la transformación.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.rgb_split_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">rgb_split_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.rgb_split_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de división RGB a una imagen utilizando aceleración por GPU.</p>
<p>Esta función desplaza los canales rojo, verde y azul de una imagen en <cite>delta_x</cite> y <cite>delta_y</cite> para crear un efecto de aberración cromática (glitch). La transformación se realiza completamente en la GPU utilizando CuPy.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada en formato de 24 o 32 bits.</p></li>
<li><p><strong>delta_x</strong> (<em>float</em>): El desplazamiento horizontal aplicado a los canales RGB. Un valor positivo desplaza los canales a la derecha, y un valor negativo los desplaza a la izquierda.</p></li>
<li><p><strong>delta_y</strong> (<em>float</em>): El desplazamiento vertical aplicado a los canales RGB. Un valor positivo desplaza los canales hacia abajo, y un valor negativo los desplaza hacia arriba.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa el tamaño de la cuadrícula para la ejecución en CUDA, definiendo la distribución del cálculo en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa el tamaño del bloque, que determina el número de hilos por bloque en la ejecución en GPU.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): Una nueva superficie con el efecto de división RGB aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>delta_x</cite> o <cite>delta_y</cite> son valores no positivos o si la función no puede acceder a los datos de píxeles de <cite>surface_</cite>.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>El efecto de división RGB crea una distorsión cromática, comúnmente utilizada en efectos de glitch.</p></li>
<li><p><cite>delta_x</cite> y <cite>delta_y</cite> definen cuánto se desplazan los canales de color.</p></li>
<li><p>Asegúrese de que los valores de <cite>grid_</cite> y <cite>block_</cite> estén optimizados para la ejecución en GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.zoom_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">zoom_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.zoom_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de zoom utilizando aceleración por GPU.</p>
<p>Esta función procesa un <cite>pygame.Surface</cite> mapeando sus datos de píxeles a la memoria de la GPU y aplicando una transformación de zoom. Utiliza aceleración CUDA para un procesamiento de imágenes de alto rendimiento.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada a procesar. Debe ser una imagen en formato de 24 o 32 bits.</p></li>
<li><p><strong>centre_x</strong> (<em>unsigned int</em>): La coordenada X del centro del zoom. Debe ser mayor o igual a 0.</p></li>
<li><p><strong>centre_y</strong> (<em>unsigned int</em>): La coordenada Y del centro del zoom. Debe ser mayor o igual a 0.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa las dimensiones de la cuadrícula. Define la división de la imagen para el procesamiento paralelo en GPU. Los valores deben coincidir con los tamaños de la textura y el array.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa las dimensiones del bloque. Determina el número de hilos por bloque en la ejecución en GPU. El producto <cite>block_x * block_y</cite> no debe exceder <cite>1024</cite> (límite de CUDA).</p></li>
<li><p><strong>zoom</strong> (<em>float</em>, opcional): Un factor de zoom que controla la escala de la imagen. Debe estar dentro del rango <cite>(0.0, 1.0]</cite>. El valor predeterminado es <cite>1.0</cite> (sin escalado).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>CuPy ndarray</em>): Un array de CuPy que contiene la imagen transformada con el zoom aplicado, en formato de 24 bits.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: - Si el ancho o la altura de <cite>surface_</cite> es 0. - Si <cite>zoom</cite> no está dentro del rango <cite>(0.0, 1.0]</cite>. - Si <cite>centre_x</cite> o <cite>centre_y</cite> es negativo. - Si <cite>surface_</cite> no puede mapearse a un array 3D.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función realiza el efecto de zoom mapeando los datos de píxeles a la memoria de la GPU y utilizando CUDA para un procesamiento de alto rendimiento.</p></li>
<li><p>Asegúrese de que <cite>grid_</cite> y <cite>block_</cite> estén optimizados para las capacidades de su GPU y el tamaño de la imagen.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.wavelength_map_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">wavelength_map_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layer_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.wavelength_map_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de color específico del canal (escala de rojo, escala de verde o escala de azul) a una imagen.</p>
<p>Esta función aplica un efecto de escala de rojo, escala de verde o escala de azul a una imagen <cite>pygame.Surface</cite> dada. Aísla y enfatiza uno de los canales de color (Rojo, Verde o Azul) según el parámetro <cite>layer_</cite> proporcionado. La operación se realiza utilizando aceleración por GPU para un mejor rendimiento.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada a la que se aplicará el efecto.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa la configuración de la cuadrícula. Los valores de la cuadrícula deben coincidir con los tamaños de la imagen y el array.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa la configuración del bloque. Los valores del bloque determinan cuántos hilos se lanzan por bloque.</p></li>
<li><p><strong>layer_</strong> (<em>unsigned short int</em>, opcional): Especifica qué canal de color aislar. El valor predeterminado es <cite>0</cite> (canal Rojo). Los valores son: - <cite>0</cite> para el canal Rojo - <cite>1</cite> para el canal Verde - <cite>2</cite> para el canal Azul</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): La imagen con el efecto de canal seleccionado (escala de rojo, escala de verde o escala de azul) aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si el valor de <cite>layer_</cite> no está dentro del rango de 0 a 2.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función utiliza aceleración por GPU para un procesamiento de imágenes de alto rendimiento.</p></li>
<li><p>El parámetro <cite>layer_</cite> determina qué canal de color se enfatiza.</p></li>
<li><p>El resultado es un nuevo <cite>pygame.Surface</cite> con el efecto de canal de color seleccionado aplicado.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de mapa de calor a una imagen con inversión opcional.</p>
<p>Esta función aplica un efecto de mapa de calor a una imagen utilizando aceleración por GPU. El efecto de mapa de calor se utiliza típicamente para visualizar la intensidad o magnitud en una superficie 2D. El efecto puede invertirse según el parámetro <cite>invert_</cite>, cambiando la representación del color.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La imagen de entrada a la que se aplicará el efecto de mapa de calor.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa la configuración de la cuadrícula. Los valores de la cuadrícula deben coincidir con los tamaños de la textura y el array para la ejecución paralela en la GPU.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa la configuración del bloque. Define el número de hilos por bloque para la ejecución en GPU. El producto <cite>block_x * block_y</cite> no debe exceder <cite>1024</cite> (el máximo de hilos por bloque en CUDA).</p></li>
<li><p><strong>invert_</strong> (<em>boolean</em>, opcional): Si es <cite>True</cite>, el rango de colores del mapa de calor se invierte. El valor predeterminado es <cite>False</cite>, lo que significa que no hay inversión.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): La imagen con el efecto de mapa de calor aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>invert_</cite> no es un booleano.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento de imágenes de alto rendimiento.</p></li>
<li><p>La inversión del mapa de calor permite una representación de color diferente.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.heatmap_gpu_inplace">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">heatmap_gpu_inplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invert_</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.heatmap_gpu_inplace" title="Link to this definition">¶</a></dt>
<dd><p>Aplica el efecto de mapa de calor en el lugar a un <cite>pygame.Surface</cite>.</p>
<p>Esta función aplica un efecto de mapa de calor a la superficie de entrada en el lugar, modificando los datos de píxeles directamente sin devolver una nueva superficie. La visualización del mapa de calor mejora la intensidad de la imagen basándose en un mapeo de colores, con la opción de invertir el efecto de color.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie sobre la que se aplicará el efecto de mapa de calor. La superficie debe ser un <cite>pygame.Surface</cite> válido que contenga datos de píxeles en un array 3D (canales RGB).</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa la configuración de la cuadrícula para la ejecución paralela en GPU. Los valores de la cuadrícula deben coincidir con los tamaños del array y la textura.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa la configuración del bloque. Define el número de hilos por bloque para el cálculo en GPU. El producto <cite>block_x * block_y</cite> no debe exceder <cite>1024</cite> (el máximo de hilos por bloque en CUDA).</p></li>
<li><p><strong>invert_</strong> (<em>boolean</em>, opcional): Si es <cite>True</cite>, el efecto de mapa de calor se invierte, invirtiendo el rango de colores. El valor predeterminado es <cite>False</cite> (sin inversión).</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>void</em>): Esta función modifica <cite>surface_</cite> directamente y no devuelve ningún valor.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>invert_</cite> no es un booleano.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>La función utiliza aceleración por GPU para un procesamiento de imágenes de alto rendimiento.</p></li>
<li><p>El efecto se aplica en el lugar, lo que significa que la entrada <cite>surface_</cite> se modifica directamente.</p></li>
<li><p>La inversión del mapa de calor permite una representación de color invertida.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.predator_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">predator_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_smooth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv_colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bloom_flag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">pygame.BLEND_RGB_ADD</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.predator_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Aplica un efecto de visión de depredador utilizando aceleración por GPU.</p>
<p>Esta función procesa el <cite>pygame.Surface</cite> de entrada para aplicar un efecto de visión de depredador utilizando aceleración por GPU. El efecto simula un filtro de visión con ajustes de bloom y mapa de colores, que se pueden personalizar según los parámetros proporcionados.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada a procesar.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Una tupla <cite>(grid_y, grid_x)</cite> que representa las dimensiones de la cuadrícula para la ejecución del núcleo CUDA.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Una tupla <cite>(block_y, block_x)</cite> que representa las dimensiones del bloque para la ejecución del núcleo CUDA.</p></li>
<li><p><strong>bloom_smooth</strong> (<em>unsigned int</em>, opcional): El factor de suavizado para el efecto de bloom. El valor predeterminado es <cite>50</cite>.</p></li>
<li><p><strong>bloom_threshold</strong> (<em>unsigned int</em>, opcional): El umbral de intensidad para el efecto de bloom. El valor predeterminado es <cite>50</cite>.</p></li>
<li><p><strong>inv_colormap</strong> (<em>boolean</em>, opcional): Si se debe invertir el mapa de colores. El valor predeterminado es <cite>False</cite>.</p></li>
<li><p><strong>blend</strong> (<em>int</em>, opcional): El modo de mezcla para la renderización final. El valor predeterminado es <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
<li><p><strong>bloom_flag</strong> (<em>boolean</em>, opcional): Bandera para habilitar el efecto de bloom. El valor predeterminado es <cite>pygame.BLEND_RGB_ADD</cite>.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>pygame.Surface</em>): La superficie procesada con el efecto de visión de depredador aplicado.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>bloom_smooth</cite>, <cite>bloom_threshold</cite> no son enteros positivos o si <cite>blend</cite> no es un modo de mezcla válido.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función utiliza aceleración por GPU para aplicar un efecto de visión de depredador rápido.</p></li>
<li><p>El efecto de bloom simula áreas brillantes de alta intensidad, y el mapa de colores se puede invertir para diferentes efectos visuales.</p></li>
<li><p>Los parámetros <cite>blend</cite> y <cite>bloom_flag</cite> permiten personalizar el efecto de renderización final.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="Shader_gpu.downscale_surface_gpu">
<span class="sig-prename descclassname"><span class="pre">Shader_gpu.</span></span><span class="sig-name descname"><span class="pre">downscale_surface_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">surface_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zoom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Shader_gpu.downscale_surface_gpu" title="Link to this definition">¶</a></dt>
<dd><p>Reduce la escala de una superficie de pygame utilizando CUDA en CuPy.</p>
<p>Esta función extrae los datos de píxeles de un <cite>pygame.Surface</cite>, los transfiere a la GPU, aplica una operación de reducción de escala utilizando un núcleo CUDA y devuelve la imagen procesada en un búfer de bytes.</p>
<p><strong>Parámetros:</strong></p>
<ul class="simple">
<li><p><strong>surface_</strong> (<em>pygame.Surface</em>): La superficie de entrada a reducir.</p></li>
<li><p><strong>grid_</strong> (<em>tuple</em>): Dimensiones de la cuadrícula CUDA para la ejecución del núcleo.</p></li>
<li><p><strong>block_</strong> (<em>tuple</em>): Dimensiones del bloque CUDA para la ejecución del núcleo.</p></li>
<li><p><strong>zoom</strong> (<em>float</em>): El factor de escala para la reducción de escala. Debe estar en el rango <cite>[0.0, 0.9999]</cite>.</p></li>
<li><p><strong>w2</strong> (<em>int</em>): El ancho objetivo de la imagen reducida.</p></li>
<li><p><strong>h2</strong> (<em>int</em>): La altura objetivo de la imagen reducida.</p></li>
</ul>
<p><strong>Devuelve:</strong></p>
<ul class="simple">
<li><p>(<em>bytes</em>): La imagen reducida en formato RGB como un búfer de bytes.</p></li>
</ul>
<p><strong>Lanza:</strong></p>
<ul class="simple">
<li><p><strong>TypeError</strong>: Si <cite>surface_</cite> no es una <cite>pygame.Surface</cite>.</p></li>
<li><p><strong>ValueError</strong>: Si <cite>zoom</cite> no está en el rango <cite>[0.0, 0.9999]</cite>, o si <cite>w2</cite> o <cite>h2</cite> son valores no positivos.</p></li>
</ul>
<p><strong>Notas:</strong></p>
<ul class="simple">
<li><p>Esta función utiliza aceleración por GPU con CuPy para una reducción de escala eficiente.</p></li>
<li><p>La imagen reducida se devuelve como un búfer de bytes en formato RGB.</p></li>
<li><p>Asegúrese de que los valores de la cuadrícula y el bloque estén optimizados para el rendimiento de la GPU.</p></li>
</ul>
</dd></dl>

<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Tabla de contenido</a></h3>
    <ul>
<li><a class="reference internal" href="#">Shader_gpu</a><ul>
<li><a class="reference internal" href="#gpu-accelerated-image-processing-library">1. Biblioteca de Procesamiento de Imágenes Acelerada por GPU</a></li>
<li><a class="reference internal" href="#key-features-use-cases">2. Características Clave y Casos de Uso</a></li>
<li><a class="reference internal" href="#use-case">3. Caso de Uso</a></li>
<li><a class="reference internal" href="#potential-applications">4. Aplicaciones Potenciales</a></li>
<li><a class="reference internal" href="#summary">5. Resumen</a></li>
<li><a class="reference internal" href="#cython-list-methods">6. Métodos de listas en Cython</a><ul>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_free_mem"><code class="docutils literal notranslate"><span class="pre">get_gpu_free_mem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_maxmem"><code class="docutils literal notranslate"><span class="pre">get_gpu_maxmem()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_pci_bus_id"><code class="docutils literal notranslate"><span class="pre">get_gpu_pci_bus_id()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_compute_capability"><code class="docutils literal notranslate"><span class="pre">get_compute_capability()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_max_grid_per_block"><code class="docutils literal notranslate"><span class="pre">get_max_grid_per_block()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_grid"><code class="docutils literal notranslate"><span class="pre">block_grid()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.conv"><code class="docutils literal notranslate"><span class="pre">conv()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.block_and_grid_info"><code class="docutils literal notranslate"><span class="pre">block_and_grid_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.get_gpu_info"><code class="docutils literal notranslate"><span class="pre">get_gpu_info()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu"><code class="docutils literal notranslate"><span class="pre">invert_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">invert_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">invert_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.invert_rgb_array_inplace"><code class="docutils literal notranslate"><span class="pre">invert_rgb_array_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_rgb_array_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_rgb_array_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sepia_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">sepia_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_inplace_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_inplace_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bpf_buffer_gpu"><code class="docutils literal notranslate"><span class="pre">bpf_buffer_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.grayscale_lum_gpu"><code class="docutils literal notranslate"><span class="pre">grayscale_lum_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_generic_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_generic_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.median_filter_gpu"><code class="docutils literal notranslate"><span class="pre">median_filter_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_5x5_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.gaussian_3x3_gpu"><code class="docutils literal notranslate"><span class="pre">gaussian_3x3_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sobel_gpu"><code class="docutils literal notranslate"><span class="pre">sobel_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.prewitt_gpu"><code class="docutils literal notranslate"><span class="pre">prewitt_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.canny_gpu"><code class="docutils literal notranslate"><span class="pre">canny_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.color_reduction_gpu"><code class="docutils literal notranslate"><span class="pre">color_reduction_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsv_gpu"><code class="docutils literal notranslate"><span class="pre">hsv_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mult_downscale_gpu"><code class="docutils literal notranslate"><span class="pre">mult_downscale_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.upscale_c"><code class="docutils literal notranslate"><span class="pre">upscale_c()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_gpu"><code class="docutils literal notranslate"><span class="pre">bloom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bloom_array"><code class="docutils literal notranslate"><span class="pre">bloom_array()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.cartoon_gpu"><code class="docutils literal notranslate"><span class="pre">cartoon_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.blending_gpu"><code class="docutils literal notranslate"><span class="pre">blending_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.ripple_effect_gpu"><code class="docutils literal notranslate"><span class="pre">ripple_effect_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.sharpen1_gpu"><code class="docutils literal notranslate"><span class="pre">sharpen1_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.mirroring_gpu"><code class="docutils literal notranslate"><span class="pre">mirroring_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.saturation_gpu"><code class="docutils literal notranslate"><span class="pre">saturation_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.bilateral_gpu"><code class="docutils literal notranslate"><span class="pre">bilateral_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.emboss5x5_gpu"><code class="docutils literal notranslate"><span class="pre">emboss5x5_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.area24_gpu"><code class="docutils literal notranslate"><span class="pre">area24_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.brightness_gpu"><code class="docutils literal notranslate"><span class="pre">brightness_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.hsl_gpu"><code class="docutils literal notranslate"><span class="pre">hsl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.dithering_gpu"><code class="docutils literal notranslate"><span class="pre">dithering_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.fisheye_gpu"><code class="docutils literal notranslate"><span class="pre">fisheye_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.swirl_gpu"><code class="docutils literal notranslate"><span class="pre">swirl_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wave_gpu"><code class="docutils literal notranslate"><span class="pre">wave_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.chromatic_gpu"><code class="docutils literal notranslate"><span class="pre">chromatic_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.rgb_split_gpu"><code class="docutils literal notranslate"><span class="pre">rgb_split_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.zoom_gpu"><code class="docutils literal notranslate"><span class="pre">zoom_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.wavelength_map_gpu"><code class="docutils literal notranslate"><span class="pre">wavelength_map_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.heatmap_gpu_inplace"><code class="docutils literal notranslate"><span class="pre">heatmap_gpu_inplace()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.predator_gpu"><code class="docutils literal notranslate"><span class="pre">predator_gpu()</span></code></a></li>
<li><a class="reference internal" href="#Shader_gpu.downscale_surface_gpu"><code class="docutils literal notranslate"><span class="pre">downscale_surface_gpu()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Tema anterior</h4>
    <p class="topless"><a href="Shader.html"
                          title="capítulo anterior">Sombreado</a></p>
  </div>
  <div>
    <h4>Próximo tema</h4>
    <p class="topless"><a href="PygameTools.html"
                          title="próximo capítulo">PygameTools</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>Esta página</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Shader_gpu.rst.txt"
            rel="nofollow">Mostrar el código</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Búsqueda rápida</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Ir a" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             >índice</a></li>
        <li class="right" >
          <a href="PygameTools.html" title="PygameTools"
             >siguiente</a> |</li>
        <li class="right" >
          <a href="Shader.html" title="Sombreado"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">documentación de PygameShader - 1.0.11</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Shader_gpu</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Yoann Berenguer.
      Creado usando <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>